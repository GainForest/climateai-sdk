{"version":3,"sources":["../src/_internal/utilities/atproto/getBlobUrl.ts","../src/_internal/utilities/atproto/parseAtUri.ts","../src/_internal/server/utils/claims.ts","../src/_internal/zod-schemas/blobref.ts","../src/_internal/lib/isObject.ts","../src/_internal/utilities/transform/index.ts"],"names":["BlobRef"],"mappings":"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","file":"utilities.js","sourcesContent":["import {\n  type LargeBlob,\n  type LargeImage,\n  type SmallBlob,\n  type SmallImage,\n  type Uri,\n} from \"@/../lex-api/types/app/gainforest/common/defs\";\nimport type { $Typed } from \"@/../lex-api/util\";\nimport type { BlobRefGenerator } from \"@/_internal/zod-schemas/blobref\";\nimport { BlobRef } from \"@atproto/api\";\nimport { SupportedPDSDomain } from \"../..\";\n\nconst getBlobUrl = <T extends SupportedPDSDomain>(\n  did: string,\n  imageData:\n    | string\n    | BlobRef\n    | BlobRefGenerator\n    | $Typed<Uri | SmallImage | LargeImage | SmallBlob | LargeBlob>\n    | Uri\n    | SmallImage\n    | LargeImage\n    | SmallBlob\n    | LargeBlob,\n  pdsDomain: T\n) => {\n  if (typeof imageData === \"string\") {\n    const imageUrl = new URL(imageData);\n    return imageUrl.toString();\n  }\n\n  const isBlobRef =\n    imageData instanceof BlobRef ||\n    (\"ref\" in imageData && \"mimeType\" in imageData && \"size\" in imageData);\n  if (isBlobRef) {\n    const ref = imageData.ref as unknown as { $link?: string } | string;\n    const cid = typeof ref === \"string\" ? ref : (ref?.$link ?? String(ref));\n    const encodedCid = encodeURIComponent(cid);\n    return `https://${pdsDomain}/xrpc/com.atproto.sync.getBlob?did=${did}&cid=${encodedCid}`;\n  }\n\n  // Handle $Typed cases\n  if (imageData.$type === \"app.gainforest.common.defs#uri\") {\n    const uri = imageData.uri;\n    // TODO: handle other URI types\n    // if (uri.startsWith(\"at://\")) {\n    //   const { did: uriDid, rkey: uriRkey } = parseAtUri(uri);\n    //   return `${PDS_URL}/xrpc/com.atproto.repo.getRecord?did=${uriDid}&rkey=${uriRkey}`;\n    // }\n    return uri;\n  }\n\n  if (\n    imageData.$type === \"app.gainforest.common.defs#smallBlob\" ||\n    imageData.$type === \"app.gainforest.common.defs#largeBlob\"\n  ) {\n    const blob = imageData.blob;\n    return getBlobUrl(did, blob, pdsDomain);\n  }\n\n  if (\n    imageData.$type === \"app.gainforest.common.defs#smallImage\" ||\n    imageData.$type === \"app.gainforest.common.defs#largeImage\"\n  ) {\n    const image = imageData.image;\n    return getBlobUrl(did, image, pdsDomain);\n  }\n\n  if (\"blob\" in imageData) {\n    const blob = imageData.blob;\n    return getBlobUrl(did, blob, pdsDomain);\n  }\n\n  if (\"image\" in imageData) {\n    const image = imageData.image;\n    return getBlobUrl(did, image, pdsDomain);\n  }\n\n  if (\"uri\" in imageData) {\n    const uri = imageData.uri;\n    return uri;\n  }\n\n  // Line for compile time check that all cases are handled. THIS SHOULD NEVER BE REACHED.\n  const imageDataTypeCheck = imageData satisfies never;\n  return imageDataTypeCheck;\n};\n\nexport { getBlobUrl };\n","const parseAtUri = (atUri: string) => {\n  let cleanedAtUri = atUri.replace(\"at://\", \"\");\n\n  const splitUri = cleanedAtUri.split(\"/\");\n\n  const did = splitUri.at(0) ?? \"\";\n  const collection = splitUri.at(1) ?? \"\";\n  const rkey = splitUri.at(2) ?? \"self\";\n\n  return { did, collection, rkey };\n};\n\nexport { parseAtUri };\n","import type { Ecocert } from \"@/_internal/types/Ecocert\";\nimport type { OrganizationWithActivities as OrganizationWithActivitiesType } from \"@/_internal/server/routers/atproto/hypercerts/claim/activity/getAllAcrossOrgs\";\nimport { getBlobUrl } from \"@/_internal/utilities/atproto\";\nimport type { SupportedPDSDomain } from \"@/_internal/index\";\n\nexport const getEcocertsFromClaimActivities = (\n  activitiesWithOrgInfo: OrganizationWithActivitiesType[],\n  pdsDomain: SupportedPDSDomain\n): Ecocert[] => {\n  const ecocerts: Ecocert[] = [];\n  for (const activityWithOrgInfo of activitiesWithOrgInfo) {\n    const logo = activityWithOrgInfo.organizationInfo.logo;\n    const logoUrl =\n      logo ?\n        getBlobUrl(activityWithOrgInfo.repo.did, logo.image, pdsDomain)\n      : null;\n    for (const activity of activityWithOrgInfo.activities) {\n      ecocerts.push({\n        repo: {\n          did: activityWithOrgInfo.repo.did,\n        },\n        organizationInfo: {\n          name: activityWithOrgInfo.organizationInfo.displayName,\n          logoUrl: logoUrl,\n        },\n        claimActivity: activity,\n      });\n    }\n  }\n  return ecocerts;\n};\n","import z from \"zod\";\nimport { CID } from \"multiformats/cid\";\nimport type { Version } from \"multiformats/cid\";\nimport { BlobRef } from \"@atproto/api\";\n\nconst BlobRefGeneratorSchema = z.object({\n  $type: z.literal(\"blob-ref-generator\"),\n  ref: z.object({\n    $link: z.string(),\n  }),\n  mimeType: z.string(),\n  size: z.number(),\n});\n\ntype BlobRefGenerator = z.infer<typeof BlobRefGeneratorSchema>;\n\nconst toBlobRef = (input: BlobRefGenerator) => {\n  const validCID: CID<unknown, number, number, Version> = CID.parse(\n    input.ref.$link\n  );\n  return BlobRef.fromJsonRef({\n    $type: \"blob\",\n    ref: validCID,\n    mimeType: input.mimeType,\n    size: input.size,\n  });\n};\n\nconst toBlobRefGenerator = (blobRef: BlobRef): BlobRefGenerator => {\n  const json = blobRef.toJSON() as Omit<BlobRefGenerator, \"$type\"> & {\n    $type: \"blob\";\n  };\n  return {\n    $type: \"blob-ref-generator\",\n    ref: json.ref,\n    mimeType: json.mimeType,\n    size: json.size,\n  };\n};\n\nexport {\n  BlobRefGeneratorSchema,\n  toBlobRef,\n  toBlobRefGenerator,\n  type BlobRefGenerator,\n  BlobRef,\n};\n","export const isObject = (value: unknown): value is object => {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    !Array.isArray(value) &&\n    !(value instanceof RegExp) &&\n    !(value instanceof Date) &&\n    !(value instanceof Set) &&\n    !(value instanceof Map)\n  );\n};\n","// utils/transformer.ts\nimport type { DataTransformer } from \"@trpc/server\";\nimport superjson, { type SuperJSONResult } from \"superjson\";\nimport {\n  type BlobRefGenerator,\n  toBlobRef,\n} from \"@/_internal/zod-schemas/blobref\";\nimport { BlobRef } from \"@atproto/api\";\nimport { isObject } from \"@/_internal/lib/isObject\";\n\ntype ReplaceType<T, U, V> =\n  // If T directly extends U, substitute to V\n  T extends U ? V\n  : // If T is an array, recursively apply ReplaceType on the element type\n  T extends (infer Item)[] ? ReplaceType<Item, U, V>[]\n  : // If T is an object, recursively apply ReplaceType on all properties\n  T extends object ? { [K in keyof T]: ReplaceType<T[K], U, V> }\n  : // Otherwise, keep original type\n    T;\n\ntype Serialize<T> = ReplaceType<T, BlobRef, BlobRefGenerator>;\n\nconst _serialize = <T>(data: T): Serialize<T> => {\n  return JSON.parse(JSON.stringify(data)) as Serialize<T>;\n};\n\nconst _deserialize = <T>(data: Serialize<T>): T => {\n  const isObj = isObject(data);\n  if (!isObj) {\n    if (Array.isArray(data)) {\n      return data.map(_deserialize) as T;\n    }\n    return data as T;\n  }\n  if (\"$type\" in data && data.$type === \"blob\" && \"ref\" in data) {\n    try {\n      return toBlobRef(data as unknown as BlobRefGenerator) as T;\n    } catch {\n      return data as T;\n    }\n  }\n\n  const obj = data as Record<string, unknown>;\n  return Object.fromEntries(\n    Object.entries(obj).map(([key, value]) => [key, _deserialize(value)])\n  ) as T;\n};\n\nexport const customTransformer: DataTransformer = {\n  serialize: (object) => {\n    // typeof object = object\n    // This logic runs for transforming the query or mutation parameters before they are sent to the server.\n    // Conversion of object to string is automatically handled by TRPC.\n    const atprotoSerialized = _serialize(object);\n    const serializedObject = superjson.serialize(atprotoSerialized);\n    return serializedObject;\n  },\n  deserialize: <T>(object: SuperJSONResult): T => {\n    // typeof object = { json: object }\n    // This logic runs for transforming the query or mutation response before it is received by the client.\n    // The received response is automatically converted from stringified JSON to object by TRPC.\n    const superjsonDeserialized = superjson.deserialize(object) as Serialize<T>;\n    const deserializedObject = _deserialize(superjsonDeserialized);\n    // console.log(\"deserialized object\", deserializedObject);\n    return deserializedObject as T;\n  },\n};\n\nexport type SerializedSuperjson<T> = Omit<SuperJSONResult, \"json\"> & {\n  json: Serialize<T>;\n};\n\nexport const serialize = <T>(data: T) => {\n  const result = customTransformer.serialize(data);\n  return result as SerializedSuperjson<T>;\n};\n\nexport const deserialize = <T>(object: SerializedSuperjson<T>): T => {\n  return customTransformer.deserialize(object);\n};\n"]}