{"version":3,"sources":["../../node_modules/@atproto/xrpc/src/types.ts","../../node_modules/@atproto/xrpc/src/util.ts","../../node_modules/@atproto/xrpc/src/fetch-handler.ts","../../node_modules/@atproto/xrpc/src/xrpc-client.ts","../../node_modules/@atproto/xrpc/src/client.ts","../../node_modules/@atproto/xrpc/src/index.ts","../../lex-api/index.ts","../../lex-api/lexicons.ts","../../lex-api/util.ts","../../lex-api/types/app/certified/location.ts","../../lex-api/types/org/hypercerts/claim/claim.ts","../../lex-api/types/org/hypercerts/claim/contribution.ts","../../lex-api/types/org/hypercerts/claim/evaluation.ts","../../lex-api/types/org/hypercerts/claim/evidence.ts","../../lex-api/types/org/hypercerts/claim/measurement.ts","../../lex-api/types/org/hypercerts/claim/rights.ts","../../lex-api/types/org/hypercerts/collection.ts","../../lex-api/types/org/hypercerts/defs.ts","../../lex-api/types/app/gainforest/common/defs.ts","../../lex-api/types/app/gainforest/organization/defaultSite.ts","../../lex-api/types/app/gainforest/organization/getIndexedOrganizations.ts","../../lex-api/types/app/gainforest/organization/info.ts","../../lex-api/types/app/gainforest/organization/measuredTrees.ts","../../lex-api/types/app/gainforest/organization/site.ts","../../lex-api/types/com/atproto/repo/strongRef.ts"],"sourcesContent":["import { z } from 'zod'\nimport { ValidationError } from '@atproto/lexicon'\n\nexport type QueryParams = Record<string, any>\nexport type HeadersMap = Record<string, string | undefined>\n\nexport type {\n  /** @deprecated not to be confused with the WHATWG Headers constructor */\n  HeadersMap as Headers,\n}\n\nexport type Gettable<T> = T | (() => T)\n\nexport interface CallOptions {\n  encoding?: string\n  signal?: AbortSignal\n  headers?: HeadersMap\n}\n\nexport const errorResponseBody = z.object({\n  error: z.string().optional(),\n  message: z.string().optional(),\n})\nexport type ErrorResponseBody = z.infer<typeof errorResponseBody>\n\nexport enum ResponseType {\n  /**\n   * Network issue, unable to get response from the server.\n   */\n  Unknown = 1,\n  /**\n   * Response failed lexicon validation.\n   */\n  InvalidResponse = 2,\n  Success = 200,\n  InvalidRequest = 400,\n  AuthenticationRequired = 401,\n  Forbidden = 403,\n  XRPCNotSupported = 404,\n  NotAcceptable = 406,\n  PayloadTooLarge = 413,\n  UnsupportedMediaType = 415,\n  RateLimitExceeded = 429,\n  InternalServerError = 500,\n  MethodNotImplemented = 501,\n  UpstreamFailure = 502,\n  NotEnoughResources = 503,\n  UpstreamTimeout = 504,\n}\n\nexport function httpResponseCodeToEnum(status: number): ResponseType {\n  if (status in ResponseType) {\n    return status\n  } else if (status >= 100 && status < 200) {\n    return ResponseType.XRPCNotSupported\n  } else if (status >= 200 && status < 300) {\n    return ResponseType.Success\n  } else if (status >= 300 && status < 400) {\n    return ResponseType.XRPCNotSupported\n  } else if (status >= 400 && status < 500) {\n    return ResponseType.InvalidRequest\n  } else {\n    return ResponseType.InternalServerError\n  }\n}\n\nexport function httpResponseCodeToName(status: number): string {\n  return ResponseType[httpResponseCodeToEnum(status)]\n}\n\nexport const ResponseTypeStrings = {\n  [ResponseType.Unknown]: 'Unknown',\n  [ResponseType.InvalidResponse]: 'Invalid Response',\n  [ResponseType.Success]: 'Success',\n  [ResponseType.InvalidRequest]: 'Invalid Request',\n  [ResponseType.AuthenticationRequired]: 'Authentication Required',\n  [ResponseType.Forbidden]: 'Forbidden',\n  [ResponseType.XRPCNotSupported]: 'XRPC Not Supported',\n  [ResponseType.NotAcceptable]: 'Not Acceptable',\n  [ResponseType.PayloadTooLarge]: 'Payload Too Large',\n  [ResponseType.UnsupportedMediaType]: 'Unsupported Media Type',\n  [ResponseType.RateLimitExceeded]: 'Rate Limit Exceeded',\n  [ResponseType.InternalServerError]: 'Internal Server Error',\n  [ResponseType.MethodNotImplemented]: 'Method Not Implemented',\n  [ResponseType.UpstreamFailure]: 'Upstream Failure',\n  [ResponseType.NotEnoughResources]: 'Not Enough Resources',\n  [ResponseType.UpstreamTimeout]: 'Upstream Timeout',\n} as const satisfies Record<ResponseType, string>\n\nexport function httpResponseCodeToString(status: number): string {\n  return ResponseTypeStrings[httpResponseCodeToEnum(status)]\n}\n\nexport class XRPCResponse {\n  success = true\n\n  constructor(\n    public data: any,\n    public headers: HeadersMap,\n  ) {}\n}\n\nexport class XRPCError extends Error {\n  success = false\n\n  public status: ResponseType\n\n  constructor(\n    statusCode: number,\n    public error: string = httpResponseCodeToName(statusCode),\n    message?: string,\n    public headers?: HeadersMap,\n    options?: ErrorOptions,\n  ) {\n    super(message || error || httpResponseCodeToString(statusCode), options)\n\n    this.status = httpResponseCodeToEnum(statusCode)\n\n    // Pre 2022 runtimes won't handle the \"options\" constructor argument\n    const cause = options?.cause\n    if (this.cause === undefined && cause !== undefined) {\n      this.cause = cause\n    }\n  }\n\n  static from(cause: unknown, fallbackStatus?: ResponseType): XRPCError {\n    if (cause instanceof XRPCError) {\n      return cause\n    }\n\n    // Type cast the cause to an Error if it is one\n    const causeErr = cause instanceof Error ? cause : undefined\n\n    // Try and find a Response object in the cause\n    const causeResponse: Response | undefined =\n      cause instanceof Response\n        ? cause\n        : cause?.['response'] instanceof Response\n          ? cause['response']\n          : undefined\n\n    const statusCode: unknown =\n      // Extract status code from \"http-errors\" like errors\n      causeErr?.['statusCode'] ??\n      causeErr?.['status'] ??\n      // Use the status code from the response object as fallback\n      causeResponse?.status\n\n    // Convert the status code to a ResponseType\n    const status: ResponseType =\n      typeof statusCode === 'number'\n        ? httpResponseCodeToEnum(statusCode)\n        : fallbackStatus ?? ResponseType.Unknown\n\n    const message = causeErr?.message ?? String(cause)\n\n    const headers = causeResponse\n      ? Object.fromEntries(causeResponse.headers.entries())\n      : undefined\n\n    return new XRPCError(status, undefined, message, headers, { cause })\n  }\n}\n\nexport class XRPCInvalidResponseError extends XRPCError {\n  constructor(\n    public lexiconNsid: string,\n    public validationError: ValidationError,\n    public responseBody: unknown,\n  ) {\n    super(\n      ResponseType.InvalidResponse,\n      // @NOTE: This is probably wrong and should use ResponseTypeNames instead.\n      // But it would mean a breaking change.\n      ResponseTypeStrings[ResponseType.InvalidResponse],\n      `The server gave an invalid response and may be out of date.`,\n      undefined,\n      { cause: validationError },\n    )\n  }\n}\n","import {\n  LexXrpcProcedure,\n  LexXrpcQuery,\n  jsonStringToLex,\n  stringifyLex,\n} from '@atproto/lexicon'\nimport {\n  CallOptions,\n  ErrorResponseBody,\n  Gettable,\n  QueryParams,\n  ResponseType,\n  XRPCError,\n  errorResponseBody,\n} from './types'\n\nconst ReadableStream =\n  globalThis.ReadableStream ||\n  (class {\n    constructor() {\n      // This anonymous class will never pass any \"instanceof\" check and cannot\n      // be instantiated.\n      throw new Error('ReadableStream is not supported in this environment')\n    }\n  } as typeof globalThis.ReadableStream)\n\nexport function isErrorResponseBody(v: unknown): v is ErrorResponseBody {\n  return errorResponseBody.safeParse(v).success\n}\n\nexport function getMethodSchemaHTTPMethod(\n  schema: LexXrpcProcedure | LexXrpcQuery,\n) {\n  if (schema.type === 'procedure') {\n    return 'post'\n  }\n  return 'get'\n}\n\nexport function constructMethodCallUri(\n  nsid: string,\n  schema: LexXrpcProcedure | LexXrpcQuery,\n  serviceUri: URL,\n  params?: QueryParams,\n): string {\n  const uri = new URL(constructMethodCallUrl(nsid, schema, params), serviceUri)\n  return uri.toString()\n}\n\nexport function constructMethodCallUrl(\n  nsid: string,\n  schema: LexXrpcProcedure | LexXrpcQuery,\n  params?: QueryParams,\n): string {\n  const pathname = `/xrpc/${encodeURIComponent(nsid)}`\n  if (!params) return pathname\n\n  const searchParams: [string, string][] = []\n\n  for (const [key, value] of Object.entries(params)) {\n    const paramSchema = schema.parameters?.properties?.[key]\n    if (!paramSchema) {\n      throw new Error(`Invalid query parameter: ${key}`)\n    }\n    if (value !== undefined) {\n      if (paramSchema.type === 'array') {\n        const values = Array.isArray(value) ? value : [value]\n        for (const val of values) {\n          searchParams.push([\n            key,\n            encodeQueryParam(paramSchema.items.type, val),\n          ])\n        }\n      } else {\n        searchParams.push([key, encodeQueryParam(paramSchema.type, value)])\n      }\n    }\n  }\n\n  if (!searchParams.length) return pathname\n\n  return `${pathname}?${new URLSearchParams(searchParams).toString()}`\n}\n\nexport function encodeQueryParam(\n  type:\n    | 'string'\n    | 'float'\n    | 'integer'\n    | 'boolean'\n    | 'datetime'\n    | 'array'\n    | 'unknown',\n  value: any,\n): string {\n  if (type === 'string' || type === 'unknown') {\n    return String(value)\n  }\n  if (type === 'float') {\n    return String(Number(value))\n  } else if (type === 'integer') {\n    return String(Number(value) | 0)\n  } else if (type === 'boolean') {\n    return value ? 'true' : 'false'\n  } else if (type === 'datetime') {\n    if (value instanceof Date) {\n      return value.toISOString()\n    }\n    return String(value)\n  }\n  throw new Error(`Unsupported query param type: ${type}`)\n}\n\nexport function constructMethodCallHeaders(\n  schema: LexXrpcProcedure | LexXrpcQuery,\n  data?: unknown,\n  opts?: CallOptions,\n): Headers {\n  // Not using `new Headers(opts?.headers)` to avoid duplicating headers values\n  // due to inconsistent casing in headers name. In case of multiple headers\n  // with the same name (but using a different case), the last one will be used.\n\n  // new Headers({ 'content-type': 'foo', 'Content-Type': 'bar' }).get('content-type')\n  // => 'foo, bar'\n  const headers = new Headers()\n\n  if (opts?.headers) {\n    for (const name in opts.headers) {\n      if (headers.has(name)) {\n        throw new TypeError(`Duplicate header: ${name}`)\n      }\n\n      const value = opts.headers[name]\n      if (value != null) {\n        headers.set(name, value)\n      }\n    }\n  }\n\n  if (schema.type === 'procedure') {\n    if (opts?.encoding) {\n      headers.set('content-type', opts.encoding)\n    } else if (!headers.has('content-type') && typeof data !== 'undefined') {\n      // Special handling of BodyInit types before falling back to JSON encoding\n      if (\n        data instanceof ArrayBuffer ||\n        data instanceof ReadableStream ||\n        ArrayBuffer.isView(data)\n      ) {\n        headers.set('content-type', 'application/octet-stream')\n      } else if (data instanceof FormData) {\n        // Note: The multipart form data boundary is missing from the header\n        // we set here, making that header invalid. This special case will be\n        // handled in encodeMethodCallBody()\n        headers.set('content-type', 'multipart/form-data')\n      } else if (data instanceof URLSearchParams) {\n        headers.set(\n          'content-type',\n          'application/x-www-form-urlencoded;charset=UTF-8',\n        )\n      } else if (isBlobLike(data)) {\n        headers.set('content-type', data.type || 'application/octet-stream')\n      } else if (typeof data === 'string') {\n        headers.set('content-type', 'text/plain;charset=UTF-8')\n      }\n      // At this point, data is not a valid BodyInit type.\n      else if (isIterable(data)) {\n        headers.set('content-type', 'application/octet-stream')\n      } else if (\n        typeof data === 'boolean' ||\n        typeof data === 'number' ||\n        typeof data === 'string' ||\n        typeof data === 'object' // covers \"null\"\n      ) {\n        headers.set('content-type', 'application/json')\n      } else {\n        // symbol, function, bigint\n        throw new XRPCError(\n          ResponseType.InvalidRequest,\n          `Unsupported data type: ${typeof data}`,\n        )\n      }\n    }\n  }\n  return headers\n}\n\nexport function combineHeaders(\n  headersInit: undefined | HeadersInit,\n  defaultHeaders?: Iterable<[string, undefined | Gettable<null | string>]>,\n): undefined | HeadersInit {\n  if (!defaultHeaders) return headersInit\n\n  let headers: Headers | undefined = undefined\n\n  for (const [name, definition] of defaultHeaders) {\n    // Ignore undefined values (allowed for convenience when using\n    // Object.entries).\n    if (definition === undefined) continue\n\n    // Lazy initialization of the headers object\n    headers ??= new Headers(headersInit)\n\n    if (headers.has(name)) continue\n\n    const value = typeof definition === 'function' ? definition() : definition\n\n    if (typeof value === 'string') headers.set(name, value)\n    else if (value === null) headers.delete(name)\n    else throw new TypeError(`Invalid \"${name}\" header value: ${typeof value}`)\n  }\n\n  return headers ?? headersInit\n}\n\nfunction isBlobLike(value: unknown): value is Blob {\n  if (value == null) return false\n  if (typeof value !== 'object') return false\n  if (typeof Blob === 'function' && value instanceof Blob) return true\n\n  // Support for Blobs provided by libraries that don't use the native Blob\n  // (e.g. fetch-blob from node-fetch).\n  // https://github.com/node-fetch/fetch-blob/blob/a1a182e5978811407bef4ea1632b517567dda01f/index.js#L233-L244\n\n  const tag = value[Symbol.toStringTag]\n  if (tag === 'Blob' || tag === 'File') {\n    return 'stream' in value && typeof value.stream === 'function'\n  }\n\n  return false\n}\n\nexport function isBodyInit(value: unknown): value is BodyInit {\n  switch (typeof value) {\n    case 'string':\n      return true\n    case 'object':\n      return (\n        value instanceof ArrayBuffer ||\n        value instanceof FormData ||\n        value instanceof URLSearchParams ||\n        value instanceof ReadableStream ||\n        ArrayBuffer.isView(value) ||\n        isBlobLike(value)\n      )\n    default:\n      return false\n  }\n}\n\nexport function isIterable(\n  value: unknown,\n): value is Iterable<unknown> | AsyncIterable<unknown> {\n  return (\n    value != null &&\n    typeof value === 'object' &&\n    (Symbol.iterator in value || Symbol.asyncIterator in value)\n  )\n}\n\nexport function encodeMethodCallBody(\n  headers: Headers,\n  data?: unknown,\n): BodyInit | undefined {\n  // Silently ignore the body if there is no content-type header.\n  const contentType = headers.get('content-type')\n  if (!contentType) {\n    return undefined\n  }\n\n  if (typeof data === 'undefined') {\n    // This error would be returned by the server, but we can catch it earlier\n    // to avoid un-necessary requests. Note that a content-length of 0 does not\n    // necessary mean that the body is \"empty\" (e.g. an empty txt file).\n    throw new XRPCError(\n      ResponseType.InvalidRequest,\n      `A request body is expected but none was provided`,\n    )\n  }\n\n  if (isBodyInit(data)) {\n    if (data instanceof FormData && contentType === 'multipart/form-data') {\n      // fetch() will encode FormData payload itself, but it won't override the\n      // content-type header if already present. This would cause the boundary\n      // to be missing from the content-type header, resulting in a 400 error.\n      // Deleting the content-type header here to let fetch() re-create it.\n      headers.delete('content-type')\n    }\n\n    // Will be encoded by the fetch API.\n    return data\n  }\n\n  if (isIterable(data)) {\n    // Note that some environments support using Iterable & AsyncIterable as the\n    // body (e.g. Node's fetch), but not all of them do (browsers).\n    return iterableToReadableStream(data)\n  }\n\n  if (contentType.startsWith('text/')) {\n    return new TextEncoder().encode(String(data))\n  }\n  if (contentType.startsWith('application/json')) {\n    const json = stringifyLex(data)\n    // Server would return a 400 error if the JSON is invalid (e.g. trying to\n    // JSONify a function, or an object that implements toJSON() poorly).\n    if (json === undefined) {\n      throw new XRPCError(\n        ResponseType.InvalidRequest,\n        `Failed to encode request body as JSON`,\n      )\n    }\n    return new TextEncoder().encode(json)\n  }\n\n  // At this point, \"data\" is not a valid BodyInit value, and we don't know how\n  // to encode it into one. Passing it to fetch would result in an error. Let's\n  // throw our own error instead.\n\n  const type =\n    !data || typeof data !== 'object'\n      ? typeof data\n      : data.constructor !== Object &&\n          typeof data.constructor === 'function' &&\n          typeof data.constructor?.name === 'string'\n        ? data.constructor.name\n        : 'object'\n\n  throw new XRPCError(\n    ResponseType.InvalidRequest,\n    `Unable to encode ${type} as ${contentType} data`,\n  )\n}\n\n/**\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/from_static}\n */\nfunction iterableToReadableStream(\n  iterable: Iterable<unknown> | AsyncIterable<unknown>,\n): ReadableStream<Uint8Array> {\n  // Use the native ReadableStream.from() if available.\n  if ('from' in ReadableStream && typeof ReadableStream.from === 'function') {\n    return ReadableStream.from(iterable)\n  }\n\n  // If you see this error, consider using a polyfill for ReadableStream. For\n  // example, the \"web-streams-polyfill\" package:\n  // https://github.com/MattiasBuelens/web-streams-polyfill\n\n  throw new TypeError(\n    'ReadableStream.from() is not supported in this environment. ' +\n      'It is required to support using iterables as the request body. ' +\n      'Consider using a polyfill or re-write your code to use a different body type.',\n  )\n}\n\nexport function httpResponseBodyParse(\n  mimeType: string | null,\n  data: ArrayBuffer | undefined,\n): any {\n  try {\n    if (mimeType) {\n      if (mimeType.includes('application/json')) {\n        const str = new TextDecoder().decode(data)\n        return jsonStringToLex(str)\n      }\n      if (mimeType.startsWith('text/')) {\n        return new TextDecoder().decode(data)\n      }\n    }\n    if (data instanceof ArrayBuffer) {\n      return new Uint8Array(data)\n    }\n    return data\n  } catch (cause) {\n    throw new XRPCError(\n      ResponseType.InvalidResponse,\n      undefined,\n      `Failed to parse response body: ${String(cause)}`,\n      undefined,\n      { cause },\n    )\n  }\n}\n","import { Gettable } from './types'\nimport { combineHeaders } from './util'\n\nexport type FetchHandler = (\n  this: void,\n  /**\n   * The URL (pathname + query parameters) to make the request to, without the\n   * origin. The origin (protocol, hostname, and port) must be added by this\n   * {@link FetchHandler}, typically based on authentication or other factors.\n   */\n  url: string,\n  init: RequestInit,\n) => Promise<Response>\n\nexport type FetchHandlerOptions = BuildFetchHandlerOptions | string | URL\n\nexport type BuildFetchHandlerOptions = {\n  /**\n   * The service URL to make requests to. This can be a string, URL, or a\n   * function that returns a string or URL. This is useful for dynamic URLs,\n   * such as a service URL that changes based on authentication.\n   */\n  service: Gettable<string | URL>\n\n  /**\n   * Headers to be added to every request. If a function is provided, it will be\n   * called on each request to get the headers. This is useful for dynamic\n   * headers, such as authentication tokens that may expire.\n   */\n  headers?: {\n    [_ in string]?: Gettable<null | string>\n  }\n\n  /**\n   * Bring your own fetch implementation. Typically useful for testing, logging,\n   * mocking, or adding retries, session management, signatures, proof of\n   * possession (DPoP), SSRF protection, etc. Defaults to the global `fetch`\n   * function.\n   */\n  fetch?: typeof globalThis.fetch\n}\n\nexport interface FetchHandlerObject {\n  fetchHandler: (\n    this: FetchHandlerObject,\n    /**\n     * The URL (pathname + query parameters) to make the request to, without the\n     * origin. The origin (protocol, hostname, and port) must be added by this\n     * {@link FetchHandler}, typically based on authentication or other factors.\n     */\n    url: string,\n    init: RequestInit,\n  ) => Promise<Response>\n}\n\nexport function buildFetchHandler(\n  options: FetchHandler | FetchHandlerObject | FetchHandlerOptions,\n): FetchHandler {\n  // Already a fetch handler (allowed for convenience)\n  if (typeof options === 'function') return options\n  if (typeof options === 'object' && 'fetchHandler' in options) {\n    return options.fetchHandler.bind(options)\n  }\n\n  const {\n    service,\n    headers: defaultHeaders = undefined,\n    fetch = globalThis.fetch,\n  } = typeof options === 'string' || options instanceof URL\n    ? { service: options }\n    : options\n\n  if (typeof fetch !== 'function') {\n    throw new TypeError(\n      'XrpcDispatcher requires fetch() to be available in your environment.',\n    )\n  }\n\n  const defaultHeadersEntries =\n    defaultHeaders != null ? Object.entries(defaultHeaders) : undefined\n\n  return async function (url, init) {\n    const base = typeof service === 'function' ? service() : service\n    const fullUrl = new URL(url, base)\n\n    const headers = combineHeaders(init.headers, defaultHeadersEntries)\n\n    return fetch(fullUrl, { ...init, headers })\n  }\n}\n","import { LexiconDoc, Lexicons, ValidationError } from '@atproto/lexicon'\nimport {\n  FetchHandler,\n  FetchHandlerObject,\n  FetchHandlerOptions,\n  buildFetchHandler,\n} from './fetch-handler'\nimport {\n  CallOptions,\n  Gettable,\n  QueryParams,\n  ResponseType,\n  XRPCError,\n  XRPCInvalidResponseError,\n  XRPCResponse,\n  httpResponseCodeToEnum,\n} from './types'\nimport {\n  combineHeaders,\n  constructMethodCallHeaders,\n  constructMethodCallUrl,\n  encodeMethodCallBody,\n  getMethodSchemaHTTPMethod,\n  httpResponseBodyParse,\n  isErrorResponseBody,\n} from './util'\n\nexport class XrpcClient {\n  readonly fetchHandler: FetchHandler\n  readonly headers = new Map<string, Gettable<null | string>>()\n  readonly lex: Lexicons\n\n  constructor(\n    fetchHandlerOpts: FetchHandler | FetchHandlerObject | FetchHandlerOptions,\n    // \"Lexicons\" is redundant here (because that class implements\n    // \"Iterable<LexiconDoc>\") but we keep it for explicitness:\n    lex: Lexicons | Iterable<LexiconDoc>,\n  ) {\n    this.fetchHandler = buildFetchHandler(fetchHandlerOpts)\n\n    this.lex = lex instanceof Lexicons ? lex : new Lexicons(lex)\n  }\n\n  setHeader(key: string, value: Gettable<null | string>): void {\n    this.headers.set(key.toLowerCase(), value)\n  }\n\n  unsetHeader(key: string): void {\n    this.headers.delete(key.toLowerCase())\n  }\n\n  clearHeaders(): void {\n    this.headers.clear()\n  }\n\n  async call(\n    methodNsid: string,\n    params?: QueryParams,\n    data?: unknown,\n    opts?: CallOptions,\n  ): Promise<XRPCResponse> {\n    const def = this.lex.getDefOrThrow(methodNsid)\n    if (!def || (def.type !== 'query' && def.type !== 'procedure')) {\n      throw new TypeError(\n        `Invalid lexicon: ${methodNsid}. Must be a query or procedure.`,\n      )\n    }\n\n    // @TODO: should we validate the params and data here?\n    // this.lex.assertValidXrpcParams(methodNsid, params)\n    // if (data !== undefined) {\n    //   this.lex.assertValidXrpcInput(methodNsid, data)\n    // }\n\n    const reqUrl = constructMethodCallUrl(methodNsid, def, params)\n    const reqMethod = getMethodSchemaHTTPMethod(def)\n    const reqHeaders = constructMethodCallHeaders(def, data, opts)\n    const reqBody = encodeMethodCallBody(reqHeaders, data)\n\n    // The duplex field is required for streaming bodies, but not yet reflected\n    // anywhere in docs or types. See whatwg/fetch#1438, nodejs/node#46221.\n    const init: RequestInit & { duplex: 'half' } = {\n      method: reqMethod,\n      headers: combineHeaders(reqHeaders, this.headers),\n      body: reqBody,\n      duplex: 'half',\n      redirect: 'follow',\n      signal: opts?.signal,\n    }\n\n    try {\n      const response = await this.fetchHandler.call(undefined, reqUrl, init)\n\n      const resStatus = response.status\n      const resHeaders = Object.fromEntries(response.headers.entries())\n      const resBodyBytes = await response.arrayBuffer()\n      const resBody = httpResponseBodyParse(\n        response.headers.get('content-type'),\n        resBodyBytes,\n      )\n\n      const resCode = httpResponseCodeToEnum(resStatus)\n      if (resCode !== ResponseType.Success) {\n        const { error = undefined, message = undefined } =\n          resBody && isErrorResponseBody(resBody) ? resBody : {}\n        throw new XRPCError(resCode, error, message, resHeaders)\n      }\n\n      try {\n        this.lex.assertValidXrpcOutput(methodNsid, resBody)\n      } catch (e: unknown) {\n        if (e instanceof ValidationError) {\n          throw new XRPCInvalidResponseError(methodNsid, e, resBody)\n        }\n\n        throw e\n      }\n\n      return new XRPCResponse(resBody, resHeaders)\n    } catch (err) {\n      throw XRPCError.from(err)\n    }\n  }\n}\n","import { LexiconDoc, Lexicons } from '@atproto/lexicon'\nimport { CallOptions, QueryParams } from './types'\nimport { combineHeaders } from './util'\nimport { XrpcClient } from './xrpc-client'\n\n/** @deprecated Use {@link XrpcClient} instead */\nexport class Client {\n  /** @deprecated */\n  get fetch(): never {\n    throw new Error(\n      'Client.fetch is no longer supported. Use an XrpcClient instead.',\n    )\n  }\n\n  /** @deprecated */\n  set fetch(_: never) {\n    throw new Error(\n      'Client.fetch is no longer supported. Use an XrpcClient instead.',\n    )\n  }\n\n  lex = new Lexicons()\n\n  // method calls\n  //\n\n  async call(\n    serviceUri: string | URL,\n    methodNsid: string,\n    params?: QueryParams,\n    data?: BodyInit | null,\n    opts?: CallOptions,\n  ) {\n    return this.service(serviceUri).call(methodNsid, params, data, opts)\n  }\n\n  service(serviceUri: string | URL) {\n    return new ServiceClient(this, serviceUri)\n  }\n\n  // schemas\n  // =\n\n  addLexicon(doc: LexiconDoc) {\n    this.lex.add(doc)\n  }\n\n  addLexicons(docs: LexiconDoc[]) {\n    for (const doc of docs) {\n      this.addLexicon(doc)\n    }\n  }\n\n  removeLexicon(uri: string) {\n    this.lex.remove(uri)\n  }\n}\n\n/** @deprecated Use {@link XrpcClient} instead */\nexport class ServiceClient extends XrpcClient {\n  uri: URL\n\n  constructor(\n    public baseClient: Client,\n    serviceUri: string | URL,\n  ) {\n    super(async (input, init) => {\n      const headers = combineHeaders(init.headers, Object.entries(this.headers))\n      return fetch(new URL(input, this.uri), { ...init, headers })\n    }, baseClient.lex)\n    this.uri = typeof serviceUri === 'string' ? new URL(serviceUri) : serviceUri\n  }\n}\n","export * from './client'\nexport * from './fetch-handler'\nexport * from './types'\nexport * from './util'\nexport * from './xrpc-client'\n\n/* eslint-disable import/no-deprecated */\nimport { Client } from './client'\n/** @deprecated create a local {@link XrpcClient} instance instead */\nconst defaultInst = new Client()\nexport default defaultInst\n/* eslint-enable import/no-deprecated */\n","/**\n * The following lines are added by lex-api-mod.ts to fix build errors.\n */\nimport {\n  ComAtprotoRepoListRecords,\n  ComAtprotoRepoGetRecord,\n  ComAtprotoRepoCreateRecord,\n  ComAtprotoRepoPutRecord,\n  ComAtprotoRepoDeleteRecord,\n} from \"@atproto/api\";\n/**\n * GENERATED CODE - DO NOT MODIFY\n */\n\n/**\n * GENERATED CODE - DO NOT MODIFY\n */\nimport {\n  XrpcClient,\n  type FetchHandler,\n  type FetchHandlerOptions,\n} from '@atproto/xrpc'\nimport { schemas } from './lexicons.js'\nimport { CID } from 'multiformats/cid'\nimport { type OmitKey, type Un$Typed } from './util.js'\nimport * as AppCertifiedLocation from './types/app/certified/location.js'\nimport * as OrgHypercertsClaimClaim from './types/org/hypercerts/claim/claim.js'\nimport * as OrgHypercertsClaimContribution from './types/org/hypercerts/claim/contribution.js'\nimport * as OrgHypercertsClaimEvaluation from './types/org/hypercerts/claim/evaluation.js'\nimport * as OrgHypercertsClaimEvidence from './types/org/hypercerts/claim/evidence.js'\nimport * as OrgHypercertsClaimMeasurement from './types/org/hypercerts/claim/measurement.js'\nimport * as OrgHypercertsClaimRights from './types/org/hypercerts/claim/rights.js'\nimport * as OrgHypercertsCollection from './types/org/hypercerts/collection.js'\nimport * as OrgHypercertsDefs from './types/org/hypercerts/defs.js'\nimport * as AppGainforestCommonDefs from './types/app/gainforest/common/defs.js'\nimport * as AppGainforestOrganizationDefaultSite from './types/app/gainforest/organization/defaultSite.js'\nimport * as AppGainforestOrganizationGetIndexedOrganizations from './types/app/gainforest/organization/getIndexedOrganizations.js'\nimport * as AppGainforestOrganizationInfo from './types/app/gainforest/organization/info.js'\nimport * as AppGainforestOrganizationMeasuredTrees from './types/app/gainforest/organization/measuredTrees.js'\nimport * as AppGainforestOrganizationSite from './types/app/gainforest/organization/site.js'\nimport * as ComAtprotoRepoStrongRef from './types/com/atproto/repo/strongRef.js'\n\nexport * as AppCertifiedLocation from './types/app/certified/location.js'\nexport * as OrgHypercertsClaimClaim from './types/org/hypercerts/claim/claim.js'\nexport * as OrgHypercertsClaimContribution from './types/org/hypercerts/claim/contribution.js'\nexport * as OrgHypercertsClaimEvaluation from './types/org/hypercerts/claim/evaluation.js'\nexport * as OrgHypercertsClaimEvidence from './types/org/hypercerts/claim/evidence.js'\nexport * as OrgHypercertsClaimMeasurement from './types/org/hypercerts/claim/measurement.js'\nexport * as OrgHypercertsClaimRights from './types/org/hypercerts/claim/rights.js'\nexport * as OrgHypercertsCollection from './types/org/hypercerts/collection.js'\nexport * as OrgHypercertsDefs from './types/org/hypercerts/defs.js'\nexport * as AppGainforestCommonDefs from './types/app/gainforest/common/defs.js'\nexport * as AppGainforestOrganizationDefaultSite from './types/app/gainforest/organization/defaultSite.js'\nexport * as AppGainforestOrganizationGetIndexedOrganizations from './types/app/gainforest/organization/getIndexedOrganizations.js'\nexport * as AppGainforestOrganizationInfo from './types/app/gainforest/organization/info.js'\nexport * as AppGainforestOrganizationMeasuredTrees from './types/app/gainforest/organization/measuredTrees.js'\nexport * as AppGainforestOrganizationSite from './types/app/gainforest/organization/site.js'\nexport * as ComAtprotoRepoStrongRef from './types/com/atproto/repo/strongRef.js'\n\nexport class AtpBaseClient extends XrpcClient {\n  app: AppNS\n  org: OrgNS\n  com: ComNS\n\n  constructor(options: FetchHandler | FetchHandlerOptions) {\n    super(options, schemas)\n    this.app = new AppNS(this)\n    this.org = new OrgNS(this)\n    this.com = new ComNS(this)\n  }\n\n  /** @deprecated use `this` instead */\n  get xrpc(): XrpcClient {\n    return this\n  }\n}\n\nexport class AppNS {\n  _client: XrpcClient\n  certified: AppCertifiedNS\n  gainforest: AppGainforestNS\n\n  constructor(client: XrpcClient) {\n    this._client = client\n    this.certified = new AppCertifiedNS(client)\n    this.gainforest = new AppGainforestNS(client)\n  }\n}\n\nexport class AppCertifiedNS {\n  _client: XrpcClient\n  location: AppCertifiedLocationRecord\n\n  constructor(client: XrpcClient) {\n    this._client = client\n    this.location = new AppCertifiedLocationRecord(client)\n  }\n}\n\nexport class AppCertifiedLocationRecord {\n  _client: XrpcClient\n\n  constructor(client: XrpcClient) {\n    this._client = client\n  }\n\n  async list(\n    params: OmitKey<ComAtprotoRepoListRecords.QueryParams, 'collection'>,\n  ): Promise<{\n    cursor?: string\n    records: { uri: string; value: AppCertifiedLocation.Record }[]\n  }> {\n    const res = await this._client.call('com.atproto.repo.listRecords', {\n      collection: 'app.certified.location',\n      ...params,\n    })\n    return res.data\n  }\n\n  async get(\n    params: OmitKey<ComAtprotoRepoGetRecord.QueryParams, 'collection'>,\n  ): Promise<{ uri: string; cid: string; value: AppCertifiedLocation.Record }> {\n    const res = await this._client.call('com.atproto.repo.getRecord', {\n      collection: 'app.certified.location',\n      ...params,\n    })\n    return res.data\n  }\n\n  async create(\n    params: OmitKey<\n      ComAtprotoRepoCreateRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<AppCertifiedLocation.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'app.certified.location'\n    const res = await this._client.call(\n      'com.atproto.repo.createRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async put(\n    params: OmitKey<\n      ComAtprotoRepoPutRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<AppCertifiedLocation.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'app.certified.location'\n    const res = await this._client.call(\n      'com.atproto.repo.putRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async delete(\n    params: OmitKey<ComAtprotoRepoDeleteRecord.InputSchema, 'collection'>,\n    headers?: Record<string, string>,\n  ): Promise<void> {\n    await this._client.call(\n      'com.atproto.repo.deleteRecord',\n      undefined,\n      { collection: 'app.certified.location', ...params },\n      { headers },\n    )\n  }\n}\n\nexport class AppGainforestNS {\n  _client: XrpcClient\n  organization: AppGainforestOrganizationNS\n\n  constructor(client: XrpcClient) {\n    this._client = client\n    this.organization = new AppGainforestOrganizationNS(client)\n  }\n}\n\nexport class AppGainforestOrganizationNS {\n  _client: XrpcClient\n  defaultSite: AppGainforestOrganizationDefaultSiteRecord\n  info: AppGainforestOrganizationInfoRecord\n  measuredTrees: AppGainforestOrganizationMeasuredTreesRecord\n  site: AppGainforestOrganizationSiteRecord\n\n  constructor(client: XrpcClient) {\n    this._client = client\n    this.defaultSite = new AppGainforestOrganizationDefaultSiteRecord(client)\n    this.info = new AppGainforestOrganizationInfoRecord(client)\n    this.measuredTrees = new AppGainforestOrganizationMeasuredTreesRecord(\n      client,\n    )\n    this.site = new AppGainforestOrganizationSiteRecord(client)\n  }\n\n  getIndexedOrganizations(\n    params?: AppGainforestOrganizationGetIndexedOrganizations.QueryParams,\n    opts?: AppGainforestOrganizationGetIndexedOrganizations.CallOptions,\n  ): Promise<AppGainforestOrganizationGetIndexedOrganizations.Response> {\n    return this._client.call(\n      'app.gainforest.organization.getIndexedOrganizations',\n      params,\n      undefined,\n      opts,\n    )\n  }\n}\n\nexport class AppGainforestOrganizationDefaultSiteRecord {\n  _client: XrpcClient\n\n  constructor(client: XrpcClient) {\n    this._client = client\n  }\n\n  async list(\n    params: OmitKey<ComAtprotoRepoListRecords.QueryParams, 'collection'>,\n  ): Promise<{\n    cursor?: string\n    records: {\n      uri: string\n      value: AppGainforestOrganizationDefaultSite.Record\n    }[]\n  }> {\n    const res = await this._client.call('com.atproto.repo.listRecords', {\n      collection: 'app.gainforest.organization.defaultSite',\n      ...params,\n    })\n    return res.data\n  }\n\n  async get(\n    params: OmitKey<ComAtprotoRepoGetRecord.QueryParams, 'collection'>,\n  ): Promise<{\n    uri: string\n    cid: string\n    value: AppGainforestOrganizationDefaultSite.Record\n  }> {\n    const res = await this._client.call('com.atproto.repo.getRecord', {\n      collection: 'app.gainforest.organization.defaultSite',\n      ...params,\n    })\n    return res.data\n  }\n\n  async create(\n    params: OmitKey<\n      ComAtprotoRepoCreateRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<AppGainforestOrganizationDefaultSite.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'app.gainforest.organization.defaultSite'\n    const res = await this._client.call(\n      'com.atproto.repo.createRecord',\n      undefined,\n      {\n        collection,\n        rkey: 'self',\n        ...params,\n        record: { ...record, $type: collection },\n      },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async put(\n    params: OmitKey<\n      ComAtprotoRepoPutRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<AppGainforestOrganizationDefaultSite.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'app.gainforest.organization.defaultSite'\n    const res = await this._client.call(\n      'com.atproto.repo.putRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async delete(\n    params: OmitKey<ComAtprotoRepoDeleteRecord.InputSchema, 'collection'>,\n    headers?: Record<string, string>,\n  ): Promise<void> {\n    await this._client.call(\n      'com.atproto.repo.deleteRecord',\n      undefined,\n      { collection: 'app.gainforest.organization.defaultSite', ...params },\n      { headers },\n    )\n  }\n}\n\nexport class AppGainforestOrganizationInfoRecord {\n  _client: XrpcClient\n\n  constructor(client: XrpcClient) {\n    this._client = client\n  }\n\n  async list(\n    params: OmitKey<ComAtprotoRepoListRecords.QueryParams, 'collection'>,\n  ): Promise<{\n    cursor?: string\n    records: { uri: string; value: AppGainforestOrganizationInfo.Record }[]\n  }> {\n    const res = await this._client.call('com.atproto.repo.listRecords', {\n      collection: 'app.gainforest.organization.info',\n      ...params,\n    })\n    return res.data\n  }\n\n  async get(\n    params: OmitKey<ComAtprotoRepoGetRecord.QueryParams, 'collection'>,\n  ): Promise<{\n    uri: string\n    cid: string\n    value: AppGainforestOrganizationInfo.Record\n  }> {\n    const res = await this._client.call('com.atproto.repo.getRecord', {\n      collection: 'app.gainforest.organization.info',\n      ...params,\n    })\n    return res.data\n  }\n\n  async create(\n    params: OmitKey<\n      ComAtprotoRepoCreateRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<AppGainforestOrganizationInfo.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'app.gainforest.organization.info'\n    const res = await this._client.call(\n      'com.atproto.repo.createRecord',\n      undefined,\n      {\n        collection,\n        rkey: 'self',\n        ...params,\n        record: { ...record, $type: collection },\n      },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async put(\n    params: OmitKey<\n      ComAtprotoRepoPutRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<AppGainforestOrganizationInfo.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'app.gainforest.organization.info'\n    const res = await this._client.call(\n      'com.atproto.repo.putRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async delete(\n    params: OmitKey<ComAtprotoRepoDeleteRecord.InputSchema, 'collection'>,\n    headers?: Record<string, string>,\n  ): Promise<void> {\n    await this._client.call(\n      'com.atproto.repo.deleteRecord',\n      undefined,\n      { collection: 'app.gainforest.organization.info', ...params },\n      { headers },\n    )\n  }\n}\n\nexport class AppGainforestOrganizationMeasuredTreesRecord {\n  _client: XrpcClient\n\n  constructor(client: XrpcClient) {\n    this._client = client\n  }\n\n  async list(\n    params: OmitKey<ComAtprotoRepoListRecords.QueryParams, 'collection'>,\n  ): Promise<{\n    cursor?: string\n    records: {\n      uri: string\n      value: AppGainforestOrganizationMeasuredTrees.Record\n    }[]\n  }> {\n    const res = await this._client.call('com.atproto.repo.listRecords', {\n      collection: 'app.gainforest.organization.measuredTrees',\n      ...params,\n    })\n    return res.data\n  }\n\n  async get(\n    params: OmitKey<ComAtprotoRepoGetRecord.QueryParams, 'collection'>,\n  ): Promise<{\n    uri: string\n    cid: string\n    value: AppGainforestOrganizationMeasuredTrees.Record\n  }> {\n    const res = await this._client.call('com.atproto.repo.getRecord', {\n      collection: 'app.gainforest.organization.measuredTrees',\n      ...params,\n    })\n    return res.data\n  }\n\n  async create(\n    params: OmitKey<\n      ComAtprotoRepoCreateRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<AppGainforestOrganizationMeasuredTrees.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'app.gainforest.organization.measuredTrees'\n    const res = await this._client.call(\n      'com.atproto.repo.createRecord',\n      undefined,\n      {\n        collection,\n        rkey: 'self',\n        ...params,\n        record: { ...record, $type: collection },\n      },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async put(\n    params: OmitKey<\n      ComAtprotoRepoPutRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<AppGainforestOrganizationMeasuredTrees.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'app.gainforest.organization.measuredTrees'\n    const res = await this._client.call(\n      'com.atproto.repo.putRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async delete(\n    params: OmitKey<ComAtprotoRepoDeleteRecord.InputSchema, 'collection'>,\n    headers?: Record<string, string>,\n  ): Promise<void> {\n    await this._client.call(\n      'com.atproto.repo.deleteRecord',\n      undefined,\n      { collection: 'app.gainforest.organization.measuredTrees', ...params },\n      { headers },\n    )\n  }\n}\n\nexport class AppGainforestOrganizationSiteRecord {\n  _client: XrpcClient\n\n  constructor(client: XrpcClient) {\n    this._client = client\n  }\n\n  async list(\n    params: OmitKey<ComAtprotoRepoListRecords.QueryParams, 'collection'>,\n  ): Promise<{\n    cursor?: string\n    records: { uri: string; value: AppGainforestOrganizationSite.Record }[]\n  }> {\n    const res = await this._client.call('com.atproto.repo.listRecords', {\n      collection: 'app.gainforest.organization.site',\n      ...params,\n    })\n    return res.data\n  }\n\n  async get(\n    params: OmitKey<ComAtprotoRepoGetRecord.QueryParams, 'collection'>,\n  ): Promise<{\n    uri: string\n    cid: string\n    value: AppGainforestOrganizationSite.Record\n  }> {\n    const res = await this._client.call('com.atproto.repo.getRecord', {\n      collection: 'app.gainforest.organization.site',\n      ...params,\n    })\n    return res.data\n  }\n\n  async create(\n    params: OmitKey<\n      ComAtprotoRepoCreateRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<AppGainforestOrganizationSite.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'app.gainforest.organization.site'\n    const res = await this._client.call(\n      'com.atproto.repo.createRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async put(\n    params: OmitKey<\n      ComAtprotoRepoPutRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<AppGainforestOrganizationSite.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'app.gainforest.organization.site'\n    const res = await this._client.call(\n      'com.atproto.repo.putRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async delete(\n    params: OmitKey<ComAtprotoRepoDeleteRecord.InputSchema, 'collection'>,\n    headers?: Record<string, string>,\n  ): Promise<void> {\n    await this._client.call(\n      'com.atproto.repo.deleteRecord',\n      undefined,\n      { collection: 'app.gainforest.organization.site', ...params },\n      { headers },\n    )\n  }\n}\n\nexport class OrgNS {\n  _client: XrpcClient\n  hypercerts: OrgHypercertsNS\n\n  constructor(client: XrpcClient) {\n    this._client = client\n    this.hypercerts = new OrgHypercertsNS(client)\n  }\n}\n\nexport class OrgHypercertsNS {\n  _client: XrpcClient\n  collection: OrgHypercertsCollectionRecord\n  claim: OrgHypercertsClaimNS\n\n  constructor(client: XrpcClient) {\n    this._client = client\n    this.claim = new OrgHypercertsClaimNS(client)\n    this.collection = new OrgHypercertsCollectionRecord(client)\n  }\n}\n\nexport class OrgHypercertsClaimNS {\n  _client: XrpcClient\n  claim: OrgHypercertsClaimClaimRecord\n  contribution: OrgHypercertsClaimContributionRecord\n  evaluation: OrgHypercertsClaimEvaluationRecord\n  evidence: OrgHypercertsClaimEvidenceRecord\n  measurement: OrgHypercertsClaimMeasurementRecord\n  rights: OrgHypercertsClaimRightsRecord\n\n  constructor(client: XrpcClient) {\n    this._client = client\n    this.claim = new OrgHypercertsClaimClaimRecord(client)\n    this.contribution = new OrgHypercertsClaimContributionRecord(client)\n    this.evaluation = new OrgHypercertsClaimEvaluationRecord(client)\n    this.evidence = new OrgHypercertsClaimEvidenceRecord(client)\n    this.measurement = new OrgHypercertsClaimMeasurementRecord(client)\n    this.rights = new OrgHypercertsClaimRightsRecord(client)\n  }\n}\n\nexport class OrgHypercertsClaimClaimRecord {\n  _client: XrpcClient\n\n  constructor(client: XrpcClient) {\n    this._client = client\n  }\n\n  async list(\n    params: OmitKey<ComAtprotoRepoListRecords.QueryParams, 'collection'>,\n  ): Promise<{\n    cursor?: string\n    records: { uri: string; value: OrgHypercertsClaimClaim.Record }[]\n  }> {\n    const res = await this._client.call('com.atproto.repo.listRecords', {\n      collection: 'org.hypercerts.claim.claim',\n      ...params,\n    })\n    return res.data\n  }\n\n  async get(\n    params: OmitKey<ComAtprotoRepoGetRecord.QueryParams, 'collection'>,\n  ): Promise<{\n    uri: string\n    cid: string\n    value: OrgHypercertsClaimClaim.Record\n  }> {\n    const res = await this._client.call('com.atproto.repo.getRecord', {\n      collection: 'org.hypercerts.claim.claim',\n      ...params,\n    })\n    return res.data\n  }\n\n  async create(\n    params: OmitKey<\n      ComAtprotoRepoCreateRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<OrgHypercertsClaimClaim.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'org.hypercerts.claim.claim'\n    const res = await this._client.call(\n      'com.atproto.repo.createRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async put(\n    params: OmitKey<\n      ComAtprotoRepoPutRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<OrgHypercertsClaimClaim.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'org.hypercerts.claim.claim'\n    const res = await this._client.call(\n      'com.atproto.repo.putRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async delete(\n    params: OmitKey<ComAtprotoRepoDeleteRecord.InputSchema, 'collection'>,\n    headers?: Record<string, string>,\n  ): Promise<void> {\n    await this._client.call(\n      'com.atproto.repo.deleteRecord',\n      undefined,\n      { collection: 'org.hypercerts.claim.claim', ...params },\n      { headers },\n    )\n  }\n}\n\nexport class OrgHypercertsClaimContributionRecord {\n  _client: XrpcClient\n\n  constructor(client: XrpcClient) {\n    this._client = client\n  }\n\n  async list(\n    params: OmitKey<ComAtprotoRepoListRecords.QueryParams, 'collection'>,\n  ): Promise<{\n    cursor?: string\n    records: { uri: string; value: OrgHypercertsClaimContribution.Record }[]\n  }> {\n    const res = await this._client.call('com.atproto.repo.listRecords', {\n      collection: 'org.hypercerts.claim.contribution',\n      ...params,\n    })\n    return res.data\n  }\n\n  async get(\n    params: OmitKey<ComAtprotoRepoGetRecord.QueryParams, 'collection'>,\n  ): Promise<{\n    uri: string\n    cid: string\n    value: OrgHypercertsClaimContribution.Record\n  }> {\n    const res = await this._client.call('com.atproto.repo.getRecord', {\n      collection: 'org.hypercerts.claim.contribution',\n      ...params,\n    })\n    return res.data\n  }\n\n  async create(\n    params: OmitKey<\n      ComAtprotoRepoCreateRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<OrgHypercertsClaimContribution.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'org.hypercerts.claim.contribution'\n    const res = await this._client.call(\n      'com.atproto.repo.createRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async put(\n    params: OmitKey<\n      ComAtprotoRepoPutRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<OrgHypercertsClaimContribution.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'org.hypercerts.claim.contribution'\n    const res = await this._client.call(\n      'com.atproto.repo.putRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async delete(\n    params: OmitKey<ComAtprotoRepoDeleteRecord.InputSchema, 'collection'>,\n    headers?: Record<string, string>,\n  ): Promise<void> {\n    await this._client.call(\n      'com.atproto.repo.deleteRecord',\n      undefined,\n      { collection: 'org.hypercerts.claim.contribution', ...params },\n      { headers },\n    )\n  }\n}\n\nexport class OrgHypercertsClaimEvaluationRecord {\n  _client: XrpcClient\n\n  constructor(client: XrpcClient) {\n    this._client = client\n  }\n\n  async list(\n    params: OmitKey<ComAtprotoRepoListRecords.QueryParams, 'collection'>,\n  ): Promise<{\n    cursor?: string\n    records: { uri: string; value: OrgHypercertsClaimEvaluation.Record }[]\n  }> {\n    const res = await this._client.call('com.atproto.repo.listRecords', {\n      collection: 'org.hypercerts.claim.evaluation',\n      ...params,\n    })\n    return res.data\n  }\n\n  async get(\n    params: OmitKey<ComAtprotoRepoGetRecord.QueryParams, 'collection'>,\n  ): Promise<{\n    uri: string\n    cid: string\n    value: OrgHypercertsClaimEvaluation.Record\n  }> {\n    const res = await this._client.call('com.atproto.repo.getRecord', {\n      collection: 'org.hypercerts.claim.evaluation',\n      ...params,\n    })\n    return res.data\n  }\n\n  async create(\n    params: OmitKey<\n      ComAtprotoRepoCreateRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<OrgHypercertsClaimEvaluation.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'org.hypercerts.claim.evaluation'\n    const res = await this._client.call(\n      'com.atproto.repo.createRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async put(\n    params: OmitKey<\n      ComAtprotoRepoPutRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<OrgHypercertsClaimEvaluation.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'org.hypercerts.claim.evaluation'\n    const res = await this._client.call(\n      'com.atproto.repo.putRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async delete(\n    params: OmitKey<ComAtprotoRepoDeleteRecord.InputSchema, 'collection'>,\n    headers?: Record<string, string>,\n  ): Promise<void> {\n    await this._client.call(\n      'com.atproto.repo.deleteRecord',\n      undefined,\n      { collection: 'org.hypercerts.claim.evaluation', ...params },\n      { headers },\n    )\n  }\n}\n\nexport class OrgHypercertsClaimEvidenceRecord {\n  _client: XrpcClient\n\n  constructor(client: XrpcClient) {\n    this._client = client\n  }\n\n  async list(\n    params: OmitKey<ComAtprotoRepoListRecords.QueryParams, 'collection'>,\n  ): Promise<{\n    cursor?: string\n    records: { uri: string; value: OrgHypercertsClaimEvidence.Record }[]\n  }> {\n    const res = await this._client.call('com.atproto.repo.listRecords', {\n      collection: 'org.hypercerts.claim.evidence',\n      ...params,\n    })\n    return res.data\n  }\n\n  async get(\n    params: OmitKey<ComAtprotoRepoGetRecord.QueryParams, 'collection'>,\n  ): Promise<{\n    uri: string\n    cid: string\n    value: OrgHypercertsClaimEvidence.Record\n  }> {\n    const res = await this._client.call('com.atproto.repo.getRecord', {\n      collection: 'org.hypercerts.claim.evidence',\n      ...params,\n    })\n    return res.data\n  }\n\n  async create(\n    params: OmitKey<\n      ComAtprotoRepoCreateRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<OrgHypercertsClaimEvidence.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'org.hypercerts.claim.evidence'\n    const res = await this._client.call(\n      'com.atproto.repo.createRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async put(\n    params: OmitKey<\n      ComAtprotoRepoPutRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<OrgHypercertsClaimEvidence.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'org.hypercerts.claim.evidence'\n    const res = await this._client.call(\n      'com.atproto.repo.putRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async delete(\n    params: OmitKey<ComAtprotoRepoDeleteRecord.InputSchema, 'collection'>,\n    headers?: Record<string, string>,\n  ): Promise<void> {\n    await this._client.call(\n      'com.atproto.repo.deleteRecord',\n      undefined,\n      { collection: 'org.hypercerts.claim.evidence', ...params },\n      { headers },\n    )\n  }\n}\n\nexport class OrgHypercertsClaimMeasurementRecord {\n  _client: XrpcClient\n\n  constructor(client: XrpcClient) {\n    this._client = client\n  }\n\n  async list(\n    params: OmitKey<ComAtprotoRepoListRecords.QueryParams, 'collection'>,\n  ): Promise<{\n    cursor?: string\n    records: { uri: string; value: OrgHypercertsClaimMeasurement.Record }[]\n  }> {\n    const res = await this._client.call('com.atproto.repo.listRecords', {\n      collection: 'org.hypercerts.claim.measurement',\n      ...params,\n    })\n    return res.data\n  }\n\n  async get(\n    params: OmitKey<ComAtprotoRepoGetRecord.QueryParams, 'collection'>,\n  ): Promise<{\n    uri: string\n    cid: string\n    value: OrgHypercertsClaimMeasurement.Record\n  }> {\n    const res = await this._client.call('com.atproto.repo.getRecord', {\n      collection: 'org.hypercerts.claim.measurement',\n      ...params,\n    })\n    return res.data\n  }\n\n  async create(\n    params: OmitKey<\n      ComAtprotoRepoCreateRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<OrgHypercertsClaimMeasurement.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'org.hypercerts.claim.measurement'\n    const res = await this._client.call(\n      'com.atproto.repo.createRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async put(\n    params: OmitKey<\n      ComAtprotoRepoPutRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<OrgHypercertsClaimMeasurement.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'org.hypercerts.claim.measurement'\n    const res = await this._client.call(\n      'com.atproto.repo.putRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async delete(\n    params: OmitKey<ComAtprotoRepoDeleteRecord.InputSchema, 'collection'>,\n    headers?: Record<string, string>,\n  ): Promise<void> {\n    await this._client.call(\n      'com.atproto.repo.deleteRecord',\n      undefined,\n      { collection: 'org.hypercerts.claim.measurement', ...params },\n      { headers },\n    )\n  }\n}\n\nexport class OrgHypercertsClaimRightsRecord {\n  _client: XrpcClient\n\n  constructor(client: XrpcClient) {\n    this._client = client\n  }\n\n  async list(\n    params: OmitKey<ComAtprotoRepoListRecords.QueryParams, 'collection'>,\n  ): Promise<{\n    cursor?: string\n    records: { uri: string; value: OrgHypercertsClaimRights.Record }[]\n  }> {\n    const res = await this._client.call('com.atproto.repo.listRecords', {\n      collection: 'org.hypercerts.claim.rights',\n      ...params,\n    })\n    return res.data\n  }\n\n  async get(\n    params: OmitKey<ComAtprotoRepoGetRecord.QueryParams, 'collection'>,\n  ): Promise<{\n    uri: string\n    cid: string\n    value: OrgHypercertsClaimRights.Record\n  }> {\n    const res = await this._client.call('com.atproto.repo.getRecord', {\n      collection: 'org.hypercerts.claim.rights',\n      ...params,\n    })\n    return res.data\n  }\n\n  async create(\n    params: OmitKey<\n      ComAtprotoRepoCreateRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<OrgHypercertsClaimRights.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'org.hypercerts.claim.rights'\n    const res = await this._client.call(\n      'com.atproto.repo.createRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async put(\n    params: OmitKey<\n      ComAtprotoRepoPutRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<OrgHypercertsClaimRights.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'org.hypercerts.claim.rights'\n    const res = await this._client.call(\n      'com.atproto.repo.putRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async delete(\n    params: OmitKey<ComAtprotoRepoDeleteRecord.InputSchema, 'collection'>,\n    headers?: Record<string, string>,\n  ): Promise<void> {\n    await this._client.call(\n      'com.atproto.repo.deleteRecord',\n      undefined,\n      { collection: 'org.hypercerts.claim.rights', ...params },\n      { headers },\n    )\n  }\n}\n\nexport class OrgHypercertsCollectionRecord {\n  _client: XrpcClient\n\n  constructor(client: XrpcClient) {\n    this._client = client\n  }\n\n  async list(\n    params: OmitKey<ComAtprotoRepoListRecords.QueryParams, 'collection'>,\n  ): Promise<{\n    cursor?: string\n    records: { uri: string; value: OrgHypercertsCollection.Record }[]\n  }> {\n    const res = await this._client.call('com.atproto.repo.listRecords', {\n      collection: 'org.hypercerts.collection',\n      ...params,\n    })\n    return res.data\n  }\n\n  async get(\n    params: OmitKey<ComAtprotoRepoGetRecord.QueryParams, 'collection'>,\n  ): Promise<{\n    uri: string\n    cid: string\n    value: OrgHypercertsCollection.Record\n  }> {\n    const res = await this._client.call('com.atproto.repo.getRecord', {\n      collection: 'org.hypercerts.collection',\n      ...params,\n    })\n    return res.data\n  }\n\n  async create(\n    params: OmitKey<\n      ComAtprotoRepoCreateRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<OrgHypercertsCollection.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'org.hypercerts.collection'\n    const res = await this._client.call(\n      'com.atproto.repo.createRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async put(\n    params: OmitKey<\n      ComAtprotoRepoPutRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<OrgHypercertsCollection.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'org.hypercerts.collection'\n    const res = await this._client.call(\n      'com.atproto.repo.putRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async delete(\n    params: OmitKey<ComAtprotoRepoDeleteRecord.InputSchema, 'collection'>,\n    headers?: Record<string, string>,\n  ): Promise<void> {\n    await this._client.call(\n      'com.atproto.repo.deleteRecord',\n      undefined,\n      { collection: 'org.hypercerts.collection', ...params },\n      { headers },\n    )\n  }\n}\n\nexport class ComNS {\n  _client: XrpcClient\n  atproto: ComAtprotoNS\n\n  constructor(client: XrpcClient) {\n    this._client = client\n    this.atproto = new ComAtprotoNS(client)\n  }\n}\n\nexport class ComAtprotoNS {\n  _client: XrpcClient\n  repo: ComAtprotoRepoNS\n\n  constructor(client: XrpcClient) {\n    this._client = client\n    this.repo = new ComAtprotoRepoNS(client)\n  }\n}\n\nexport class ComAtprotoRepoNS {\n  _client: XrpcClient\n\n  constructor(client: XrpcClient) {\n    this._client = client\n  }\n}\n","/**\n * GENERATED CODE - DO NOT MODIFY\n */\nimport {\n  type LexiconDoc,\n  Lexicons,\n  ValidationError,\n  type ValidationResult,\n} from '@atproto/lexicon'\nimport { type $Typed, is$typed, maybe$typed } from './util.js'\n\nexport const schemaDict = {\n  AppCertifiedLocation: {\n    lexicon: 1,\n    id: 'app.certified.location',\n    defs: {\n      main: {\n        type: 'record',\n        description: 'A location reference',\n        key: 'any',\n        record: {\n          type: 'object',\n          required: [\n            'lpVersion',\n            'srs',\n            'locationType',\n            'location',\n            'createdAt',\n          ],\n          properties: {\n            lpVersion: {\n              type: 'string',\n              description: 'The version of the Location Protocol',\n              maxLength: 10,\n            },\n            srs: {\n              type: 'string',\n              format: 'uri',\n              description:\n                'The Spatial Reference System URI (e.g., http://www.opengis.net/def/crs/OGC/1.3/CRS84) that defines the coordinate system.',\n              maxLength: 100,\n            },\n            locationType: {\n              type: 'string',\n              description:\n                'An identifier for the format of the location data (e.g., coordinate-decimal, geojson-point)',\n              knownValues: ['coordinate-decimal', 'geojson-point'],\n              maxLength: 20,\n            },\n            location: {\n              type: 'union',\n              refs: [\n                'lex:org.hypercerts.defs#uri',\n                'lex:org.hypercerts.defs#smallBlob',\n              ],\n              description:\n                'The location of where the work was performed as a URI or blob.',\n            },\n            name: {\n              type: 'string',\n              description: 'Optional name for this location',\n              maxLength: 1000,\n              maxGraphemes: 100,\n            },\n            description: {\n              type: 'string',\n              description: 'Optional description for this location',\n              maxLength: 2000,\n              maxGraphemes: 500,\n            },\n            createdAt: {\n              type: 'string',\n              format: 'datetime',\n              description:\n                'Client-declared timestamp when this record was originally created',\n            },\n          },\n        },\n      },\n    },\n  },\n  OrgHypercertsClaimClaim: {\n    lexicon: 1,\n    id: 'org.hypercerts.claim.claim',\n    defs: {\n      main: {\n        type: 'record',\n        description: 'A hypercert record tracking impact work.',\n        key: 'any',\n        record: {\n          type: 'object',\n          required: [\n            'title',\n            'shortDescription',\n            'createdAt',\n            'workScope',\n            'workTimeFrameFrom',\n            'workTimeFrameTo',\n          ],\n          properties: {\n            title: {\n              type: 'string',\n              description: 'Title of the hypercert',\n              maxLength: 256,\n            },\n            shortDescription: {\n              type: 'string',\n              description: 'Short blurb of the impact work done.',\n              maxLength: 3000,\n              maxGraphemes: 300,\n            },\n            description: {\n              type: 'string',\n              description:\n                'Optional longer description of the impact work done.',\n              maxLength: 30000,\n              maxGraphemes: 3000,\n            },\n            image: {\n              type: 'union',\n              refs: [\n                'lex:org.hypercerts.defs#uri',\n                'lex:org.hypercerts.defs#smallImage',\n              ],\n              description:\n                'The hypercert visual representation as a URI or image blob',\n            },\n            workScope: {\n              type: 'string',\n              description: 'Scope of the work performed',\n              maxLength: 5000,\n              maxGraphemes: 1000,\n            },\n            workTimeFrameFrom: {\n              type: 'string',\n              format: 'datetime',\n              description: 'When the work began',\n            },\n            workTimeFrameTo: {\n              type: 'string',\n              format: 'datetime',\n              description: 'When the work ended',\n            },\n            evidence: {\n              type: 'array',\n              description:\n                'Supporting evidence, documentation, or external data URIs',\n              items: {\n                type: 'ref',\n                ref: 'lex:com.atproto.repo.strongRef',\n                description:\n                  'A strong reference to the evidence that supports this impact claim. The record referenced must conform with the org.hypercerts.claim.evidence lexicon',\n              },\n              maxLength: 100,\n            },\n            contributions: {\n              type: 'array',\n              description:\n                'A strong reference to the contributions done to create the impact in the hypercerts. The record referenced must conform with the lexicon org.hypercerts.claim.contributions',\n              items: {\n                type: 'ref',\n                ref: 'lex:com.atproto.repo.strongRef',\n              },\n            },\n            rights: {\n              type: 'ref',\n              ref: 'lex:com.atproto.repo.strongRef',\n              description:\n                'A strong reference to the rights that this hypercert has. The record referenced must conform with the lexicon org.hypercerts.claim.rights',\n            },\n            location: {\n              type: 'ref',\n              ref: 'lex:com.atproto.repo.strongRef',\n              description:\n                'A strong reference to the location where the work for done hypercert was located. The record referenced must conform with the lexicon org.hypercerts.claim.location',\n            },\n            createdAt: {\n              type: 'string',\n              format: 'datetime',\n              description:\n                'Client-declared timestamp when this record was originally created',\n            },\n          },\n        },\n      },\n    },\n  },\n  OrgHypercertsClaimContribution: {\n    lexicon: 1,\n    id: 'org.hypercerts.claim.contribution',\n    defs: {\n      main: {\n        type: 'record',\n        description: \"A contribution made toward a hypercert's impact.\",\n        key: 'any',\n        record: {\n          type: 'object',\n          required: ['hypercert', 'contributors', 'createdAt'],\n          properties: {\n            hypercert: {\n              type: 'ref',\n              ref: 'lex:com.atproto.repo.strongRef',\n              description:\n                'A strong reference to the hypercert this contribution is for. The record referenced must conform with the lexicon org.hypercerts.claim.',\n            },\n            role: {\n              type: 'string',\n              description: 'Role or title of the contributor(s).',\n              maxLength: 100,\n            },\n            contributors: {\n              type: 'array',\n              description:\n                'List of the contributors (names, pseudonyms, or DIDs). If multiple contributors are stored in the same hypercertContribution, then they would have the exact same role.',\n              items: {\n                type: 'string',\n              },\n            },\n            description: {\n              type: 'string',\n              description: 'What the contribution concretely achieved',\n              maxLength: 2000,\n              maxGraphemes: 500,\n            },\n            workTimeframeFrom: {\n              type: 'string',\n              format: 'datetime',\n              description:\n                'When this contribution started. This should be a subset of the hypercert timeframe.',\n            },\n            workTimeframeTo: {\n              type: 'string',\n              format: 'datetime',\n              description:\n                'When this contribution finished.  This should be a subset of the hypercert timeframe.',\n            },\n            createdAt: {\n              type: 'string',\n              format: 'datetime',\n              description:\n                'Client-declared timestamp when this record was originally created',\n            },\n          },\n        },\n      },\n    },\n  },\n  OrgHypercertsClaimEvaluation: {\n    lexicon: 1,\n    id: 'org.hypercerts.claim.evaluation',\n    defs: {\n      main: {\n        type: 'record',\n        description: 'An evaluation of a hypercert or other claim',\n        key: 'tid',\n        record: {\n          type: 'object',\n          required: ['subject', 'evaluators', 'summary', 'createdAt'],\n          properties: {\n            subject: {\n              type: 'ref',\n              ref: 'lex:com.atproto.repo.strongRef',\n              description:\n                'A strong reference to the evaluated claim. (e.g measurement, hypercert, contribution, etc)',\n            },\n            evaluators: {\n              type: 'array',\n              description: 'DIDs of the evaluators',\n              items: {\n                type: 'string',\n                format: 'did',\n              },\n              maxLength: 100,\n            },\n            evaluations: {\n              type: 'array',\n              description:\n                'Evaluation data (URIs or blobs) containing detailed reports or methodology',\n              items: {\n                type: 'union',\n                refs: [\n                  'lex:org.hypercerts.defs#uri',\n                  'lex:org.hypercerts.defs#smallBlob',\n                ],\n              },\n              maxLength: 100,\n            },\n            summary: {\n              type: 'string',\n              description: 'Brief evaluation summary',\n              maxLength: 5000,\n              maxGraphemes: 1000,\n            },\n            createdAt: {\n              type: 'string',\n              format: 'datetime',\n              description:\n                'Client-declared timestamp when this record was originally created',\n            },\n          },\n        },\n      },\n    },\n  },\n  OrgHypercertsClaimEvidence: {\n    lexicon: 1,\n    id: 'org.hypercerts.claim.evidence',\n    defs: {\n      main: {\n        type: 'record',\n        description: 'A piece of evidence supporting a hypercert claim',\n        key: 'any',\n        record: {\n          type: 'object',\n          required: ['content', 'shortDescription', 'createdAt'],\n          properties: {\n            content: {\n              type: 'union',\n              refs: [\n                'lex:org.hypercerts.defs#uri',\n                'lex:org.hypercerts.defs#smallBlob',\n              ],\n              description:\n                'A piece of evidence (URI or blobs) supporting a hypercert claim',\n            },\n            title: {\n              type: 'string',\n              maxLength: 256,\n              description:\n                'Optional title to describe the nature of the evidence',\n            },\n            shortDescription: {\n              type: 'string',\n              maxLength: 3000,\n              maxGraphemes: 300,\n              description:\n                'Short description explaining what this evidence demonstrates or proves',\n            },\n            description: {\n              type: 'string',\n              description:\n                'Optional longer description describing the impact claim evidence.',\n              maxLength: 30000,\n              maxGraphemes: 3000,\n            },\n            createdAt: {\n              type: 'string',\n              format: 'datetime',\n              description:\n                'Client-declared timestamp when this hypercert claim was originally created',\n            },\n          },\n        },\n      },\n    },\n  },\n  OrgHypercertsClaimMeasurement: {\n    lexicon: 1,\n    id: 'org.hypercerts.claim.measurement',\n    defs: {\n      main: {\n        type: 'record',\n        description: 'External measurement data supporting a hypercert claim',\n        key: 'tid',\n        record: {\n          type: 'object',\n          required: ['hypercert', 'measurers', 'metric', 'value', 'createdAt'],\n          properties: {\n            hypercert: {\n              type: 'ref',\n              ref: 'lex:com.atproto.repo.strongRef',\n              description:\n                'A strong reference to the hypercert that this measurement is for. The record referenced must conform with the lexicon org.hypercerts.claim.',\n            },\n            measurers: {\n              type: 'array',\n              description:\n                'DIDs of the entity (or entities) that measured this data',\n              items: {\n                type: 'string',\n                format: 'did',\n              },\n              maxLength: 100,\n            },\n            metric: {\n              type: 'string',\n              description: 'The metric being measured',\n              maxLength: 500,\n            },\n            value: {\n              type: 'string',\n              description: 'The measured value',\n              maxLength: 500,\n            },\n            measurementMethodURI: {\n              type: 'string',\n              format: 'uri',\n              description:\n                'URI to methodology documentation, standard protocol, or measurement procedure',\n            },\n            evidenceURI: {\n              type: 'array',\n              description: 'URIs to supporting evidence or data',\n              items: {\n                type: 'string',\n                format: 'uri',\n              },\n              maxLength: 50,\n            },\n            createdAt: {\n              type: 'string',\n              format: 'datetime',\n              description:\n                'Client-declared timestamp when this record was originally created',\n            },\n          },\n        },\n      },\n    },\n  },\n  OrgHypercertsClaimRights: {\n    lexicon: 1,\n    id: 'org.hypercerts.claim.rights',\n    defs: {\n      main: {\n        type: 'record',\n        description:\n          'Describes the rights that a user has with a hypercert, such as whether it can be sold, transferred, and under what conditions.',\n        key: 'any',\n        record: {\n          type: 'object',\n          required: [\n            'rightsName',\n            'rightsType',\n            'rightsDescription',\n            'createdAt',\n          ],\n          properties: {\n            rightsName: {\n              type: 'string',\n              description: 'Full name of the rights',\n              maxLength: 100,\n            },\n            rightsType: {\n              type: 'string',\n              description: 'Short rights identifier for easier search',\n              maxLength: 10,\n            },\n            rightsDescription: {\n              type: 'string',\n              description: 'Description of the rights of this hypercert',\n            },\n            createdAt: {\n              type: 'string',\n              format: 'datetime',\n              description:\n                'Client-declared timestamp when this record was originally created',\n            },\n          },\n        },\n      },\n    },\n  },\n  OrgHypercertsCollection: {\n    lexicon: 1,\n    id: 'org.hypercerts.collection',\n    defs: {\n      main: {\n        type: 'record',\n        description:\n          'A collection/group of hypercerts that have a specific property.',\n        key: 'tid',\n        record: {\n          type: 'object',\n          required: ['title', 'claims', 'createdAt'],\n          properties: {\n            title: {\n              type: 'string',\n              description: 'The title of this collection',\n              maxLength: 800,\n              maxGraphemes: 80,\n            },\n            shortDescription: {\n              type: 'string',\n              maxLength: 3000,\n              maxGraphemes: 300,\n              description: 'A short description of this collection',\n            },\n            coverPhoto: {\n              type: 'union',\n              refs: [\n                'lex:org.hypercerts.defs#uri',\n                'lex:org.hypercerts.defs#smallBlob',\n              ],\n              description:\n                'The cover photo of this collection (either in URI format or in a blob).',\n            },\n            claims: {\n              type: 'array',\n              description:\n                'Array of claims with their associated weights in this collection',\n              items: {\n                type: 'ref',\n                ref: 'lex:org.hypercerts.collection#claimItem',\n              },\n            },\n            createdAt: {\n              type: 'string',\n              format: 'datetime',\n              description:\n                'Client-declared timestamp when this record was originally created',\n            },\n          },\n        },\n      },\n      claimItem: {\n        type: 'object',\n        required: ['claim', 'weight'],\n        properties: {\n          claim: {\n            type: 'ref',\n            ref: 'lex:com.atproto.repo.strongRef',\n            description:\n              'A strong reference to a hypercert claim record. This claim must conform to the lexicon org.hypercerts.claim.record',\n          },\n          weight: {\n            type: 'string',\n            description:\n              'The weight/importance of this hypercert claim in the collection (a percentage from 0-100, stored as a string to avoid float precision issues). The total claim weights should add up to 100.',\n          },\n        },\n      },\n    },\n  },\n  OrgHypercertsDefs: {\n    lexicon: 1,\n    id: 'org.hypercerts.defs',\n    defs: {\n      uri: {\n        type: 'object',\n        required: ['uri'],\n        description: 'Object containing a URI to external data',\n        properties: {\n          uri: {\n            type: 'string',\n            format: 'uri',\n            maxGraphemes: 1024,\n            description: 'URI to external data',\n          },\n        },\n      },\n      smallBlob: {\n        type: 'object',\n        required: ['blob'],\n        description: 'Object containing a blob to external data',\n        properties: {\n          blob: {\n            type: 'blob',\n            accept: ['*/*'],\n            maxSize: 10485760,\n            description: 'Blob to external data (up to 10MB)',\n          },\n        },\n      },\n      largeBlob: {\n        type: 'object',\n        required: ['blob'],\n        description: 'Object containing a blob to external data',\n        properties: {\n          blob: {\n            type: 'blob',\n            accept: ['*/*'],\n            maxSize: 104857600,\n            description: 'Blob to external data (up to 100MB)',\n          },\n        },\n      },\n      smallImage: {\n        type: 'object',\n        required: ['image'],\n        description: 'Object containing a small image',\n        properties: {\n          image: {\n            type: 'blob',\n            accept: ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'],\n            maxSize: 5242880,\n            description: 'Image (up to 5MB)',\n          },\n        },\n      },\n      largeImage: {\n        type: 'object',\n        required: ['image'],\n        description: 'Object containing a large image',\n        properties: {\n          image: {\n            type: 'blob',\n            accept: ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'],\n            maxSize: 10485760,\n            description: 'Image (up to 10MB)',\n          },\n        },\n      },\n    },\n  },\n  AppGainforestCommonDefs: {\n    lexicon: 1,\n    id: 'app.gainforest.common.defs',\n    defs: {\n      uri: {\n        type: 'object',\n        required: ['uri'],\n        description: 'Object containing a URI to external data',\n        properties: {\n          uri: {\n            type: 'string',\n            format: 'uri',\n            maxGraphemes: 1024,\n            description: 'URI to external data',\n          },\n        },\n      },\n      smallBlob: {\n        type: 'object',\n        required: ['blob'],\n        description: 'Object containing a blob to external data',\n        properties: {\n          blob: {\n            type: 'blob',\n            accept: ['*/*'],\n            maxSize: 10485760,\n            description: 'Blob to external data (up to 10MB)',\n          },\n        },\n      },\n      largeBlob: {\n        type: 'object',\n        required: ['blob'],\n        description: 'Object containing a blob to external data',\n        properties: {\n          blob: {\n            type: 'blob',\n            accept: ['*/*'],\n            maxSize: 104857600,\n            description: 'Blob to external data (up to 100MB)',\n          },\n        },\n      },\n      smallImage: {\n        type: 'object',\n        required: ['image'],\n        description: 'Object containing a small image',\n        properties: {\n          image: {\n            type: 'blob',\n            accept: ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'],\n            maxSize: 5242880,\n            description: 'Image (up to 5MB)',\n          },\n        },\n      },\n      largeImage: {\n        type: 'object',\n        required: ['image'],\n        description: 'Object containing a large image',\n        properties: {\n          image: {\n            type: 'blob',\n            accept: ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'],\n            maxSize: 10485760,\n            description: 'Image (up to 10MB)',\n          },\n        },\n      },\n      indexedOrganization: {\n        type: 'object',\n        required: ['id', 'name'],\n        properties: {\n          id: {\n            type: 'string',\n            format: 'uri',\n            description: 'The URI of the organization',\n          },\n          name: {\n            type: 'string',\n            description: 'The name of the organization',\n          },\n        },\n      },\n    },\n  },\n  AppGainforestOrganizationDefaultSite: {\n    lexicon: 1,\n    id: 'app.gainforest.organization.defaultSite',\n    defs: {\n      main: {\n        type: 'record',\n        description: 'A declaration of the default site for an organization',\n        key: 'literal:self',\n        record: {\n          type: 'object',\n          required: ['site'],\n          properties: {\n            site: {\n              type: 'string',\n              format: 'at-uri',\n              description:\n                'The reference to the default site record in the PDS',\n            },\n          },\n        },\n      },\n    },\n  },\n  AppGainforestOrganizationGetIndexedOrganizations: {\n    lexicon: 1,\n    id: 'app.gainforest.organization.getIndexedOrganizations',\n    defs: {\n      main: {\n        type: 'query',\n        description: 'Get all organizations to view initially on map',\n        parameters: {\n          type: 'params',\n          properties: {},\n        },\n        output: {\n          encoding: 'application/json',\n          schema: {\n            type: 'object',\n            required: ['organizations'],\n            properties: {\n              organizations: {\n                type: 'array',\n                items: {\n                  type: 'ref',\n                  ref: 'lex:app.gainforest.common.defs#indexedOrganization',\n                },\n              },\n            },\n          },\n        },\n      },\n    },\n  },\n  AppGainforestOrganizationInfo: {\n    lexicon: 1,\n    id: 'app.gainforest.organization.info',\n    defs: {\n      main: {\n        type: 'record',\n        description: 'A declaration of an organization or project',\n        key: 'literal:self',\n        record: {\n          type: 'object',\n          required: [\n            'displayName',\n            'shortDescription',\n            'longDescription',\n            'objectives',\n            'country',\n            'visibility',\n          ],\n          properties: {\n            displayName: {\n              type: 'string',\n              description: 'The name of the organization or project',\n              minLength: 8,\n              maxLength: 255,\n            },\n            shortDescription: {\n              type: 'string',\n              description: 'The description of the organization or project',\n              minLength: 50,\n              maxLength: 2000,\n            },\n            longDescription: {\n              type: 'string',\n              description:\n                'The long description of the organization or project in markdown',\n              minLength: 50,\n              maxLength: 5000,\n            },\n            coverImage: {\n              type: 'ref',\n              ref: 'lex:app.gainforest.common.defs#smallImage',\n              description: 'Cover image for the organization',\n            },\n            logo: {\n              type: 'ref',\n              ref: 'lex:app.gainforest.common.defs#smallImage',\n              description: 'Logo for the organization',\n            },\n            objectives: {\n              type: 'array',\n              description: 'The objectives of the organization or project',\n              items: {\n                type: 'string',\n                enum: [\n                  'Conservation',\n                  'Research',\n                  'Education',\n                  'Community',\n                  'Other',\n                ],\n              },\n            },\n            startDate: {\n              type: 'string',\n              description: 'The start date of the organization or project',\n              format: 'datetime',\n            },\n            website: {\n              type: 'string',\n              description: 'The website of the organization or project',\n              format: 'uri',\n            },\n            country: {\n              type: 'string',\n              description:\n                'The country of the organization or project in two letter code (ISO 3166-1 alpha-2)',\n            },\n            visibility: {\n              type: 'string',\n              description:\n                'The visibility of the organization or project in the Green Globe',\n              enum: ['Public', 'Hidden'],\n            },\n          },\n        },\n      },\n    },\n  },\n  AppGainforestOrganizationMeasuredTrees: {\n    lexicon: 1,\n    id: 'app.gainforest.organization.measuredTrees',\n    defs: {\n      main: {\n        type: 'record',\n        description: 'A declaration of measured trees for an organization',\n        key: 'literal:self',\n        record: {\n          type: 'object',\n          required: ['shapefile'],\n          properties: {\n            shapefile: {\n              type: 'string',\n              format: 'uri',\n              description:\n                'The uri pointing to the shapefile of the measured trees',\n            },\n          },\n        },\n      },\n    },\n  },\n  AppGainforestOrganizationSite: {\n    lexicon: 1,\n    id: 'app.gainforest.organization.site',\n    defs: {\n      main: {\n        type: 'record',\n        description: 'A declaration of a site for an organization',\n        key: 'tid',\n        record: {\n          type: 'object',\n          required: ['name', 'lat', 'lon', 'area', 'shapefile'],\n          properties: {\n            name: {\n              type: 'string',\n              description: 'The name of the site',\n            },\n            lat: {\n              type: 'string',\n              description: 'The latitude of the centerpoint of the site',\n            },\n            lon: {\n              type: 'string',\n              description: 'The longitude of the centerpoint of the site',\n            },\n            area: {\n              type: 'string',\n              description: 'The area of the site in hectares',\n            },\n            shapefile: {\n              type: 'union',\n              refs: [\n                'lex:app.gainforest.common.defs#uri',\n                'lex:app.gainforest.common.defs#smallBlob',\n              ],\n              description:\n                'URI or blob pointing to a geoJSON file containing the site boundaries',\n            },\n            trees: {\n              type: 'union',\n              refs: [\n                'lex:app.gainforest.common.defs#uri',\n                'lex:app.gainforest.common.defs#smallBlob',\n              ],\n              description:\n                'URI or blob pointing to GeoJSON data containing tree planting data for this site',\n            },\n          },\n        },\n      },\n    },\n  },\n  ComAtprotoRepoStrongRef: {\n    lexicon: 1,\n    id: 'com.atproto.repo.strongRef',\n    description: 'A URI with a content-hash fingerprint.',\n    defs: {\n      main: {\n        type: 'object',\n        required: ['uri', 'cid'],\n        properties: {\n          uri: {\n            type: 'string',\n            format: 'at-uri',\n          },\n          cid: {\n            type: 'string',\n            format: 'cid',\n          },\n        },\n      },\n    },\n  },\n} as const satisfies Record<string, LexiconDoc>\nexport const schemas = Object.values(schemaDict) satisfies LexiconDoc[]\nexport const lexicons: Lexicons = new Lexicons(schemas)\n\nexport function validate<T extends { $type: string }>(\n  v: unknown,\n  id: string,\n  hash: string,\n  requiredType: true,\n): ValidationResult<T>\nexport function validate<T extends { $type?: string }>(\n  v: unknown,\n  id: string,\n  hash: string,\n  requiredType?: false,\n): ValidationResult<T>\nexport function validate(\n  v: unknown,\n  id: string,\n  hash: string,\n  requiredType?: boolean,\n): ValidationResult {\n  return (requiredType ? is$typed : maybe$typed)(v, id, hash)\n    ? lexicons.validate(`${id}#${hash}`, v)\n    : {\n        success: false,\n        error: new ValidationError(\n          `Must be an object with \"${hash === 'main' ? id : `${id}#${hash}`}\" $type property`,\n        ),\n      }\n}\n\nexport const ids = {\n  AppCertifiedLocation: 'app.certified.location',\n  OrgHypercertsClaimClaim: 'org.hypercerts.claim.claim',\n  OrgHypercertsClaimContribution: 'org.hypercerts.claim.contribution',\n  OrgHypercertsClaimEvaluation: 'org.hypercerts.claim.evaluation',\n  OrgHypercertsClaimEvidence: 'org.hypercerts.claim.evidence',\n  OrgHypercertsClaimMeasurement: 'org.hypercerts.claim.measurement',\n  OrgHypercertsClaimRights: 'org.hypercerts.claim.rights',\n  OrgHypercertsCollection: 'org.hypercerts.collection',\n  OrgHypercertsDefs: 'org.hypercerts.defs',\n  AppGainforestCommonDefs: 'app.gainforest.common.defs',\n  AppGainforestOrganizationDefaultSite:\n    'app.gainforest.organization.defaultSite',\n  AppGainforestOrganizationGetIndexedOrganizations:\n    'app.gainforest.organization.getIndexedOrganizations',\n  AppGainforestOrganizationInfo: 'app.gainforest.organization.info',\n  AppGainforestOrganizationMeasuredTrees:\n    'app.gainforest.organization.measuredTrees',\n  AppGainforestOrganizationSite: 'app.gainforest.organization.site',\n  ComAtprotoRepoStrongRef: 'com.atproto.repo.strongRef',\n} as const\n","/**\n * GENERATED CODE - DO NOT MODIFY\n */\n\nimport { type ValidationResult } from '@atproto/lexicon'\n\nexport type OmitKey<T, K extends keyof T> = {\n  [K2 in keyof T as K2 extends K ? never : K2]: T[K2]\n}\n\nexport type $Typed<V, T extends string = string> = V & { $type: T }\nexport type Un$Typed<V extends { $type?: string }> = OmitKey<V, '$type'>\n\nexport type $Type<Id extends string, Hash extends string> = Hash extends 'main'\n  ? Id\n  : `${Id}#${Hash}`\n\nfunction isObject<V>(v: V): v is V & object {\n  return v != null && typeof v === 'object'\n}\n\nfunction is$type<Id extends string, Hash extends string>(\n  $type: unknown,\n  id: Id,\n  hash: Hash,\n): $type is $Type<Id, Hash> {\n  return hash === 'main'\n    ? $type === id\n    : // $type === `${id}#${hash}`\n      typeof $type === 'string' &&\n        $type.length === id.length + 1 + hash.length &&\n        $type.charCodeAt(id.length) === 35 /* '#' */ &&\n        $type.startsWith(id) &&\n        $type.endsWith(hash)\n}\n\nexport type $TypedObject<\n  V,\n  Id extends string,\n  Hash extends string,\n> = V extends {\n  $type: $Type<Id, Hash>\n}\n  ? V\n  : V extends { $type?: string }\n    ? V extends { $type?: infer T extends $Type<Id, Hash> }\n      ? V & { $type: T }\n      : never\n    : V & { $type: $Type<Id, Hash> }\n\nexport function is$typed<V, Id extends string, Hash extends string>(\n  v: V,\n  id: Id,\n  hash: Hash,\n): v is $TypedObject<V, Id, Hash> {\n  return isObject(v) && '$type' in v && is$type(v.$type, id, hash)\n}\n\nexport function maybe$typed<V, Id extends string, Hash extends string>(\n  v: V,\n  id: Id,\n  hash: Hash,\n): v is V & object & { $type?: $Type<Id, Hash> } {\n  return (\n    isObject(v) &&\n    ('$type' in v ? v.$type === undefined || is$type(v.$type, id, hash) : true)\n  )\n}\n\nexport type Validator<R = unknown> = (v: unknown) => ValidationResult<R>\nexport type ValidatorParam<V extends Validator> =\n  V extends Validator<infer R> ? R : never\n\n/**\n * Utility function that allows to convert a \"validate*\" utility function into a\n * type predicate.\n */\nexport function asPredicate<V extends Validator>(validate: V) {\n  return function <T>(v: T): v is T & ValidatorParam<V> {\n    return validate(v).success\n  }\n}\n","/**\n * GENERATED CODE - DO NOT MODIFY\n */\nimport { type ValidationResult, BlobRef } from '@atproto/lexicon'\nimport { CID } from 'multiformats/cid'\nimport { validate as _validate } from '../../../lexicons'\nimport { type $Typed, is$typed as _is$typed, type OmitKey } from '../../../util'\nimport type * as OrgHypercertsDefs from '../../org/hypercerts/defs.js'\n\nconst is$typed = _is$typed,\n  validate = _validate\nconst id = 'app.certified.location'\n\nexport interface Main {\n  $type: 'app.certified.location'\n  /** The version of the Location Protocol */\n  lpVersion: string\n  /** The Spatial Reference System URI (e.g., http://www.opengis.net/def/crs/OGC/1.3/CRS84) that defines the coordinate system. */\n  srs: string\n  /** An identifier for the format of the location data (e.g., coordinate-decimal, geojson-point) */\n  locationType: 'coordinate-decimal' | 'geojson-point' | (string & {})\n  location:\n    | $Typed<OrgHypercertsDefs.Uri>\n    | $Typed<OrgHypercertsDefs.SmallBlob>\n    | { $type: string }\n  /** Optional name for this location */\n  name?: string\n  /** Optional description for this location */\n  description?: string\n  /** Client-declared timestamp when this record was originally created */\n  createdAt: string\n  [k: string]: unknown\n}\n\nconst hashMain = 'main'\n\nexport function isMain<V>(v: V) {\n  return is$typed(v, id, hashMain)\n}\n\nexport function validateMain<V>(v: V) {\n  return validate<Main & V>(v, id, hashMain, true)\n}\n\nexport {\n  type Main as Record,\n  isMain as isRecord,\n  validateMain as validateRecord,\n}\n","/**\n * GENERATED CODE - DO NOT MODIFY\n */\nimport { type ValidationResult, BlobRef } from '@atproto/lexicon'\nimport { CID } from 'multiformats/cid'\nimport { validate as _validate } from '../../../../lexicons'\nimport {\n  type $Typed,\n  is$typed as _is$typed,\n  type OmitKey,\n} from '../../../../util'\nimport type * as OrgHypercertsDefs from '../defs.js'\nimport type * as ComAtprotoRepoStrongRef from '../../../com/atproto/repo/strongRef.js'\n\nconst is$typed = _is$typed,\n  validate = _validate\nconst id = 'org.hypercerts.claim.claim'\n\nexport interface Main {\n  $type: 'org.hypercerts.claim.claim'\n  /** Title of the hypercert */\n  title: string\n  /** Short blurb of the impact work done. */\n  shortDescription: string\n  /** Optional longer description of the impact work done. */\n  description?: string\n  image?:\n    | $Typed<OrgHypercertsDefs.Uri>\n    | $Typed<OrgHypercertsDefs.SmallImage>\n    | { $type: string }\n  /** Scope of the work performed */\n  workScope: string\n  /** When the work began */\n  workTimeFrameFrom: string\n  /** When the work ended */\n  workTimeFrameTo: string\n  /** Supporting evidence, documentation, or external data URIs */\n  evidence?: ComAtprotoRepoStrongRef.Main[]\n  /** A strong reference to the contributions done to create the impact in the hypercerts. The record referenced must conform with the lexicon org.hypercerts.claim.contributions */\n  contributions?: ComAtprotoRepoStrongRef.Main[]\n  rights?: ComAtprotoRepoStrongRef.Main\n  location?: ComAtprotoRepoStrongRef.Main\n  /** Client-declared timestamp when this record was originally created */\n  createdAt: string\n  [k: string]: unknown\n}\n\nconst hashMain = 'main'\n\nexport function isMain<V>(v: V) {\n  return is$typed(v, id, hashMain)\n}\n\nexport function validateMain<V>(v: V) {\n  return validate<Main & V>(v, id, hashMain, true)\n}\n\nexport {\n  type Main as Record,\n  isMain as isRecord,\n  validateMain as validateRecord,\n}\n","/**\n * GENERATED CODE - DO NOT MODIFY\n */\nimport { type ValidationResult, BlobRef } from '@atproto/lexicon'\nimport { CID } from 'multiformats/cid'\nimport { validate as _validate } from '../../../../lexicons'\nimport {\n  type $Typed,\n  is$typed as _is$typed,\n  type OmitKey,\n} from '../../../../util'\nimport type * as ComAtprotoRepoStrongRef from '../../../com/atproto/repo/strongRef.js'\n\nconst is$typed = _is$typed,\n  validate = _validate\nconst id = 'org.hypercerts.claim.contribution'\n\nexport interface Main {\n  $type: 'org.hypercerts.claim.contribution'\n  hypercert: ComAtprotoRepoStrongRef.Main\n  /** Role or title of the contributor(s). */\n  role?: string\n  /** List of the contributors (names, pseudonyms, or DIDs). If multiple contributors are stored in the same hypercertContribution, then they would have the exact same role. */\n  contributors: string[]\n  /** What the contribution concretely achieved */\n  description?: string\n  /** When this contribution started. This should be a subset of the hypercert timeframe. */\n  workTimeframeFrom?: string\n  /** When this contribution finished.  This should be a subset of the hypercert timeframe. */\n  workTimeframeTo?: string\n  /** Client-declared timestamp when this record was originally created */\n  createdAt: string\n  [k: string]: unknown\n}\n\nconst hashMain = 'main'\n\nexport function isMain<V>(v: V) {\n  return is$typed(v, id, hashMain)\n}\n\nexport function validateMain<V>(v: V) {\n  return validate<Main & V>(v, id, hashMain, true)\n}\n\nexport {\n  type Main as Record,\n  isMain as isRecord,\n  validateMain as validateRecord,\n}\n","/**\n * GENERATED CODE - DO NOT MODIFY\n */\nimport { type ValidationResult, BlobRef } from '@atproto/lexicon'\nimport { CID } from 'multiformats/cid'\nimport { validate as _validate } from '../../../../lexicons'\nimport {\n  type $Typed,\n  is$typed as _is$typed,\n  type OmitKey,\n} from '../../../../util'\nimport type * as ComAtprotoRepoStrongRef from '../../../com/atproto/repo/strongRef.js'\nimport type * as OrgHypercertsDefs from '../defs.js'\n\nconst is$typed = _is$typed,\n  validate = _validate\nconst id = 'org.hypercerts.claim.evaluation'\n\nexport interface Main {\n  $type: 'org.hypercerts.claim.evaluation'\n  subject: ComAtprotoRepoStrongRef.Main\n  /** DIDs of the evaluators */\n  evaluators: string[]\n  /** Evaluation data (URIs or blobs) containing detailed reports or methodology */\n  evaluations?: (\n    | $Typed<OrgHypercertsDefs.Uri>\n    | $Typed<OrgHypercertsDefs.SmallBlob>\n    | { $type: string }\n  )[]\n  /** Brief evaluation summary */\n  summary: string\n  /** Client-declared timestamp when this record was originally created */\n  createdAt: string\n  [k: string]: unknown\n}\n\nconst hashMain = 'main'\n\nexport function isMain<V>(v: V) {\n  return is$typed(v, id, hashMain)\n}\n\nexport function validateMain<V>(v: V) {\n  return validate<Main & V>(v, id, hashMain, true)\n}\n\nexport {\n  type Main as Record,\n  isMain as isRecord,\n  validateMain as validateRecord,\n}\n","/**\n * GENERATED CODE - DO NOT MODIFY\n */\nimport { type ValidationResult, BlobRef } from '@atproto/lexicon'\nimport { CID } from 'multiformats/cid'\nimport { validate as _validate } from '../../../../lexicons'\nimport {\n  type $Typed,\n  is$typed as _is$typed,\n  type OmitKey,\n} from '../../../../util'\nimport type * as OrgHypercertsDefs from '../defs.js'\n\nconst is$typed = _is$typed,\n  validate = _validate\nconst id = 'org.hypercerts.claim.evidence'\n\nexport interface Main {\n  $type: 'org.hypercerts.claim.evidence'\n  content:\n    | $Typed<OrgHypercertsDefs.Uri>\n    | $Typed<OrgHypercertsDefs.SmallBlob>\n    | { $type: string }\n  /** Optional title to describe the nature of the evidence */\n  title?: string\n  /** Short description explaining what this evidence demonstrates or proves */\n  shortDescription: string\n  /** Optional longer description describing the impact claim evidence. */\n  description?: string\n  /** Client-declared timestamp when this hypercert claim was originally created */\n  createdAt: string\n  [k: string]: unknown\n}\n\nconst hashMain = 'main'\n\nexport function isMain<V>(v: V) {\n  return is$typed(v, id, hashMain)\n}\n\nexport function validateMain<V>(v: V) {\n  return validate<Main & V>(v, id, hashMain, true)\n}\n\nexport {\n  type Main as Record,\n  isMain as isRecord,\n  validateMain as validateRecord,\n}\n","/**\n * GENERATED CODE - DO NOT MODIFY\n */\nimport { type ValidationResult, BlobRef } from '@atproto/lexicon'\nimport { CID } from 'multiformats/cid'\nimport { validate as _validate } from '../../../../lexicons'\nimport {\n  type $Typed,\n  is$typed as _is$typed,\n  type OmitKey,\n} from '../../../../util'\nimport type * as ComAtprotoRepoStrongRef from '../../../com/atproto/repo/strongRef.js'\n\nconst is$typed = _is$typed,\n  validate = _validate\nconst id = 'org.hypercerts.claim.measurement'\n\nexport interface Main {\n  $type: 'org.hypercerts.claim.measurement'\n  hypercert: ComAtprotoRepoStrongRef.Main\n  /** DIDs of the entity (or entities) that measured this data */\n  measurers: string[]\n  /** The metric being measured */\n  metric: string\n  /** The measured value */\n  value: string\n  /** URI to methodology documentation, standard protocol, or measurement procedure */\n  measurementMethodURI?: string\n  /** URIs to supporting evidence or data */\n  evidenceURI?: string[]\n  /** Client-declared timestamp when this record was originally created */\n  createdAt: string\n  [k: string]: unknown\n}\n\nconst hashMain = 'main'\n\nexport function isMain<V>(v: V) {\n  return is$typed(v, id, hashMain)\n}\n\nexport function validateMain<V>(v: V) {\n  return validate<Main & V>(v, id, hashMain, true)\n}\n\nexport {\n  type Main as Record,\n  isMain as isRecord,\n  validateMain as validateRecord,\n}\n","/**\n * GENERATED CODE - DO NOT MODIFY\n */\nimport { type ValidationResult, BlobRef } from '@atproto/lexicon'\nimport { CID } from 'multiformats/cid'\nimport { validate as _validate } from '../../../../lexicons'\nimport {\n  type $Typed,\n  is$typed as _is$typed,\n  type OmitKey,\n} from '../../../../util'\n\nconst is$typed = _is$typed,\n  validate = _validate\nconst id = 'org.hypercerts.claim.rights'\n\nexport interface Main {\n  $type: 'org.hypercerts.claim.rights'\n  /** Full name of the rights */\n  rightsName: string\n  /** Short rights identifier for easier search */\n  rightsType: string\n  /** Description of the rights of this hypercert */\n  rightsDescription: string\n  /** Client-declared timestamp when this record was originally created */\n  createdAt: string\n  [k: string]: unknown\n}\n\nconst hashMain = 'main'\n\nexport function isMain<V>(v: V) {\n  return is$typed(v, id, hashMain)\n}\n\nexport function validateMain<V>(v: V) {\n  return validate<Main & V>(v, id, hashMain, true)\n}\n\nexport {\n  type Main as Record,\n  isMain as isRecord,\n  validateMain as validateRecord,\n}\n","/**\n * GENERATED CODE - DO NOT MODIFY\n */\nimport { type ValidationResult, BlobRef } from '@atproto/lexicon'\nimport { CID } from 'multiformats/cid'\nimport { validate as _validate } from '../../../lexicons'\nimport { type $Typed, is$typed as _is$typed, type OmitKey } from '../../../util'\nimport type * as OrgHypercertsDefs from './defs.js'\nimport type * as ComAtprotoRepoStrongRef from '../../com/atproto/repo/strongRef.js'\n\nconst is$typed = _is$typed,\n  validate = _validate\nconst id = 'org.hypercerts.collection'\n\nexport interface Main {\n  $type: 'org.hypercerts.collection'\n  /** The title of this collection */\n  title: string\n  /** A short description of this collection */\n  shortDescription?: string\n  coverPhoto?:\n    | $Typed<OrgHypercertsDefs.Uri>\n    | $Typed<OrgHypercertsDefs.SmallBlob>\n    | { $type: string }\n  /** Array of claims with their associated weights in this collection */\n  claims: ClaimItem[]\n  /** Client-declared timestamp when this record was originally created */\n  createdAt: string\n  [k: string]: unknown\n}\n\nconst hashMain = 'main'\n\nexport function isMain<V>(v: V) {\n  return is$typed(v, id, hashMain)\n}\n\nexport function validateMain<V>(v: V) {\n  return validate<Main & V>(v, id, hashMain, true)\n}\n\nexport {\n  type Main as Record,\n  isMain as isRecord,\n  validateMain as validateRecord,\n}\n\nexport interface ClaimItem {\n  $type?: 'org.hypercerts.collection#claimItem'\n  claim: ComAtprotoRepoStrongRef.Main\n  /** The weight/importance of this hypercert claim in the collection (a percentage from 0-100, stored as a string to avoid float precision issues). The total claim weights should add up to 100. */\n  weight: string\n}\n\nconst hashClaimItem = 'claimItem'\n\nexport function isClaimItem<V>(v: V) {\n  return is$typed(v, id, hashClaimItem)\n}\n\nexport function validateClaimItem<V>(v: V) {\n  return validate<ClaimItem & V>(v, id, hashClaimItem)\n}\n","/**\n * GENERATED CODE - DO NOT MODIFY\n */\nimport { type ValidationResult, BlobRef } from '@atproto/lexicon'\nimport { CID } from 'multiformats/cid'\nimport { validate as _validate } from '../../../lexicons'\nimport { type $Typed, is$typed as _is$typed, type OmitKey } from '../../../util'\n\nconst is$typed = _is$typed,\n  validate = _validate\nconst id = 'org.hypercerts.defs'\n\n/** Object containing a URI to external data */\nexport interface Uri {\n  $type?: 'org.hypercerts.defs#uri'\n  /** URI to external data */\n  uri: string\n}\n\nconst hashUri = 'uri'\n\nexport function isUri<V>(v: V) {\n  return is$typed(v, id, hashUri)\n}\n\nexport function validateUri<V>(v: V) {\n  return validate<Uri & V>(v, id, hashUri)\n}\n\n/** Object containing a blob to external data */\nexport interface SmallBlob {\n  $type?: 'org.hypercerts.defs#smallBlob'\n  /** Blob to external data (up to 10MB) */\n  blob: BlobRef\n}\n\nconst hashSmallBlob = 'smallBlob'\n\nexport function isSmallBlob<V>(v: V) {\n  return is$typed(v, id, hashSmallBlob)\n}\n\nexport function validateSmallBlob<V>(v: V) {\n  return validate<SmallBlob & V>(v, id, hashSmallBlob)\n}\n\n/** Object containing a blob to external data */\nexport interface LargeBlob {\n  $type?: 'org.hypercerts.defs#largeBlob'\n  /** Blob to external data (up to 100MB) */\n  blob: BlobRef\n}\n\nconst hashLargeBlob = 'largeBlob'\n\nexport function isLargeBlob<V>(v: V) {\n  return is$typed(v, id, hashLargeBlob)\n}\n\nexport function validateLargeBlob<V>(v: V) {\n  return validate<LargeBlob & V>(v, id, hashLargeBlob)\n}\n\n/** Object containing a small image */\nexport interface SmallImage {\n  $type?: 'org.hypercerts.defs#smallImage'\n  /** Image (up to 5MB) */\n  image: BlobRef\n}\n\nconst hashSmallImage = 'smallImage'\n\nexport function isSmallImage<V>(v: V) {\n  return is$typed(v, id, hashSmallImage)\n}\n\nexport function validateSmallImage<V>(v: V) {\n  return validate<SmallImage & V>(v, id, hashSmallImage)\n}\n\n/** Object containing a large image */\nexport interface LargeImage {\n  $type?: 'org.hypercerts.defs#largeImage'\n  /** Image (up to 10MB) */\n  image: BlobRef\n}\n\nconst hashLargeImage = 'largeImage'\n\nexport function isLargeImage<V>(v: V) {\n  return is$typed(v, id, hashLargeImage)\n}\n\nexport function validateLargeImage<V>(v: V) {\n  return validate<LargeImage & V>(v, id, hashLargeImage)\n}\n","/**\n * GENERATED CODE - DO NOT MODIFY\n */\nimport { type ValidationResult, BlobRef } from '@atproto/lexicon'\nimport { CID } from 'multiformats/cid'\nimport { validate as _validate } from '../../../../lexicons'\nimport {\n  type $Typed,\n  is$typed as _is$typed,\n  type OmitKey,\n} from '../../../../util'\n\nconst is$typed = _is$typed,\n  validate = _validate\nconst id = 'app.gainforest.common.defs'\n\n/** Object containing a URI to external data */\nexport interface Uri {\n  $type?: 'app.gainforest.common.defs#uri'\n  /** URI to external data */\n  uri: string\n}\n\nconst hashUri = 'uri'\n\nexport function isUri<V>(v: V) {\n  return is$typed(v, id, hashUri)\n}\n\nexport function validateUri<V>(v: V) {\n  return validate<Uri & V>(v, id, hashUri)\n}\n\n/** Object containing a blob to external data */\nexport interface SmallBlob {\n  $type?: 'app.gainforest.common.defs#smallBlob'\n  /** Blob to external data (up to 10MB) */\n  blob: BlobRef\n}\n\nconst hashSmallBlob = 'smallBlob'\n\nexport function isSmallBlob<V>(v: V) {\n  return is$typed(v, id, hashSmallBlob)\n}\n\nexport function validateSmallBlob<V>(v: V) {\n  return validate<SmallBlob & V>(v, id, hashSmallBlob)\n}\n\n/** Object containing a blob to external data */\nexport interface LargeBlob {\n  $type?: 'app.gainforest.common.defs#largeBlob'\n  /** Blob to external data (up to 100MB) */\n  blob: BlobRef\n}\n\nconst hashLargeBlob = 'largeBlob'\n\nexport function isLargeBlob<V>(v: V) {\n  return is$typed(v, id, hashLargeBlob)\n}\n\nexport function validateLargeBlob<V>(v: V) {\n  return validate<LargeBlob & V>(v, id, hashLargeBlob)\n}\n\n/** Object containing a small image */\nexport interface SmallImage {\n  $type?: 'app.gainforest.common.defs#smallImage'\n  /** Image (up to 5MB) */\n  image: BlobRef\n}\n\nconst hashSmallImage = 'smallImage'\n\nexport function isSmallImage<V>(v: V) {\n  return is$typed(v, id, hashSmallImage)\n}\n\nexport function validateSmallImage<V>(v: V) {\n  return validate<SmallImage & V>(v, id, hashSmallImage)\n}\n\n/** Object containing a large image */\nexport interface LargeImage {\n  $type?: 'app.gainforest.common.defs#largeImage'\n  /** Image (up to 10MB) */\n  image: BlobRef\n}\n\nconst hashLargeImage = 'largeImage'\n\nexport function isLargeImage<V>(v: V) {\n  return is$typed(v, id, hashLargeImage)\n}\n\nexport function validateLargeImage<V>(v: V) {\n  return validate<LargeImage & V>(v, id, hashLargeImage)\n}\n\nexport interface IndexedOrganization {\n  $type?: 'app.gainforest.common.defs#indexedOrganization'\n  /** The URI of the organization */\n  id: string\n  /** The name of the organization */\n  name: string\n}\n\nconst hashIndexedOrganization = 'indexedOrganization'\n\nexport function isIndexedOrganization<V>(v: V) {\n  return is$typed(v, id, hashIndexedOrganization)\n}\n\nexport function validateIndexedOrganization<V>(v: V) {\n  return validate<IndexedOrganization & V>(v, id, hashIndexedOrganization)\n}\n","/**\n * GENERATED CODE - DO NOT MODIFY\n */\nimport { type ValidationResult, BlobRef } from '@atproto/lexicon'\nimport { CID } from 'multiformats/cid'\nimport { validate as _validate } from '../../../../lexicons'\nimport {\n  type $Typed,\n  is$typed as _is$typed,\n  type OmitKey,\n} from '../../../../util'\n\nconst is$typed = _is$typed,\n  validate = _validate\nconst id = 'app.gainforest.organization.defaultSite'\n\nexport interface Main {\n  $type: 'app.gainforest.organization.defaultSite'\n  /** The reference to the default site record in the PDS */\n  site: string\n  [k: string]: unknown\n}\n\nconst hashMain = 'main'\n\nexport function isMain<V>(v: V) {\n  return is$typed(v, id, hashMain)\n}\n\nexport function validateMain<V>(v: V) {\n  return validate<Main & V>(v, id, hashMain, true)\n}\n\nexport {\n  type Main as Record,\n  isMain as isRecord,\n  validateMain as validateRecord,\n}\n","/**\n * GENERATED CODE - DO NOT MODIFY\n */\nimport { HeadersMap, XRPCError } from '@atproto/xrpc'\nimport { type ValidationResult, BlobRef } from '@atproto/lexicon'\nimport { CID } from 'multiformats/cid'\nimport { validate as _validate } from '../../../../lexicons'\nimport {\n  type $Typed,\n  is$typed as _is$typed,\n  type OmitKey,\n} from '../../../../util'\nimport type * as AppGainforestCommonDefs from '../common/defs.js'\n\nconst is$typed = _is$typed,\n  validate = _validate\nconst id = 'app.gainforest.organization.getIndexedOrganizations'\n\nexport type QueryParams = {}\nexport type InputSchema = undefined\n\nexport interface OutputSchema {\n  organizations: AppGainforestCommonDefs.IndexedOrganization[]\n}\n\nexport interface CallOptions {\n  signal?: AbortSignal\n  headers?: HeadersMap\n}\n\nexport interface Response {\n  success: boolean\n  headers: HeadersMap\n  data: OutputSchema\n}\n\nexport function toKnownErr(e: any) {\n  return e\n}\n","/**\n * GENERATED CODE - DO NOT MODIFY\n */\nimport { type ValidationResult, BlobRef } from '@atproto/lexicon'\nimport { CID } from 'multiformats/cid'\nimport { validate as _validate } from '../../../../lexicons'\nimport {\n  type $Typed,\n  is$typed as _is$typed,\n  type OmitKey,\n} from '../../../../util'\nimport type * as AppGainforestCommonDefs from '../common/defs.js'\n\nconst is$typed = _is$typed,\n  validate = _validate\nconst id = 'app.gainforest.organization.info'\n\nexport interface Main {\n  $type: 'app.gainforest.organization.info'\n  /** The name of the organization or project */\n  displayName: string\n  /** The description of the organization or project */\n  shortDescription: string\n  /** The long description of the organization or project in markdown */\n  longDescription: string\n  coverImage?: AppGainforestCommonDefs.SmallImage\n  logo?: AppGainforestCommonDefs.SmallImage\n  /** The objectives of the organization or project */\n  objectives: (\n    | 'Conservation'\n    | 'Research'\n    | 'Education'\n    | 'Community'\n    | 'Other'\n  )[]\n  /** The start date of the organization or project */\n  startDate?: string\n  /** The website of the organization or project */\n  website?: string\n  /** The country of the organization or project in two letter code (ISO 3166-1 alpha-2) */\n  country: string\n  /** The visibility of the organization or project in the Green Globe */\n  visibility: 'Public' | 'Hidden'\n  [k: string]: unknown\n}\n\nconst hashMain = 'main'\n\nexport function isMain<V>(v: V) {\n  return is$typed(v, id, hashMain)\n}\n\nexport function validateMain<V>(v: V) {\n  return validate<Main & V>(v, id, hashMain, true)\n}\n\nexport {\n  type Main as Record,\n  isMain as isRecord,\n  validateMain as validateRecord,\n}\n","/**\n * GENERATED CODE - DO NOT MODIFY\n */\nimport { type ValidationResult, BlobRef } from '@atproto/lexicon'\nimport { CID } from 'multiformats/cid'\nimport { validate as _validate } from '../../../../lexicons'\nimport {\n  type $Typed,\n  is$typed as _is$typed,\n  type OmitKey,\n} from '../../../../util'\n\nconst is$typed = _is$typed,\n  validate = _validate\nconst id = 'app.gainforest.organization.measuredTrees'\n\nexport interface Main {\n  $type: 'app.gainforest.organization.measuredTrees'\n  /** The uri pointing to the shapefile of the measured trees */\n  shapefile: string\n  [k: string]: unknown\n}\n\nconst hashMain = 'main'\n\nexport function isMain<V>(v: V) {\n  return is$typed(v, id, hashMain)\n}\n\nexport function validateMain<V>(v: V) {\n  return validate<Main & V>(v, id, hashMain, true)\n}\n\nexport {\n  type Main as Record,\n  isMain as isRecord,\n  validateMain as validateRecord,\n}\n","/**\n * GENERATED CODE - DO NOT MODIFY\n */\nimport { type ValidationResult, BlobRef } from '@atproto/lexicon'\nimport { CID } from 'multiformats/cid'\nimport { validate as _validate } from '../../../../lexicons'\nimport {\n  type $Typed,\n  is$typed as _is$typed,\n  type OmitKey,\n} from '../../../../util'\nimport type * as AppGainforestCommonDefs from '../common/defs.js'\n\nconst is$typed = _is$typed,\n  validate = _validate\nconst id = 'app.gainforest.organization.site'\n\nexport interface Main {\n  $type: 'app.gainforest.organization.site'\n  /** The name of the site */\n  name: string\n  /** The latitude of the centerpoint of the site */\n  lat: string\n  /** The longitude of the centerpoint of the site */\n  lon: string\n  /** The area of the site in hectares */\n  area: string\n  shapefile:\n    | $Typed<AppGainforestCommonDefs.Uri>\n    | $Typed<AppGainforestCommonDefs.SmallBlob>\n    | { $type: string }\n  trees?:\n    | $Typed<AppGainforestCommonDefs.Uri>\n    | $Typed<AppGainforestCommonDefs.SmallBlob>\n    | { $type: string }\n  [k: string]: unknown\n}\n\nconst hashMain = 'main'\n\nexport function isMain<V>(v: V) {\n  return is$typed(v, id, hashMain)\n}\n\nexport function validateMain<V>(v: V) {\n  return validate<Main & V>(v, id, hashMain, true)\n}\n\nexport {\n  type Main as Record,\n  isMain as isRecord,\n  validateMain as validateRecord,\n}\n","/**\n * GENERATED CODE - DO NOT MODIFY\n */\nimport { type ValidationResult, BlobRef } from '@atproto/lexicon'\nimport { CID } from 'multiformats/cid'\nimport { validate as _validate } from '../../../../lexicons'\nimport {\n  type $Typed,\n  is$typed as _is$typed,\n  type OmitKey,\n} from '../../../../util'\n\nconst is$typed = _is$typed,\n  validate = _validate\nconst id = 'com.atproto.repo.strongRef'\n\nexport interface Main {\n  $type?: 'com.atproto.repo.strongRef'\n  uri: string\n  cid: string\n}\n\nconst hashMain = 'main'\n\nexport function isMain<V>(v: V) {\n  return is$typed(v, id, hashMain)\n}\n\nexport function validateMain<V>(v: V) {\n  return validate<Main & V>(v, id, hashMain)\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkDA,YAAA,yBAAA;AAgBA,YAAA,yBAAA;AAuBA,YAAA,2BAAA;AAzFA,QAAA,QAAA,UAAA,KAAA;AAmBa,YAAA,oBAAoB,MAAA,EAAE,OAAO;MACxC,OAAO,MAAA,EAAE,OAAM,EAAG,SAAQ;MAC1B,SAAS,MAAA,EAAE,OAAM,EAAG,SAAQ;KAC7B;AAGD,QAAY;AAAZ,KAAA,SAAYA,eAAY;AAItB,MAAAA,cAAAA,cAAA,SAAA,IAAA,CAAA,IAAA;AAIA,MAAAA,cAAAA,cAAA,iBAAA,IAAA,CAAA,IAAA;AACA,MAAAA,cAAAA,cAAA,SAAA,IAAA,GAAA,IAAA;AACA,MAAAA,cAAAA,cAAA,gBAAA,IAAA,GAAA,IAAA;AACA,MAAAA,cAAAA,cAAA,wBAAA,IAAA,GAAA,IAAA;AACA,MAAAA,cAAAA,cAAA,WAAA,IAAA,GAAA,IAAA;AACA,MAAAA,cAAAA,cAAA,kBAAA,IAAA,GAAA,IAAA;AACA,MAAAA,cAAAA,cAAA,eAAA,IAAA,GAAA,IAAA;AACA,MAAAA,cAAAA,cAAA,iBAAA,IAAA,GAAA,IAAA;AACA,MAAAA,cAAAA,cAAA,sBAAA,IAAA,GAAA,IAAA;AACA,MAAAA,cAAAA,cAAA,mBAAA,IAAA,GAAA,IAAA;AACA,MAAAA,cAAAA,cAAA,qBAAA,IAAA,GAAA,IAAA;AACA,MAAAA,cAAAA,cAAA,sBAAA,IAAA,GAAA,IAAA;AACA,MAAAA,cAAAA,cAAA,iBAAA,IAAA,GAAA,IAAA;AACA,MAAAA,cAAAA,cAAA,oBAAA,IAAA,GAAA,IAAA;AACA,MAAAA,cAAAA,cAAA,iBAAA,IAAA,GAAA,IAAA;IACF,GAvBY,iBAAY,QAAA,eAAZ,eAAY,CAAA,EAAA;AAyBxB,aAAgB,uBAAuB,QAAc;AACnD,UAAI,UAAU,cAAc;AAC1B,eAAO;MACT,WAAW,UAAU,OAAO,SAAS,KAAK;AACxC,eAAO,aAAa;MACtB,WAAW,UAAU,OAAO,SAAS,KAAK;AACxC,eAAO,aAAa;MACtB,WAAW,UAAU,OAAO,SAAS,KAAK;AACxC,eAAO,aAAa;MACtB,WAAW,UAAU,OAAO,SAAS,KAAK;AACxC,eAAO,aAAa;MACtB,OAAO;AACL,eAAO,aAAa;MACtB;IACF;AAEA,aAAgB,uBAAuB,QAAc;AACnD,aAAO,aAAa,uBAAuB,MAAM,CAAC;IACpD;AAEa,YAAA,sBAAsB;MACjC,CAAC,aAAa,OAAO,GAAG;MACxB,CAAC,aAAa,eAAe,GAAG;MAChC,CAAC,aAAa,OAAO,GAAG;MACxB,CAAC,aAAa,cAAc,GAAG;MAC/B,CAAC,aAAa,sBAAsB,GAAG;MACvC,CAAC,aAAa,SAAS,GAAG;MAC1B,CAAC,aAAa,gBAAgB,GAAG;MACjC,CAAC,aAAa,aAAa,GAAG;MAC9B,CAAC,aAAa,eAAe,GAAG;MAChC,CAAC,aAAa,oBAAoB,GAAG;MACrC,CAAC,aAAa,iBAAiB,GAAG;MAClC,CAAC,aAAa,mBAAmB,GAAG;MACpC,CAAC,aAAa,oBAAoB,GAAG;MACrC,CAAC,aAAa,eAAe,GAAG;MAChC,CAAC,aAAa,kBAAkB,GAAG;MACnC,CAAC,aAAa,eAAe,GAAG;;AAGlC,aAAgB,yBAAyB,QAAc;AACrD,aAAO,QAAA,oBAAoB,uBAAuB,MAAM,CAAC;IAC3D;AAEA,QAAa,eAAb,MAAyB;MAGvB,YACS,MACA,SAAmB;AAD1B,eAAA,eAAA,MAAA,QAAA;;;;iBAAO;;AACP,eAAA,eAAA,MAAA,WAAA;;;;iBAAO;;AAJT,eAAA,eAAA,MAAA,WAAA;;;;iBAAU;;MAKP;;AANL,YAAA,eAAA;AASA,QAAa,YAAb,MAAa,mBAAkB,MAAK;MAKlC,YACE,YACO,QAAgB,uBAAuB,UAAU,GACxD,SACO,SACP,SAAsB;AAEtB,cAAM,WAAW,SAAS,yBAAyB,UAAU,GAAG,OAAO;AALvE,eAAA,eAAA,MAAA,SAAA;;;;iBAAO;;AAEP,eAAA,eAAA,MAAA,WAAA;;;;iBAAO;;AART,eAAA,eAAA,MAAA,WAAA;;;;iBAAU;;AAEH,eAAA,eAAA,MAAA,UAAA;;;;;;AAWL,aAAK,SAAS,uBAAuB,UAAU;AAG/C,cAAM,QAAQ,SAAS;AACvB,YAAI,KAAK,UAAU,UAAa,UAAU,QAAW;AACnD,eAAK,QAAQ;QACf;MACF;MAEA,OAAO,KAAK,OAAgB,gBAA6B;AACvD,YAAI,iBAAiB,YAAW;AAC9B,iBAAO;QACT;AAGA,cAAM,WAAW,iBAAiB,QAAQ,QAAQ;AAGlD,cAAM,gBACJ,iBAAiB,WACb,QACA,QAAQ,UAAU,aAAa,WAC7B,MAAM,UAAU,IAChB;AAER,cAAM;;UAEJ,WAAW,YAAY,KACvB,WAAW,QAAQ;UAEnB,eAAe;;AAGjB,cAAM,SACJ,OAAO,eAAe,WAClB,uBAAuB,UAAU,IACjC,kBAAkB,aAAa;AAErC,cAAM,UAAU,UAAU,WAAW,OAAO,KAAK;AAEjD,cAAM,UAAU,gBACZ,OAAO,YAAY,cAAc,QAAQ,QAAO,CAAE,IAClD;AAEJ,eAAO,IAAI,WAAU,QAAQ,QAAW,SAAS,SAAS,EAAE,MAAK,CAAE;MACrE;;AA3DF,YAAA,YAAA;AA8DA,QAAa,2BAAb,cAA8C,UAAS;MACrD,YACS,aACA,iBACA,cAAqB;AAE5B;UACE,aAAa;;;UAGb,QAAA,oBAAoB,aAAa,eAAe;UAChD;UACA;UACA,EAAE,OAAO,gBAAe;QAAE;AAX5B,eAAA,eAAA,MAAA,eAAA;;;;iBAAO;;AACP,eAAA,eAAA,MAAA,mBAAA;;;;iBAAO;;AACP,eAAA,eAAA,MAAA,gBAAA;;;;iBAAO;;MAWT;;AAfF,YAAA,2BAAA;;;;;;;;;AC1IA,YAAA,sBAAA;AAIA,YAAA,4BAAA;AASA,YAAA,yBAAA;AAUA,YAAA,yBAAA;AAmCA,YAAA,mBAAA;AA6BA,YAAA,6BAAA;AA0EA,YAAA,iBAAA;AA6CA,YAAA,aAAA;AAkBA,YAAA,aAAA;AAUA,YAAA,uBAAA;AAgGA,YAAA,wBAAA;AApWA,QAAA,YAAA,UAAA,kBAAA;AAMA,QAAA,UAAA;AAUA,QAAM,iBACJ,WAAW,kBACV,MAAA;MACC,cAAA;AAGE,cAAM,IAAI,MAAM,qDAAqD;MACvE;;AAGJ,aAAgB,oBAAoB,GAAU;AAC5C,aAAO,QAAA,kBAAkB,UAAU,CAAC,EAAE;IACxC;AAEA,aAAgB,0BACd,QAAuC;AAEvC,UAAI,OAAO,SAAS,aAAa;AAC/B,eAAO;MACT;AACA,aAAO;IACT;AAEA,aAAgB,uBACd,MACA,QACA,YACA,QAAoB;AAEpB,YAAM,MAAM,IAAI,IAAI,uBAAuB,MAAM,QAAQ,MAAM,GAAG,UAAU;AAC5E,aAAO,IAAI,SAAQ;IACrB;AAEA,aAAgB,uBACd,MACA,QACA,QAAoB;AAEpB,YAAM,WAAW,SAAS,mBAAmB,IAAI,CAAC;AAClD,UAAI,CAAC;AAAQ,eAAO;AAEpB,YAAM,eAAmC,CAAA;AAEzC,iBAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,MAAM,GAAG;AACjD,cAAM,cAAc,OAAO,YAAY,aAAa,GAAG;AACvD,YAAI,CAAC,aAAa;AAChB,gBAAM,IAAI,MAAM,4BAA4B,GAAG,EAAE;QACnD;AACA,YAAI,UAAU,QAAW;AACvB,cAAI,YAAY,SAAS,SAAS;AAChC,kBAAM,SAAS,MAAM,QAAQ,KAAK,IAAI,QAAQ,CAAC,KAAK;AACpD,uBAAW,OAAO,QAAQ;AACxB,2BAAa,KAAK;gBAChB;gBACA,iBAAiB,YAAY,MAAM,MAAM,GAAG;eAC7C;YACH;UACF,OAAO;AACL,yBAAa,KAAK,CAAC,KAAK,iBAAiB,YAAY,MAAM,KAAK,CAAC,CAAC;UACpE;QACF;MACF;AAEA,UAAI,CAAC,aAAa;AAAQ,eAAO;AAEjC,aAAO,GAAG,QAAQ,IAAI,IAAI,gBAAgB,YAAY,EAAE,SAAQ,CAAE;IACpE;AAEA,aAAgB,iBACd,MAQA,OAAU;AAEV,UAAI,SAAS,YAAY,SAAS,WAAW;AAC3C,eAAO,OAAO,KAAK;MACrB;AACA,UAAI,SAAS,SAAS;AACpB,eAAO,OAAO,OAAO,KAAK,CAAC;MAC7B,WAAW,SAAS,WAAW;AAC7B,eAAO,OAAO,OAAO,KAAK,IAAI,CAAC;MACjC,WAAW,SAAS,WAAW;AAC7B,eAAO,QAAQ,SAAS;MAC1B,WAAW,SAAS,YAAY;AAC9B,YAAI,iBAAiB,MAAM;AACzB,iBAAO,MAAM,YAAW;QAC1B;AACA,eAAO,OAAO,KAAK;MACrB;AACA,YAAM,IAAI,MAAM,iCAAiC,IAAI,EAAE;IACzD;AAEA,aAAgB,2BACd,QACA,MACA,MAAkB;AAQlB,YAAM,UAAU,IAAI,QAAO;AAE3B,UAAI,MAAM,SAAS;AACjB,mBAAW,QAAQ,KAAK,SAAS;AAC/B,cAAI,QAAQ,IAAI,IAAI,GAAG;AACrB,kBAAM,IAAI,UAAU,qBAAqB,IAAI,EAAE;UACjD;AAEA,gBAAM,QAAQ,KAAK,QAAQ,IAAI;AAC/B,cAAI,SAAS,MAAM;AACjB,oBAAQ,IAAI,MAAM,KAAK;UACzB;QACF;MACF;AAEA,UAAI,OAAO,SAAS,aAAa;AAC/B,YAAI,MAAM,UAAU;AAClB,kBAAQ,IAAI,gBAAgB,KAAK,QAAQ;QAC3C,WAAW,CAAC,QAAQ,IAAI,cAAc,KAAK,OAAO,SAAS,aAAa;AAEtE,cACE,gBAAgB,eAChB,gBAAgB,kBAChB,YAAY,OAAO,IAAI,GACvB;AACA,oBAAQ,IAAI,gBAAgB,0BAA0B;UACxD,WAAW,gBAAgB,UAAU;AAInC,oBAAQ,IAAI,gBAAgB,qBAAqB;UACnD,WAAW,gBAAgB,iBAAiB;AAC1C,oBAAQ,IACN,gBACA,iDAAiD;UAErD,WAAW,WAAW,IAAI,GAAG;AAC3B,oBAAQ,IAAI,gBAAgB,KAAK,QAAQ,0BAA0B;UACrE,WAAW,OAAO,SAAS,UAAU;AACnC,oBAAQ,IAAI,gBAAgB,0BAA0B;UACxD,WAES,WAAW,IAAI,GAAG;AACzB,oBAAQ,IAAI,gBAAgB,0BAA0B;UACxD,WACE,OAAO,SAAS,aAChB,OAAO,SAAS,YAChB,OAAO,SAAS,YAChB,OAAO,SAAS,UAChB;AACA,oBAAQ,IAAI,gBAAgB,kBAAkB;UAChD,OAAO;AAEL,kBAAM,IAAI,QAAA,UACR,QAAA,aAAa,gBACb,0BAA0B,OAAO,IAAI,EAAE;UAE3C;QACF;MACF;AACA,aAAO;IACT;AAEA,aAAgB,eACd,aACA,gBAAwE;AAExE,UAAI,CAAC;AAAgB,eAAO;AAE5B,UAAI,UAA+B;AAEnC,iBAAW,CAAC,MAAM,UAAU,KAAK,gBAAgB;AAG/C,YAAI,eAAe;AAAW;AAG9B,oBAAA,UAAY,IAAI,QAAQ,WAAW;AAEnC,YAAI,QAAQ,IAAI,IAAI;AAAG;AAEvB,cAAM,QAAQ,OAAO,eAAe,aAAa,WAAU,IAAK;AAEhE,YAAI,OAAO,UAAU;AAAU,kBAAQ,IAAI,MAAM,KAAK;iBAC7C,UAAU;AAAM,kBAAQ,OAAO,IAAI;;AACvC,gBAAM,IAAI,UAAU,YAAY,IAAI,mBAAmB,OAAO,KAAK,EAAE;MAC5E;AAEA,aAAO,WAAW;IACpB;AAEA,aAAS,WAAW,OAAc;AAChC,UAAI,SAAS;AAAM,eAAO;AAC1B,UAAI,OAAO,UAAU;AAAU,eAAO;AACtC,UAAI,OAAO,SAAS,cAAc,iBAAiB;AAAM,eAAO;AAMhE,YAAM,MAAM,MAAM,OAAO,WAAW;AACpC,UAAI,QAAQ,UAAU,QAAQ,QAAQ;AACpC,eAAO,YAAY,SAAS,OAAO,MAAM,WAAW;MACtD;AAEA,aAAO;IACT;AAEA,aAAgB,WAAW,OAAc;AACvC,cAAQ,OAAO,OAAO;QACpB,KAAK;AACH,iBAAO;QACT,KAAK;AACH,iBACE,iBAAiB,eACjB,iBAAiB,YACjB,iBAAiB,mBACjB,iBAAiB,kBACjB,YAAY,OAAO,KAAK,KACxB,WAAW,KAAK;QAEpB;AACE,iBAAO;MACX;IACF;AAEA,aAAgB,WACd,OAAc;AAEd,aACE,SAAS,QACT,OAAO,UAAU,aAChB,OAAO,YAAY,SAAS,OAAO,iBAAiB;IAEzD;AAEA,aAAgB,qBACd,SACA,MAAc;AAGd,YAAM,cAAc,QAAQ,IAAI,cAAc;AAC9C,UAAI,CAAC,aAAa;AAChB,eAAO;MACT;AAEA,UAAI,OAAO,SAAS,aAAa;AAI/B,cAAM,IAAI,QAAA,UACR,QAAA,aAAa,gBACb,kDAAkD;MAEtD;AAEA,UAAI,WAAW,IAAI,GAAG;AACpB,YAAI,gBAAgB,YAAY,gBAAgB,uBAAuB;AAKrE,kBAAQ,OAAO,cAAc;QAC/B;AAGA,eAAO;MACT;AAEA,UAAI,WAAW,IAAI,GAAG;AAGpB,eAAO,yBAAyB,IAAI;MACtC;AAEA,UAAI,YAAY,WAAW,OAAO,GAAG;AACnC,eAAO,IAAI,YAAW,EAAG,OAAO,OAAO,IAAI,CAAC;MAC9C;AACA,UAAI,YAAY,WAAW,kBAAkB,GAAG;AAC9C,cAAM,QAAO,GAAA,UAAA,cAAa,IAAI;AAG9B,YAAI,SAAS,QAAW;AACtB,gBAAM,IAAI,QAAA,UACR,QAAA,aAAa,gBACb,uCAAuC;QAE3C;AACA,eAAO,IAAI,YAAW,EAAG,OAAO,IAAI;MACtC;AAMA,YAAM,OACJ,CAAC,QAAQ,OAAO,SAAS,WACrB,OAAO,OACP,KAAK,gBAAgB,UACnB,OAAO,KAAK,gBAAgB,cAC5B,OAAO,KAAK,aAAa,SAAS,WAClC,KAAK,YAAY,OACjB;AAER,YAAM,IAAI,QAAA,UACR,QAAA,aAAa,gBACb,oBAAoB,IAAI,OAAO,WAAW,OAAO;IAErD;AAKA,aAAS,yBACP,UAAoD;AAGpD,UAAI,UAAU,kBAAkB,OAAO,eAAe,SAAS,YAAY;AACzE,eAAO,eAAe,KAAK,QAAQ;MACrC;AAMA,YAAM,IAAI,UACR,0MAEiF;IAErF;AAEA,aAAgB,sBACd,UACA,MAA6B;AAE7B,UAAI;AACF,YAAI,UAAU;AACZ,cAAI,SAAS,SAAS,kBAAkB,GAAG;AACzC,kBAAM,MAAM,IAAI,YAAW,EAAG,OAAO,IAAI;AACzC,oBAAO,GAAA,UAAA,iBAAgB,GAAG;UAC5B;AACA,cAAI,SAAS,WAAW,OAAO,GAAG;AAChC,mBAAO,IAAI,YAAW,EAAG,OAAO,IAAI;UACtC;QACF;AACA,YAAI,gBAAgB,aAAa;AAC/B,iBAAO,IAAI,WAAW,IAAI;QAC5B;AACA,eAAO;MACT,SAAS,OAAO;AACd,cAAM,IAAI,QAAA,UACR,QAAA,aAAa,iBACb,QACA,kCAAkC,OAAO,KAAK,CAAC,IAC/C,QACA,EAAE,MAAK,CAAE;MAEb;IACF;;;;;;;;;ACxUA,YAAA,oBAAA;AAtDA,QAAA,SAAA;AAsDA,aAAgB,kBACd,SAAgE;AAGhE,UAAI,OAAO,YAAY;AAAY,eAAO;AAC1C,UAAI,OAAO,YAAY,YAAY,kBAAkB,SAAS;AAC5D,eAAO,QAAQ,aAAa,KAAK,OAAO;MAC1C;AAEA,YAAM,EACJ,SACA,SAAS,iBAAiB,QAC1B,OAAAC,SAAQ,WAAW,MAAK,IACtB,OAAO,YAAY,YAAY,mBAAmB,MAClD,EAAE,SAAS,QAAO,IAClB;AAEJ,UAAI,OAAOA,WAAU,YAAY;AAC/B,cAAM,IAAI,UACR,sEAAsE;MAE1E;AAEA,YAAM,wBACJ,kBAAkB,OAAO,OAAO,QAAQ,cAAc,IAAI;AAE5D,aAAO,eAAgB,KAAK,MAAI;AAC9B,cAAM,OAAO,OAAO,YAAY,aAAa,QAAO,IAAK;AACzD,cAAM,UAAU,IAAI,IAAI,KAAK,IAAI;AAEjC,cAAM,WAAU,GAAA,OAAA,gBAAe,KAAK,SAAS,qBAAqB;AAElE,eAAOA,OAAM,SAAS,EAAE,GAAG,MAAM,QAAO,CAAE;MAC5C;IACF;;;;;;;;;;ACzFA,QAAA,YAAA,UAAA,kBAAA;AACA,QAAA,kBAAA;AAMA,QAAA,UAAA;AAUA,QAAA,SAAA;AAUA,QAAaC,cAAb,MAAuB;MAKrB,YACE,kBAGA,KAAoC;AAR7B,eAAA,eAAA,MAAA,gBAAA;;;;;;AACA,eAAA,eAAA,MAAA,WAAA;;;;iBAAU,oBAAI,IAAG;;AACjB,eAAA,eAAA,MAAA,OAAA;;;;;;AAQP,aAAK,gBAAe,GAAA,gBAAA,mBAAkB,gBAAgB;AAEtD,aAAK,MAAM,eAAe,UAAA,WAAW,MAAM,IAAI,UAAA,SAAS,GAAG;MAC7D;MAEA,UAAU,KAAa,OAA8B;AACnD,aAAK,QAAQ,IAAI,IAAI,YAAW,GAAI,KAAK;MAC3C;MAEA,YAAY,KAAW;AACrB,aAAK,QAAQ,OAAO,IAAI,YAAW,CAAE;MACvC;MAEA,eAAY;AACV,aAAK,QAAQ,MAAK;MACpB;MAEA,MAAM,KACJ,YACA,QACA,MACA,MAAkB;AAElB,cAAM,MAAM,KAAK,IAAI,cAAc,UAAU;AAC7C,YAAI,CAAC,OAAQ,IAAI,SAAS,WAAW,IAAI,SAAS,aAAc;AAC9D,gBAAM,IAAI,UACR,oBAAoB,UAAU,iCAAiC;QAEnE;AAQA,cAAM,UAAS,GAAA,OAAA,wBAAuB,YAAY,KAAK,MAAM;AAC7D,cAAM,aAAY,GAAA,OAAA,2BAA0B,GAAG;AAC/C,cAAM,cAAa,GAAA,OAAA,4BAA2B,KAAK,MAAM,IAAI;AAC7D,cAAM,WAAU,GAAA,OAAA,sBAAqB,YAAY,IAAI;AAIrD,cAAM,OAAyC;UAC7C,QAAQ;UACR,UAAS,GAAA,OAAA,gBAAe,YAAY,KAAK,OAAO;UAChD,MAAM;UACN,QAAQ;UACR,UAAU;UACV,QAAQ,MAAM;;AAGhB,YAAI;AACF,gBAAM,WAAW,MAAM,KAAK,aAAa,KAAK,QAAW,QAAQ,IAAI;AAErE,gBAAM,YAAY,SAAS;AAC3B,gBAAM,aAAa,OAAO,YAAY,SAAS,QAAQ,QAAO,CAAE;AAChE,gBAAM,eAAe,MAAM,SAAS,YAAW;AAC/C,gBAAM,WAAU,GAAA,OAAA,uBACd,SAAS,QAAQ,IAAI,cAAc,GACnC,YAAY;AAGd,gBAAM,WAAU,GAAA,QAAA,wBAAuB,SAAS;AAChD,cAAI,YAAY,QAAA,aAAa,SAAS;AACpC,kBAAM,EAAE,QAAQ,QAAW,UAAU,OAAS,IAC5C,YAAW,GAAA,OAAA,qBAAoB,OAAO,IAAI,UAAU,CAAA;AACtD,kBAAM,IAAI,QAAA,UAAU,SAAS,OAAO,SAAS,UAAU;UACzD;AAEA,cAAI;AACF,iBAAK,IAAI,sBAAsB,YAAY,OAAO;UACpD,SAAS,GAAY;AACnB,gBAAI,aAAa,UAAA,iBAAiB;AAChC,oBAAM,IAAI,QAAA,yBAAyB,YAAY,GAAG,OAAO;YAC3D;AAEA,kBAAM;UACR;AAEA,iBAAO,IAAI,QAAA,aAAa,SAAS,UAAU;QAC7C,SAAS,KAAK;AACZ,gBAAM,QAAA,UAAU,KAAK,GAAG;QAC1B;MACF;;AA/FF,YAAA,aAAAA;;;;;;;;;;AC3BA,QAAA,YAAA,UAAA,kBAAA;AAEA,QAAA,SAAA;AACA,QAAA,gBAAA;AAGA,QAAa,SAAb,MAAmB;MAAnB,cAAA;AAeE,eAAA,eAAA,MAAA,OAAA;;;;iBAAM,IAAI,UAAA,SAAQ;;MAmCpB;;MAhDE,IAAI,QAAK;AACP,cAAM,IAAI,MACR,iEAAiE;MAErE;;MAGA,IAAI,MAAM,GAAQ;AAChB,cAAM,IAAI,MACR,iEAAiE;MAErE;;;MAOA,MAAM,KACJ,YACA,YACA,QACA,MACA,MAAkB;AAElB,eAAO,KAAK,QAAQ,UAAU,EAAE,KAAK,YAAY,QAAQ,MAAM,IAAI;MACrE;MAEA,QAAQ,YAAwB;AAC9B,eAAO,IAAI,cAAc,MAAM,UAAU;MAC3C;;;MAKA,WAAW,KAAe;AACxB,aAAK,IAAI,IAAI,GAAG;MAClB;MAEA,YAAY,MAAkB;AAC5B,mBAAW,OAAO,MAAM;AACtB,eAAK,WAAW,GAAG;QACrB;MACF;MAEA,cAAc,KAAW;AACvB,aAAK,IAAI,OAAO,GAAG;MACrB;;AAjDF,YAAA,SAAA;AAqDA,QAAa,gBAAb,cAAmC,cAAA,WAAU;MAG3C,YACS,YACP,YAAwB;AAExB,cAAM,OAAO,OAAO,SAAQ;AAC1B,gBAAM,WAAU,GAAA,OAAA,gBAAe,KAAK,SAAS,OAAO,QAAQ,KAAK,OAAO,CAAC;AACzE,iBAAO,MAAM,IAAI,IAAI,OAAO,KAAK,GAAG,GAAG,EAAE,GAAG,MAAM,QAAO,CAAE;QAC7D,GAAG,WAAW,GAAG;AANjB,eAAA,eAAA,MAAA,cAAA;;;;iBAAO;;AAHT,eAAA,eAAA,MAAA,OAAA;;;;;;AAUE,aAAK,MAAM,OAAO,eAAe,WAAW,IAAI,IAAI,UAAU,IAAI;MACpE;;AAZF,YAAA,gBAAA;;;;;;;;;;;;;;;;;;;;;;;;;AC3DA,iBAAA,kBAAA,OAAA;AACA,iBAAA,yBAAA,OAAA;AACA,iBAAA,iBAAA,OAAA;AACA,iBAAA,gBAAA,OAAA;AACA,iBAAA,uBAAA,OAAA;AAGA,QAAA,WAAA;AAEA,QAAM,cAAc,IAAI,SAAA,OAAM;AAC9B,YAAA,UAAe;;;;;ACOf,kBAIO;;;AClBP;AAAA,EAEE;AAAA,EACA;AAAA,OAEK;;;ACSP,SAAS,SAAY,GAAuB;AAC1C,SAAO,KAAK,QAAQ,OAAO,MAAM;AACnC;AAEA,SAAS,QACP,OACAC,MACA,MAC0B;AAC1B,SAAO,SAAS,SACZ,UAAUA;AAAA;AAAA,IAEV,OAAO,UAAU,YACf,MAAM,WAAWA,KAAG,SAAS,IAAI,KAAK,UACtC,MAAM,WAAWA,KAAG,MAAM,MAAM,MAChC,MAAM,WAAWA,IAAE,KACnB,MAAM,SAAS,IAAI;AAAA;AAC3B;AAgBO,SAAS,SACd,GACAA,MACA,MACgC;AAChC,SAAO,SAAS,CAAC,KAAK,WAAW,KAAK,QAAQ,EAAE,OAAOA,MAAI,IAAI;AACjE;AAEO,SAAS,YACd,GACAA,MACA,MAC+C;AAC/C,SACE,SAAS,CAAC,MACT,WAAW,IAAI,EAAE,UAAU,UAAa,QAAQ,EAAE,OAAOA,MAAI,IAAI,IAAI;AAE1E;;;ADxDO,IAAM,aAAa;AAAA,EACxB,sBAAsB;AAAA,IACpB,SAAS;AAAA,IACT,IAAI;AAAA,IACJ,MAAM;AAAA,MACJ,MAAM;AAAA,QACJ,MAAM;AAAA,QACN,aAAa;AAAA,QACb,KAAK;AAAA,QACL,QAAQ;AAAA,UACN,MAAM;AAAA,UACN,UAAU;AAAA,YACR;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF;AAAA,UACA,YAAY;AAAA,YACV,WAAW;AAAA,cACT,MAAM;AAAA,cACN,aAAa;AAAA,cACb,WAAW;AAAA,YACb;AAAA,YACA,KAAK;AAAA,cACH,MAAM;AAAA,cACN,QAAQ;AAAA,cACR,aACE;AAAA,cACF,WAAW;AAAA,YACb;AAAA,YACA,cAAc;AAAA,cACZ,MAAM;AAAA,cACN,aACE;AAAA,cACF,aAAa,CAAC,sBAAsB,eAAe;AAAA,cACnD,WAAW;AAAA,YACb;AAAA,YACA,UAAU;AAAA,cACR,MAAM;AAAA,cACN,MAAM;AAAA,gBACJ;AAAA,gBACA;AAAA,cACF;AAAA,cACA,aACE;AAAA,YACJ;AAAA,YACA,MAAM;AAAA,cACJ,MAAM;AAAA,cACN,aAAa;AAAA,cACb,WAAW;AAAA,cACX,cAAc;AAAA,YAChB;AAAA,YACA,aAAa;AAAA,cACX,MAAM;AAAA,cACN,aAAa;AAAA,cACb,WAAW;AAAA,cACX,cAAc;AAAA,YAChB;AAAA,YACA,WAAW;AAAA,cACT,MAAM;AAAA,cACN,QAAQ;AAAA,cACR,aACE;AAAA,YACJ;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EACA,yBAAyB;AAAA,IACvB,SAAS;AAAA,IACT,IAAI;AAAA,IACJ,MAAM;AAAA,MACJ,MAAM;AAAA,QACJ,MAAM;AAAA,QACN,aAAa;AAAA,QACb,KAAK;AAAA,QACL,QAAQ;AAAA,UACN,MAAM;AAAA,UACN,UAAU;AAAA,YACR;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF;AAAA,UACA,YAAY;AAAA,YACV,OAAO;AAAA,cACL,MAAM;AAAA,cACN,aAAa;AAAA,cACb,WAAW;AAAA,YACb;AAAA,YACA,kBAAkB;AAAA,cAChB,MAAM;AAAA,cACN,aAAa;AAAA,cACb,WAAW;AAAA,cACX,cAAc;AAAA,YAChB;AAAA,YACA,aAAa;AAAA,cACX,MAAM;AAAA,cACN,aACE;AAAA,cACF,WAAW;AAAA,cACX,cAAc;AAAA,YAChB;AAAA,YACA,OAAO;AAAA,cACL,MAAM;AAAA,cACN,MAAM;AAAA,gBACJ;AAAA,gBACA;AAAA,cACF;AAAA,cACA,aACE;AAAA,YACJ;AAAA,YACA,WAAW;AAAA,cACT,MAAM;AAAA,cACN,aAAa;AAAA,cACb,WAAW;AAAA,cACX,cAAc;AAAA,YAChB;AAAA,YACA,mBAAmB;AAAA,cACjB,MAAM;AAAA,cACN,QAAQ;AAAA,cACR,aAAa;AAAA,YACf;AAAA,YACA,iBAAiB;AAAA,cACf,MAAM;AAAA,cACN,QAAQ;AAAA,cACR,aAAa;AAAA,YACf;AAAA,YACA,UAAU;AAAA,cACR,MAAM;AAAA,cACN,aACE;AAAA,cACF,OAAO;AAAA,gBACL,MAAM;AAAA,gBACN,KAAK;AAAA,gBACL,aACE;AAAA,cACJ;AAAA,cACA,WAAW;AAAA,YACb;AAAA,YACA,eAAe;AAAA,cACb,MAAM;AAAA,cACN,aACE;AAAA,cACF,OAAO;AAAA,gBACL,MAAM;AAAA,gBACN,KAAK;AAAA,cACP;AAAA,YACF;AAAA,YACA,QAAQ;AAAA,cACN,MAAM;AAAA,cACN,KAAK;AAAA,cACL,aACE;AAAA,YACJ;AAAA,YACA,UAAU;AAAA,cACR,MAAM;AAAA,cACN,KAAK;AAAA,cACL,aACE;AAAA,YACJ;AAAA,YACA,WAAW;AAAA,cACT,MAAM;AAAA,cACN,QAAQ;AAAA,cACR,aACE;AAAA,YACJ;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EACA,gCAAgC;AAAA,IAC9B,SAAS;AAAA,IACT,IAAI;AAAA,IACJ,MAAM;AAAA,MACJ,MAAM;AAAA,QACJ,MAAM;AAAA,QACN,aAAa;AAAA,QACb,KAAK;AAAA,QACL,QAAQ;AAAA,UACN,MAAM;AAAA,UACN,UAAU,CAAC,aAAa,gBAAgB,WAAW;AAAA,UACnD,YAAY;AAAA,YACV,WAAW;AAAA,cACT,MAAM;AAAA,cACN,KAAK;AAAA,cACL,aACE;AAAA,YACJ;AAAA,YACA,MAAM;AAAA,cACJ,MAAM;AAAA,cACN,aAAa;AAAA,cACb,WAAW;AAAA,YACb;AAAA,YACA,cAAc;AAAA,cACZ,MAAM;AAAA,cACN,aACE;AAAA,cACF,OAAO;AAAA,gBACL,MAAM;AAAA,cACR;AAAA,YACF;AAAA,YACA,aAAa;AAAA,cACX,MAAM;AAAA,cACN,aAAa;AAAA,cACb,WAAW;AAAA,cACX,cAAc;AAAA,YAChB;AAAA,YACA,mBAAmB;AAAA,cACjB,MAAM;AAAA,cACN,QAAQ;AAAA,cACR,aACE;AAAA,YACJ;AAAA,YACA,iBAAiB;AAAA,cACf,MAAM;AAAA,cACN,QAAQ;AAAA,cACR,aACE;AAAA,YACJ;AAAA,YACA,WAAW;AAAA,cACT,MAAM;AAAA,cACN,QAAQ;AAAA,cACR,aACE;AAAA,YACJ;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EACA,8BAA8B;AAAA,IAC5B,SAAS;AAAA,IACT,IAAI;AAAA,IACJ,MAAM;AAAA,MACJ,MAAM;AAAA,QACJ,MAAM;AAAA,QACN,aAAa;AAAA,QACb,KAAK;AAAA,QACL,QAAQ;AAAA,UACN,MAAM;AAAA,UACN,UAAU,CAAC,WAAW,cAAc,WAAW,WAAW;AAAA,UAC1D,YAAY;AAAA,YACV,SAAS;AAAA,cACP,MAAM;AAAA,cACN,KAAK;AAAA,cACL,aACE;AAAA,YACJ;AAAA,YACA,YAAY;AAAA,cACV,MAAM;AAAA,cACN,aAAa;AAAA,cACb,OAAO;AAAA,gBACL,MAAM;AAAA,gBACN,QAAQ;AAAA,cACV;AAAA,cACA,WAAW;AAAA,YACb;AAAA,YACA,aAAa;AAAA,cACX,MAAM;AAAA,cACN,aACE;AAAA,cACF,OAAO;AAAA,gBACL,MAAM;AAAA,gBACN,MAAM;AAAA,kBACJ;AAAA,kBACA;AAAA,gBACF;AAAA,cACF;AAAA,cACA,WAAW;AAAA,YACb;AAAA,YACA,SAAS;AAAA,cACP,MAAM;AAAA,cACN,aAAa;AAAA,cACb,WAAW;AAAA,cACX,cAAc;AAAA,YAChB;AAAA,YACA,WAAW;AAAA,cACT,MAAM;AAAA,cACN,QAAQ;AAAA,cACR,aACE;AAAA,YACJ;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EACA,4BAA4B;AAAA,IAC1B,SAAS;AAAA,IACT,IAAI;AAAA,IACJ,MAAM;AAAA,MACJ,MAAM;AAAA,QACJ,MAAM;AAAA,QACN,aAAa;AAAA,QACb,KAAK;AAAA,QACL,QAAQ;AAAA,UACN,MAAM;AAAA,UACN,UAAU,CAAC,WAAW,oBAAoB,WAAW;AAAA,UACrD,YAAY;AAAA,YACV,SAAS;AAAA,cACP,MAAM;AAAA,cACN,MAAM;AAAA,gBACJ;AAAA,gBACA;AAAA,cACF;AAAA,cACA,aACE;AAAA,YACJ;AAAA,YACA,OAAO;AAAA,cACL,MAAM;AAAA,cACN,WAAW;AAAA,cACX,aACE;AAAA,YACJ;AAAA,YACA,kBAAkB;AAAA,cAChB,MAAM;AAAA,cACN,WAAW;AAAA,cACX,cAAc;AAAA,cACd,aACE;AAAA,YACJ;AAAA,YACA,aAAa;AAAA,cACX,MAAM;AAAA,cACN,aACE;AAAA,cACF,WAAW;AAAA,cACX,cAAc;AAAA,YAChB;AAAA,YACA,WAAW;AAAA,cACT,MAAM;AAAA,cACN,QAAQ;AAAA,cACR,aACE;AAAA,YACJ;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EACA,+BAA+B;AAAA,IAC7B,SAAS;AAAA,IACT,IAAI;AAAA,IACJ,MAAM;AAAA,MACJ,MAAM;AAAA,QACJ,MAAM;AAAA,QACN,aAAa;AAAA,QACb,KAAK;AAAA,QACL,QAAQ;AAAA,UACN,MAAM;AAAA,UACN,UAAU,CAAC,aAAa,aAAa,UAAU,SAAS,WAAW;AAAA,UACnE,YAAY;AAAA,YACV,WAAW;AAAA,cACT,MAAM;AAAA,cACN,KAAK;AAAA,cACL,aACE;AAAA,YACJ;AAAA,YACA,WAAW;AAAA,cACT,MAAM;AAAA,cACN,aACE;AAAA,cACF,OAAO;AAAA,gBACL,MAAM;AAAA,gBACN,QAAQ;AAAA,cACV;AAAA,cACA,WAAW;AAAA,YACb;AAAA,YACA,QAAQ;AAAA,cACN,MAAM;AAAA,cACN,aAAa;AAAA,cACb,WAAW;AAAA,YACb;AAAA,YACA,OAAO;AAAA,cACL,MAAM;AAAA,cACN,aAAa;AAAA,cACb,WAAW;AAAA,YACb;AAAA,YACA,sBAAsB;AAAA,cACpB,MAAM;AAAA,cACN,QAAQ;AAAA,cACR,aACE;AAAA,YACJ;AAAA,YACA,aAAa;AAAA,cACX,MAAM;AAAA,cACN,aAAa;AAAA,cACb,OAAO;AAAA,gBACL,MAAM;AAAA,gBACN,QAAQ;AAAA,cACV;AAAA,cACA,WAAW;AAAA,YACb;AAAA,YACA,WAAW;AAAA,cACT,MAAM;AAAA,cACN,QAAQ;AAAA,cACR,aACE;AAAA,YACJ;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EACA,0BAA0B;AAAA,IACxB,SAAS;AAAA,IACT,IAAI;AAAA,IACJ,MAAM;AAAA,MACJ,MAAM;AAAA,QACJ,MAAM;AAAA,QACN,aACE;AAAA,QACF,KAAK;AAAA,QACL,QAAQ;AAAA,UACN,MAAM;AAAA,UACN,UAAU;AAAA,YACR;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF;AAAA,UACA,YAAY;AAAA,YACV,YAAY;AAAA,cACV,MAAM;AAAA,cACN,aAAa;AAAA,cACb,WAAW;AAAA,YACb;AAAA,YACA,YAAY;AAAA,cACV,MAAM;AAAA,cACN,aAAa;AAAA,cACb,WAAW;AAAA,YACb;AAAA,YACA,mBAAmB;AAAA,cACjB,MAAM;AAAA,cACN,aAAa;AAAA,YACf;AAAA,YACA,WAAW;AAAA,cACT,MAAM;AAAA,cACN,QAAQ;AAAA,cACR,aACE;AAAA,YACJ;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EACA,yBAAyB;AAAA,IACvB,SAAS;AAAA,IACT,IAAI;AAAA,IACJ,MAAM;AAAA,MACJ,MAAM;AAAA,QACJ,MAAM;AAAA,QACN,aACE;AAAA,QACF,KAAK;AAAA,QACL,QAAQ;AAAA,UACN,MAAM;AAAA,UACN,UAAU,CAAC,SAAS,UAAU,WAAW;AAAA,UACzC,YAAY;AAAA,YACV,OAAO;AAAA,cACL,MAAM;AAAA,cACN,aAAa;AAAA,cACb,WAAW;AAAA,cACX,cAAc;AAAA,YAChB;AAAA,YACA,kBAAkB;AAAA,cAChB,MAAM;AAAA,cACN,WAAW;AAAA,cACX,cAAc;AAAA,cACd,aAAa;AAAA,YACf;AAAA,YACA,YAAY;AAAA,cACV,MAAM;AAAA,cACN,MAAM;AAAA,gBACJ;AAAA,gBACA;AAAA,cACF;AAAA,cACA,aACE;AAAA,YACJ;AAAA,YACA,QAAQ;AAAA,cACN,MAAM;AAAA,cACN,aACE;AAAA,cACF,OAAO;AAAA,gBACL,MAAM;AAAA,gBACN,KAAK;AAAA,cACP;AAAA,YACF;AAAA,YACA,WAAW;AAAA,cACT,MAAM;AAAA,cACN,QAAQ;AAAA,cACR,aACE;AAAA,YACJ;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,MACA,WAAW;AAAA,QACT,MAAM;AAAA,QACN,UAAU,CAAC,SAAS,QAAQ;AAAA,QAC5B,YAAY;AAAA,UACV,OAAO;AAAA,YACL,MAAM;AAAA,YACN,KAAK;AAAA,YACL,aACE;AAAA,UACJ;AAAA,UACA,QAAQ;AAAA,YACN,MAAM;AAAA,YACN,aACE;AAAA,UACJ;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EACA,mBAAmB;AAAA,IACjB,SAAS;AAAA,IACT,IAAI;AAAA,IACJ,MAAM;AAAA,MACJ,KAAK;AAAA,QACH,MAAM;AAAA,QACN,UAAU,CAAC,KAAK;AAAA,QAChB,aAAa;AAAA,QACb,YAAY;AAAA,UACV,KAAK;AAAA,YACH,MAAM;AAAA,YACN,QAAQ;AAAA,YACR,cAAc;AAAA,YACd,aAAa;AAAA,UACf;AAAA,QACF;AAAA,MACF;AAAA,MACA,WAAW;AAAA,QACT,MAAM;AAAA,QACN,UAAU,CAAC,MAAM;AAAA,QACjB,aAAa;AAAA,QACb,YAAY;AAAA,UACV,MAAM;AAAA,YACJ,MAAM;AAAA,YACN,QAAQ,CAAC,KAAK;AAAA,YACd,SAAS;AAAA,YACT,aAAa;AAAA,UACf;AAAA,QACF;AAAA,MACF;AAAA,MACA,WAAW;AAAA,QACT,MAAM;AAAA,QACN,UAAU,CAAC,MAAM;AAAA,QACjB,aAAa;AAAA,QACb,YAAY;AAAA,UACV,MAAM;AAAA,YACJ,MAAM;AAAA,YACN,QAAQ,CAAC,KAAK;AAAA,YACd,SAAS;AAAA,YACT,aAAa;AAAA,UACf;AAAA,QACF;AAAA,MACF;AAAA,MACA,YAAY;AAAA,QACV,MAAM;AAAA,QACN,UAAU,CAAC,OAAO;AAAA,QAClB,aAAa;AAAA,QACb,YAAY;AAAA,UACV,OAAO;AAAA,YACL,MAAM;AAAA,YACN,QAAQ,CAAC,cAAc,aAAa,aAAa,YAAY;AAAA,YAC7D,SAAS;AAAA,YACT,aAAa;AAAA,UACf;AAAA,QACF;AAAA,MACF;AAAA,MACA,YAAY;AAAA,QACV,MAAM;AAAA,QACN,UAAU,CAAC,OAAO;AAAA,QAClB,aAAa;AAAA,QACb,YAAY;AAAA,UACV,OAAO;AAAA,YACL,MAAM;AAAA,YACN,QAAQ,CAAC,cAAc,aAAa,aAAa,YAAY;AAAA,YAC7D,SAAS;AAAA,YACT,aAAa;AAAA,UACf;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EACA,yBAAyB;AAAA,IACvB,SAAS;AAAA,IACT,IAAI;AAAA,IACJ,MAAM;AAAA,MACJ,KAAK;AAAA,QACH,MAAM;AAAA,QACN,UAAU,CAAC,KAAK;AAAA,QAChB,aAAa;AAAA,QACb,YAAY;AAAA,UACV,KAAK;AAAA,YACH,MAAM;AAAA,YACN,QAAQ;AAAA,YACR,cAAc;AAAA,YACd,aAAa;AAAA,UACf;AAAA,QACF;AAAA,MACF;AAAA,MACA,WAAW;AAAA,QACT,MAAM;AAAA,QACN,UAAU,CAAC,MAAM;AAAA,QACjB,aAAa;AAAA,QACb,YAAY;AAAA,UACV,MAAM;AAAA,YACJ,MAAM;AAAA,YACN,QAAQ,CAAC,KAAK;AAAA,YACd,SAAS;AAAA,YACT,aAAa;AAAA,UACf;AAAA,QACF;AAAA,MACF;AAAA,MACA,WAAW;AAAA,QACT,MAAM;AAAA,QACN,UAAU,CAAC,MAAM;AAAA,QACjB,aAAa;AAAA,QACb,YAAY;AAAA,UACV,MAAM;AAAA,YACJ,MAAM;AAAA,YACN,QAAQ,CAAC,KAAK;AAAA,YACd,SAAS;AAAA,YACT,aAAa;AAAA,UACf;AAAA,QACF;AAAA,MACF;AAAA,MACA,YAAY;AAAA,QACV,MAAM;AAAA,QACN,UAAU,CAAC,OAAO;AAAA,QAClB,aAAa;AAAA,QACb,YAAY;AAAA,UACV,OAAO;AAAA,YACL,MAAM;AAAA,YACN,QAAQ,CAAC,cAAc,aAAa,aAAa,YAAY;AAAA,YAC7D,SAAS;AAAA,YACT,aAAa;AAAA,UACf;AAAA,QACF;AAAA,MACF;AAAA,MACA,YAAY;AAAA,QACV,MAAM;AAAA,QACN,UAAU,CAAC,OAAO;AAAA,QAClB,aAAa;AAAA,QACb,YAAY;AAAA,UACV,OAAO;AAAA,YACL,MAAM;AAAA,YACN,QAAQ,CAAC,cAAc,aAAa,aAAa,YAAY;AAAA,YAC7D,SAAS;AAAA,YACT,aAAa;AAAA,UACf;AAAA,QACF;AAAA,MACF;AAAA,MACA,qBAAqB;AAAA,QACnB,MAAM;AAAA,QACN,UAAU,CAAC,MAAM,MAAM;AAAA,QACvB,YAAY;AAAA,UACV,IAAI;AAAA,YACF,MAAM;AAAA,YACN,QAAQ;AAAA,YACR,aAAa;AAAA,UACf;AAAA,UACA,MAAM;AAAA,YACJ,MAAM;AAAA,YACN,aAAa;AAAA,UACf;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EACA,sCAAsC;AAAA,IACpC,SAAS;AAAA,IACT,IAAI;AAAA,IACJ,MAAM;AAAA,MACJ,MAAM;AAAA,QACJ,MAAM;AAAA,QACN,aAAa;AAAA,QACb,KAAK;AAAA,QACL,QAAQ;AAAA,UACN,MAAM;AAAA,UACN,UAAU,CAAC,MAAM;AAAA,UACjB,YAAY;AAAA,YACV,MAAM;AAAA,cACJ,MAAM;AAAA,cACN,QAAQ;AAAA,cACR,aACE;AAAA,YACJ;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EACA,kDAAkD;AAAA,IAChD,SAAS;AAAA,IACT,IAAI;AAAA,IACJ,MAAM;AAAA,MACJ,MAAM;AAAA,QACJ,MAAM;AAAA,QACN,aAAa;AAAA,QACb,YAAY;AAAA,UACV,MAAM;AAAA,UACN,YAAY,CAAC;AAAA,QACf;AAAA,QACA,QAAQ;AAAA,UACN,UAAU;AAAA,UACV,QAAQ;AAAA,YACN,MAAM;AAAA,YACN,UAAU,CAAC,eAAe;AAAA,YAC1B,YAAY;AAAA,cACV,eAAe;AAAA,gBACb,MAAM;AAAA,gBACN,OAAO;AAAA,kBACL,MAAM;AAAA,kBACN,KAAK;AAAA,gBACP;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EACA,+BAA+B;AAAA,IAC7B,SAAS;AAAA,IACT,IAAI;AAAA,IACJ,MAAM;AAAA,MACJ,MAAM;AAAA,QACJ,MAAM;AAAA,QACN,aAAa;AAAA,QACb,KAAK;AAAA,QACL,QAAQ;AAAA,UACN,MAAM;AAAA,UACN,UAAU;AAAA,YACR;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,YACA;AAAA,UACF;AAAA,UACA,YAAY;AAAA,YACV,aAAa;AAAA,cACX,MAAM;AAAA,cACN,aAAa;AAAA,cACb,WAAW;AAAA,cACX,WAAW;AAAA,YACb;AAAA,YACA,kBAAkB;AAAA,cAChB,MAAM;AAAA,cACN,aAAa;AAAA,cACb,WAAW;AAAA,cACX,WAAW;AAAA,YACb;AAAA,YACA,iBAAiB;AAAA,cACf,MAAM;AAAA,cACN,aACE;AAAA,cACF,WAAW;AAAA,cACX,WAAW;AAAA,YACb;AAAA,YACA,YAAY;AAAA,cACV,MAAM;AAAA,cACN,KAAK;AAAA,cACL,aAAa;AAAA,YACf;AAAA,YACA,MAAM;AAAA,cACJ,MAAM;AAAA,cACN,KAAK;AAAA,cACL,aAAa;AAAA,YACf;AAAA,YACA,YAAY;AAAA,cACV,MAAM;AAAA,cACN,aAAa;AAAA,cACb,OAAO;AAAA,gBACL,MAAM;AAAA,gBACN,MAAM;AAAA,kBACJ;AAAA,kBACA;AAAA,kBACA;AAAA,kBACA;AAAA,kBACA;AAAA,gBACF;AAAA,cACF;AAAA,YACF;AAAA,YACA,WAAW;AAAA,cACT,MAAM;AAAA,cACN,aAAa;AAAA,cACb,QAAQ;AAAA,YACV;AAAA,YACA,SAAS;AAAA,cACP,MAAM;AAAA,cACN,aAAa;AAAA,cACb,QAAQ;AAAA,YACV;AAAA,YACA,SAAS;AAAA,cACP,MAAM;AAAA,cACN,aACE;AAAA,YACJ;AAAA,YACA,YAAY;AAAA,cACV,MAAM;AAAA,cACN,aACE;AAAA,cACF,MAAM,CAAC,UAAU,QAAQ;AAAA,YAC3B;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EACA,wCAAwC;AAAA,IACtC,SAAS;AAAA,IACT,IAAI;AAAA,IACJ,MAAM;AAAA,MACJ,MAAM;AAAA,QACJ,MAAM;AAAA,QACN,aAAa;AAAA,QACb,KAAK;AAAA,QACL,QAAQ;AAAA,UACN,MAAM;AAAA,UACN,UAAU,CAAC,WAAW;AAAA,UACtB,YAAY;AAAA,YACV,WAAW;AAAA,cACT,MAAM;AAAA,cACN,QAAQ;AAAA,cACR,aACE;AAAA,YACJ;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EACA,+BAA+B;AAAA,IAC7B,SAAS;AAAA,IACT,IAAI;AAAA,IACJ,MAAM;AAAA,MACJ,MAAM;AAAA,QACJ,MAAM;AAAA,QACN,aAAa;AAAA,QACb,KAAK;AAAA,QACL,QAAQ;AAAA,UACN,MAAM;AAAA,UACN,UAAU,CAAC,QAAQ,OAAO,OAAO,QAAQ,WAAW;AAAA,UACpD,YAAY;AAAA,YACV,MAAM;AAAA,cACJ,MAAM;AAAA,cACN,aAAa;AAAA,YACf;AAAA,YACA,KAAK;AAAA,cACH,MAAM;AAAA,cACN,aAAa;AAAA,YACf;AAAA,YACA,KAAK;AAAA,cACH,MAAM;AAAA,cACN,aAAa;AAAA,YACf;AAAA,YACA,MAAM;AAAA,cACJ,MAAM;AAAA,cACN,aAAa;AAAA,YACf;AAAA,YACA,WAAW;AAAA,cACT,MAAM;AAAA,cACN,MAAM;AAAA,gBACJ;AAAA,gBACA;AAAA,cACF;AAAA,cACA,aACE;AAAA,YACJ;AAAA,YACA,OAAO;AAAA,cACL,MAAM;AAAA,cACN,MAAM;AAAA,gBACJ;AAAA,gBACA;AAAA,cACF;AAAA,cACA,aACE;AAAA,YACJ;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA,EACA,yBAAyB;AAAA,IACvB,SAAS;AAAA,IACT,IAAI;AAAA,IACJ,aAAa;AAAA,IACb,MAAM;AAAA,MACJ,MAAM;AAAA,QACJ,MAAM;AAAA,QACN,UAAU,CAAC,OAAO,KAAK;AAAA,QACvB,YAAY;AAAA,UACV,KAAK;AAAA,YACH,MAAM;AAAA,YACN,QAAQ;AAAA,UACV;AAAA,UACA,KAAK;AAAA,YACH,MAAM;AAAA,YACN,QAAQ;AAAA,UACV;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;AACO,IAAM,UAAU,OAAO,OAAO,UAAU;AACxC,IAAM,WAAqB,IAAI,SAAS,OAAO;AAc/C,SAAS,SACd,GACAC,MACA,MACA,cACkB;AAClB,UAAQ,eAAe,WAAW,aAAa,GAAGA,MAAI,IAAI,IACtD,SAAS,SAAS,GAAGA,IAAE,IAAI,IAAI,IAAI,CAAC,IACpC;AAAA,IACE,SAAS;AAAA,IACT,OAAO,IAAI;AAAA,MACT,2BAA2B,SAAS,SAASA,OAAK,GAAGA,IAAE,IAAI,IAAI,EAAE;AAAA,IACnE;AAAA,EACF;AACN;;;AE77BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA,IAAMC,YAAW;AAAjB,IACEC,YAAW;AACb,IAAM,KAAK;AAuBX,IAAM,WAAW;AAEV,SAAS,OAAU,GAAM;AAC9B,SAAOD,UAAS,GAAG,IAAI,QAAQ;AACjC;AAEO,SAAS,aAAgB,GAAM;AACpC,SAAOC,UAAmB,GAAG,IAAI,UAAU,IAAI;AACjD;;;AC1CA;AAAA;AAAA,gBAAAC;AAAA,EAAA,gBAAAA;AAAA,EAAA,oBAAAC;AAAA,EAAA,sBAAAA;AAAA;AAcA,IAAMC,YAAW;AAAjB,IACEC,YAAW;AACb,IAAMC,MAAK;AA+BX,IAAMC,YAAW;AAEV,SAASC,QAAU,GAAM;AAC9B,SAAOJ,UAAS,GAAGE,KAAIC,SAAQ;AACjC;AAEO,SAASE,cAAgB,GAAM;AACpC,SAAOJ,UAAmB,GAAGC,KAAIC,WAAU,IAAI;AACjD;;;ACvDA;AAAA;AAAA,gBAAAG;AAAA,EAAA,gBAAAA;AAAA,EAAA,oBAAAC;AAAA,EAAA,sBAAAA;AAAA;AAaA,IAAMC,YAAW;AAAjB,IACEC,YAAW;AACb,IAAMC,MAAK;AAoBX,IAAMC,YAAW;AAEV,SAASC,QAAU,GAAM;AAC9B,SAAOJ,UAAS,GAAGE,KAAIC,SAAQ;AACjC;AAEO,SAASE,cAAgB,GAAM;AACpC,SAAOJ,UAAmB,GAAGC,KAAIC,WAAU,IAAI;AACjD;;;AC3CA;AAAA;AAAA,gBAAAG;AAAA,EAAA,gBAAAA;AAAA,EAAA,oBAAAC;AAAA,EAAA,sBAAAA;AAAA;AAcA,IAAMC,YAAW;AAAjB,IACEC,YAAW;AACb,IAAMC,MAAK;AAoBX,IAAMC,YAAW;AAEV,SAASC,QAAU,GAAM;AAC9B,SAAOJ,UAAS,GAAGE,KAAIC,SAAQ;AACjC;AAEO,SAASE,cAAgB,GAAM;AACpC,SAAOJ,UAAmB,GAAGC,KAAIC,WAAU,IAAI;AACjD;;;AC5CA;AAAA;AAAA,gBAAAG;AAAA,EAAA,gBAAAA;AAAA,EAAA,oBAAAC;AAAA,EAAA,sBAAAA;AAAA;AAaA,IAAMC,YAAW;AAAjB,IACEC,YAAW;AACb,IAAMC,MAAK;AAmBX,IAAMC,YAAW;AAEV,SAASC,QAAU,GAAM;AAC9B,SAAOJ,UAAS,GAAGE,KAAIC,SAAQ;AACjC;AAEO,SAASE,cAAgB,GAAM;AACpC,SAAOJ,UAAmB,GAAGC,KAAIC,WAAU,IAAI;AACjD;;;AC1CA;AAAA;AAAA,gBAAAG;AAAA,EAAA,gBAAAA;AAAA,EAAA,oBAAAC;AAAA,EAAA,sBAAAA;AAAA;AAaA,IAAMC,YAAW;AAAjB,IACEC,YAAW;AACb,IAAMC,MAAK;AAoBX,IAAMC,YAAW;AAEV,SAASC,QAAU,GAAM;AAC9B,SAAOJ,UAAS,GAAGE,KAAIC,SAAQ;AACjC;AAEO,SAASE,cAAgB,GAAM;AACpC,SAAOJ,UAAmB,GAAGC,KAAIC,WAAU,IAAI;AACjD;;;AC3CA;AAAA;AAAA,gBAAAG;AAAA,EAAA,gBAAAA;AAAA,EAAA,oBAAAC;AAAA,EAAA,sBAAAA;AAAA;AAYA,IAAMC,YAAW;AAAjB,IACEC,YAAW;AACb,IAAMC,MAAK;AAeX,IAAMC,YAAW;AAEV,SAASC,QAAU,GAAM;AAC9B,SAAOJ,UAAS,GAAGE,KAAIC,SAAQ;AACjC;AAEO,SAASE,cAAgB,GAAM;AACpC,SAAOJ,UAAmB,GAAGC,KAAIC,WAAU,IAAI;AACjD;;;ACrCA;AAAA;AAAA;AAAA,gBAAAG;AAAA,EAAA,gBAAAA;AAAA,EAAA;AAAA,sBAAAC;AAAA,EAAA,sBAAAA;AAAA;AAUA,IAAMC,YAAW;AAAjB,IACEC,YAAW;AACb,IAAMC,MAAK;AAmBX,IAAMC,YAAW;AAEV,SAASC,QAAU,GAAM;AAC9B,SAAOJ,UAAS,GAAGE,KAAIC,SAAQ;AACjC;AAEO,SAASE,cAAgB,GAAM;AACpC,SAAOJ,UAAmB,GAAGC,KAAIC,WAAU,IAAI;AACjD;AAeA,IAAM,gBAAgB;AAEf,SAAS,YAAe,GAAM;AACnC,SAAOG,UAAS,GAAGC,KAAI,aAAa;AACtC;AAEO,SAAS,kBAAqB,GAAM;AACzC,SAAOC,UAAwB,GAAGD,KAAI,aAAa;AACrD;;;AC9DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA,IAAME,aAAW;AAAjB,IACEC,aAAW;AACb,IAAMC,MAAK;AASX,IAAM,UAAU;AAET,SAAS,MAAS,GAAM;AAC7B,SAAOF,WAAS,GAAGE,KAAI,OAAO;AAChC;AAEO,SAAS,YAAe,GAAM;AACnC,SAAOD,WAAkB,GAAGC,KAAI,OAAO;AACzC;AASA,IAAM,gBAAgB;AAEf,SAAS,YAAe,GAAM;AACnC,SAAOF,WAAS,GAAGE,KAAI,aAAa;AACtC;AAEO,SAAS,kBAAqB,GAAM;AACzC,SAAOD,WAAwB,GAAGC,KAAI,aAAa;AACrD;AASA,IAAM,gBAAgB;AAEf,SAAS,YAAe,GAAM;AACnC,SAAOF,WAAS,GAAGE,KAAI,aAAa;AACtC;AAEO,SAAS,kBAAqB,GAAM;AACzC,SAAOD,WAAwB,GAAGC,KAAI,aAAa;AACrD;AASA,IAAM,iBAAiB;AAEhB,SAAS,aAAgB,GAAM;AACpC,SAAOF,WAAS,GAAGE,KAAI,cAAc;AACvC;AAEO,SAAS,mBAAsB,GAAM;AAC1C,SAAOD,WAAyB,GAAGC,KAAI,cAAc;AACvD;AASA,IAAM,iBAAiB;AAEhB,SAAS,aAAgB,GAAM;AACpC,SAAOF,WAAS,GAAGE,KAAI,cAAc;AACvC;AAEO,SAAS,mBAAsB,GAAM;AAC1C,SAAOD,WAAyB,GAAGC,KAAI,cAAc;AACvD;;;AC/FA,IAAAC,gBAAA;AAAA,SAAAA,eAAA;AAAA;AAAA,qBAAAC;AAAA,EAAA,oBAAAC;AAAA,EAAA,mBAAAC;AAAA,EAAA,oBAAAC;AAAA,EAAA,aAAAC;AAAA,EAAA;AAAA,2BAAAC;AAAA,EAAA,0BAAAC;AAAA,EAAA,yBAAAC;AAAA,EAAA,0BAAAC;AAAA,EAAA,mBAAAC;AAAA;AAYA,IAAMC,aAAW;AAAjB,IACEC,aAAW;AACb,IAAMC,OAAK;AASX,IAAMC,WAAU;AAET,SAASC,OAAS,GAAM;AAC7B,SAAOJ,WAAS,GAAGE,MAAIC,QAAO;AAChC;AAEO,SAASE,aAAe,GAAM;AACnC,SAAOJ,WAAkB,GAAGC,MAAIC,QAAO;AACzC;AASA,IAAMG,iBAAgB;AAEf,SAASC,aAAe,GAAM;AACnC,SAAOP,WAAS,GAAGE,MAAII,cAAa;AACtC;AAEO,SAASE,mBAAqB,GAAM;AACzC,SAAOP,WAAwB,GAAGC,MAAII,cAAa;AACrD;AASA,IAAMG,iBAAgB;AAEf,SAASC,aAAe,GAAM;AACnC,SAAOV,WAAS,GAAGE,MAAIO,cAAa;AACtC;AAEO,SAASE,mBAAqB,GAAM;AACzC,SAAOV,WAAwB,GAAGC,MAAIO,cAAa;AACrD;AASA,IAAMG,kBAAiB;AAEhB,SAASC,cAAgB,GAAM;AACpC,SAAOb,WAAS,GAAGE,MAAIU,eAAc;AACvC;AAEO,SAASE,oBAAsB,GAAM;AAC1C,SAAOb,WAAyB,GAAGC,MAAIU,eAAc;AACvD;AASA,IAAMG,kBAAiB;AAEhB,SAASC,cAAgB,GAAM;AACpC,SAAOhB,WAAS,GAAGE,MAAIa,eAAc;AACvC;AAEO,SAASE,oBAAsB,GAAM;AAC1C,SAAOhB,WAAyB,GAAGC,MAAIa,eAAc;AACvD;AAUA,IAAM,0BAA0B;AAEzB,SAAS,sBAAyB,GAAM;AAC7C,SAAOf,WAAS,GAAGE,MAAI,uBAAuB;AAChD;AAEO,SAAS,4BAA+B,GAAM;AACnD,SAAOD,WAAkC,GAAGC,MAAI,uBAAuB;AACzE;;;ACrHA;AAAA;AAAA,gBAAAgB;AAAA,EAAA,gBAAAA;AAAA,EAAA,oBAAAC;AAAA,EAAA,sBAAAA;AAAA;AAYA,IAAMC,aAAW;AAAjB,IACEC,aAAW;AACb,IAAMC,OAAK;AASX,IAAMC,YAAW;AAEV,SAASC,QAAU,GAAM;AAC9B,SAAOJ,WAAS,GAAGE,MAAIC,SAAQ;AACjC;AAEO,SAASE,cAAgB,GAAM;AACpC,SAAOJ,WAAmB,GAAGC,MAAIC,WAAU,IAAI;AACjD;;;AC/BA;AAAA;AAAA;AAAA;AAoCO,SAAS,WAAW,GAAQ;AACjC,SAAO;AACT;;;ACtCA;AAAA;AAAA,gBAAAG;AAAA,EAAA,gBAAAA;AAAA,EAAA,oBAAAC;AAAA,EAAA,sBAAAA;AAAA;AAaA,IAAMC,aAAW;AAAjB,IACEC,aAAW;AACb,IAAMC,OAAK;AA+BX,IAAMC,aAAW;AAEV,SAASC,SAAU,GAAM;AAC9B,SAAOJ,WAAS,GAAGE,MAAIC,UAAQ;AACjC;AAEO,SAASE,eAAgB,GAAM;AACpC,SAAOJ,WAAmB,GAAGC,MAAIC,YAAU,IAAI;AACjD;;;ACtDA;AAAA;AAAA,gBAAAG;AAAA,EAAA,gBAAAA;AAAA,EAAA,oBAAAC;AAAA,EAAA,sBAAAA;AAAA;AAYA,IAAMC,aAAW;AAAjB,IACEC,aAAW;AACb,IAAMC,OAAK;AASX,IAAMC,aAAW;AAEV,SAASC,SAAU,GAAM;AAC9B,SAAOJ,WAAS,GAAGE,MAAIC,UAAQ;AACjC;AAEO,SAASE,eAAgB,GAAM;AACpC,SAAOJ,WAAmB,GAAGC,MAAIC,YAAU,IAAI;AACjD;;;AC/BA;AAAA;AAAA,gBAAAG;AAAA,EAAA,gBAAAA;AAAA,EAAA,oBAAAC;AAAA,EAAA,sBAAAA;AAAA;AAaA,IAAMC,aAAW;AAAjB,IACEC,aAAW;AACb,IAAMC,OAAK;AAuBX,IAAMC,aAAW;AAEV,SAASC,SAAU,GAAM;AAC9B,SAAOJ,WAAS,GAAGE,MAAIC,UAAQ;AACjC;AAEO,SAASE,eAAgB,GAAM;AACpC,SAAOJ,WAAmB,GAAGC,MAAIC,YAAU,IAAI;AACjD;;;AC9CA;AAAA;AAAA,gBAAAG;AAAA,EAAA,oBAAAC;AAAA;AAYA,IAAMC,aAAW;AAAjB,IACEC,aAAW;AACb,IAAMC,OAAK;AAQX,IAAMC,aAAW;AAEV,SAASC,SAAU,GAAM;AAC9B,SAAOJ,WAAS,GAAGE,MAAIC,UAAQ;AACjC;AAEO,SAASE,eAAgB,GAAM;AACpC,SAAOJ,WAAmB,GAAGC,MAAIC,UAAQ;AAC3C;;;AlB6BO,IAAM,gBAAN,cAA4B,uBAAW;AAAA,EAC5C;AAAA,EACA;AAAA,EACA;AAAA,EAEA,YAAY,SAA6C;AACvD,UAAM,SAAS,OAAO;AACtB,SAAK,MAAM,IAAI,MAAM,IAAI;AACzB,SAAK,MAAM,IAAI,MAAM,IAAI;AACzB,SAAK,MAAM,IAAI,MAAM,IAAI;AAAA,EAC3B;AAAA;AAAA,EAGA,IAAI,OAAmB;AACrB,WAAO;AAAA,EACT;AACF;AAEO,IAAM,QAAN,MAAY;AAAA,EACjB;AAAA,EACA;AAAA,EACA;AAAA,EAEA,YAAY,QAAoB;AAC9B,SAAK,UAAU;AACf,SAAK,YAAY,IAAI,eAAe,MAAM;AAC1C,SAAK,aAAa,IAAI,gBAAgB,MAAM;AAAA,EAC9C;AACF;AAEO,IAAM,iBAAN,MAAqB;AAAA,EAC1B;AAAA,EACA;AAAA,EAEA,YAAY,QAAoB;AAC9B,SAAK,UAAU;AACf,SAAK,WAAW,IAAI,2BAA2B,MAAM;AAAA,EACvD;AACF;AAEO,IAAM,6BAAN,MAAiC;AAAA,EACtC;AAAA,EAEA,YAAY,QAAoB;AAC9B,SAAK,UAAU;AAAA,EACjB;AAAA,EAEA,MAAM,KACJ,QAIC;AACD,UAAM,MAAM,MAAM,KAAK,QAAQ,KAAK,gCAAgC;AAAA,MAClE,YAAY;AAAA,MACZ,GAAG;AAAA,IACL,CAAC;AACD,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,IACJ,QAC2E;AAC3E,UAAM,MAAM,MAAM,KAAK,QAAQ,KAAK,8BAA8B;AAAA,MAChE,YAAY;AAAA,MACZ,GAAG;AAAA,IACL,CAAC;AACD,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,OACJ,QAIA,QACA,SACuC;AACvC,UAAM,aAAa;AACnB,UAAM,MAAM,MAAM,KAAK,QAAQ;AAAA,MAC7B;AAAA,MACA;AAAA,MACA,EAAE,YAAY,GAAG,QAAQ,QAAQ,EAAE,GAAG,QAAQ,OAAO,WAAW,EAAE;AAAA,MAClE,EAAE,UAAU,oBAAoB,QAAQ;AAAA,IAC1C;AACA,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,IACJ,QAIA,QACA,SACuC;AACvC,UAAM,aAAa;AACnB,UAAM,MAAM,MAAM,KAAK,QAAQ;AAAA,MAC7B;AAAA,MACA;AAAA,MACA,EAAE,YAAY,GAAG,QAAQ,QAAQ,EAAE,GAAG,QAAQ,OAAO,WAAW,EAAE;AAAA,MAClE,EAAE,UAAU,oBAAoB,QAAQ;AAAA,IAC1C;AACA,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,OACJ,QACA,SACe;AACf,UAAM,KAAK,QAAQ;AAAA,MACjB;AAAA,MACA;AAAA,MACA,EAAE,YAAY,0BAA0B,GAAG,OAAO;AAAA,MAClD,EAAE,QAAQ;AAAA,IACZ;AAAA,EACF;AACF;AAEO,IAAM,kBAAN,MAAsB;AAAA,EAC3B;AAAA,EACA;AAAA,EAEA,YAAY,QAAoB;AAC9B,SAAK,UAAU;AACf,SAAK,eAAe,IAAI,4BAA4B,MAAM;AAAA,EAC5D;AACF;AAEO,IAAM,8BAAN,MAAkC;AAAA,EACvC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEA,YAAY,QAAoB;AAC9B,SAAK,UAAU;AACf,SAAK,cAAc,IAAI,2CAA2C,MAAM;AACxE,SAAK,OAAO,IAAI,oCAAoC,MAAM;AAC1D,SAAK,gBAAgB,IAAI;AAAA,MACvB;AAAA,IACF;AACA,SAAK,OAAO,IAAI,oCAAoC,MAAM;AAAA,EAC5D;AAAA,EAEA,wBACE,QACA,MACoE;AACpE,WAAO,KAAK,QAAQ;AAAA,MAClB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACF;AAEO,IAAM,6CAAN,MAAiD;AAAA,EACtD;AAAA,EAEA,YAAY,QAAoB;AAC9B,SAAK,UAAU;AAAA,EACjB;AAAA,EAEA,MAAM,KACJ,QAOC;AACD,UAAM,MAAM,MAAM,KAAK,QAAQ,KAAK,gCAAgC;AAAA,MAClE,YAAY;AAAA,MACZ,GAAG;AAAA,IACL,CAAC;AACD,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,IACJ,QAKC;AACD,UAAM,MAAM,MAAM,KAAK,QAAQ,KAAK,8BAA8B;AAAA,MAChE,YAAY;AAAA,MACZ,GAAG;AAAA,IACL,CAAC;AACD,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,OACJ,QAIA,QACA,SACuC;AACvC,UAAM,aAAa;AACnB,UAAM,MAAM,MAAM,KAAK,QAAQ;AAAA,MAC7B;AAAA,MACA;AAAA,MACA;AAAA,QACE;AAAA,QACA,MAAM;AAAA,QACN,GAAG;AAAA,QACH,QAAQ,EAAE,GAAG,QAAQ,OAAO,WAAW;AAAA,MACzC;AAAA,MACA,EAAE,UAAU,oBAAoB,QAAQ;AAAA,IAC1C;AACA,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,IACJ,QAIA,QACA,SACuC;AACvC,UAAM,aAAa;AACnB,UAAM,MAAM,MAAM,KAAK,QAAQ;AAAA,MAC7B;AAAA,MACA;AAAA,MACA,EAAE,YAAY,GAAG,QAAQ,QAAQ,EAAE,GAAG,QAAQ,OAAO,WAAW,EAAE;AAAA,MAClE,EAAE,UAAU,oBAAoB,QAAQ;AAAA,IAC1C;AACA,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,OACJ,QACA,SACe;AACf,UAAM,KAAK,QAAQ;AAAA,MACjB;AAAA,MACA;AAAA,MACA,EAAE,YAAY,2CAA2C,GAAG,OAAO;AAAA,MACnE,EAAE,QAAQ;AAAA,IACZ;AAAA,EACF;AACF;AAEO,IAAM,sCAAN,MAA0C;AAAA,EAC/C;AAAA,EAEA,YAAY,QAAoB;AAC9B,SAAK,UAAU;AAAA,EACjB;AAAA,EAEA,MAAM,KACJ,QAIC;AACD,UAAM,MAAM,MAAM,KAAK,QAAQ,KAAK,gCAAgC;AAAA,MAClE,YAAY;AAAA,MACZ,GAAG;AAAA,IACL,CAAC;AACD,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,IACJ,QAKC;AACD,UAAM,MAAM,MAAM,KAAK,QAAQ,KAAK,8BAA8B;AAAA,MAChE,YAAY;AAAA,MACZ,GAAG;AAAA,IACL,CAAC;AACD,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,OACJ,QAIA,QACA,SACuC;AACvC,UAAM,aAAa;AACnB,UAAM,MAAM,MAAM,KAAK,QAAQ;AAAA,MAC7B;AAAA,MACA;AAAA,MACA;AAAA,QACE;AAAA,QACA,MAAM;AAAA,QACN,GAAG;AAAA,QACH,QAAQ,EAAE,GAAG,QAAQ,OAAO,WAAW;AAAA,MACzC;AAAA,MACA,EAAE,UAAU,oBAAoB,QAAQ;AAAA,IAC1C;AACA,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,IACJ,QAIA,QACA,SACuC;AACvC,UAAM,aAAa;AACnB,UAAM,MAAM,MAAM,KAAK,QAAQ;AAAA,MAC7B;AAAA,MACA;AAAA,MACA,EAAE,YAAY,GAAG,QAAQ,QAAQ,EAAE,GAAG,QAAQ,OAAO,WAAW,EAAE;AAAA,MAClE,EAAE,UAAU,oBAAoB,QAAQ;AAAA,IAC1C;AACA,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,OACJ,QACA,SACe;AACf,UAAM,KAAK,QAAQ;AAAA,MACjB;AAAA,MACA;AAAA,MACA,EAAE,YAAY,oCAAoC,GAAG,OAAO;AAAA,MAC5D,EAAE,QAAQ;AAAA,IACZ;AAAA,EACF;AACF;AAEO,IAAM,+CAAN,MAAmD;AAAA,EACxD;AAAA,EAEA,YAAY,QAAoB;AAC9B,SAAK,UAAU;AAAA,EACjB;AAAA,EAEA,MAAM,KACJ,QAOC;AACD,UAAM,MAAM,MAAM,KAAK,QAAQ,KAAK,gCAAgC;AAAA,MAClE,YAAY;AAAA,MACZ,GAAG;AAAA,IACL,CAAC;AACD,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,IACJ,QAKC;AACD,UAAM,MAAM,MAAM,KAAK,QAAQ,KAAK,8BAA8B;AAAA,MAChE,YAAY;AAAA,MACZ,GAAG;AAAA,IACL,CAAC;AACD,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,OACJ,QAIA,QACA,SACuC;AACvC,UAAM,aAAa;AACnB,UAAM,MAAM,MAAM,KAAK,QAAQ;AAAA,MAC7B;AAAA,MACA;AAAA,MACA;AAAA,QACE;AAAA,QACA,MAAM;AAAA,QACN,GAAG;AAAA,QACH,QAAQ,EAAE,GAAG,QAAQ,OAAO,WAAW;AAAA,MACzC;AAAA,MACA,EAAE,UAAU,oBAAoB,QAAQ;AAAA,IAC1C;AACA,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,IACJ,QAIA,QACA,SACuC;AACvC,UAAM,aAAa;AACnB,UAAM,MAAM,MAAM,KAAK,QAAQ;AAAA,MAC7B;AAAA,MACA;AAAA,MACA,EAAE,YAAY,GAAG,QAAQ,QAAQ,EAAE,GAAG,QAAQ,OAAO,WAAW,EAAE;AAAA,MAClE,EAAE,UAAU,oBAAoB,QAAQ;AAAA,IAC1C;AACA,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,OACJ,QACA,SACe;AACf,UAAM,KAAK,QAAQ;AAAA,MACjB;AAAA,MACA;AAAA,MACA,EAAE,YAAY,6CAA6C,GAAG,OAAO;AAAA,MACrE,EAAE,QAAQ;AAAA,IACZ;AAAA,EACF;AACF;AAEO,IAAM,sCAAN,MAA0C;AAAA,EAC/C;AAAA,EAEA,YAAY,QAAoB;AAC9B,SAAK,UAAU;AAAA,EACjB;AAAA,EAEA,MAAM,KACJ,QAIC;AACD,UAAM,MAAM,MAAM,KAAK,QAAQ,KAAK,gCAAgC;AAAA,MAClE,YAAY;AAAA,MACZ,GAAG;AAAA,IACL,CAAC;AACD,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,IACJ,QAKC;AACD,UAAM,MAAM,MAAM,KAAK,QAAQ,KAAK,8BAA8B;AAAA,MAChE,YAAY;AAAA,MACZ,GAAG;AAAA,IACL,CAAC;AACD,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,OACJ,QAIA,QACA,SACuC;AACvC,UAAM,aAAa;AACnB,UAAM,MAAM,MAAM,KAAK,QAAQ;AAAA,MAC7B;AAAA,MACA;AAAA,MACA,EAAE,YAAY,GAAG,QAAQ,QAAQ,EAAE,GAAG,QAAQ,OAAO,WAAW,EAAE;AAAA,MAClE,EAAE,UAAU,oBAAoB,QAAQ;AAAA,IAC1C;AACA,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,IACJ,QAIA,QACA,SACuC;AACvC,UAAM,aAAa;AACnB,UAAM,MAAM,MAAM,KAAK,QAAQ;AAAA,MAC7B;AAAA,MACA;AAAA,MACA,EAAE,YAAY,GAAG,QAAQ,QAAQ,EAAE,GAAG,QAAQ,OAAO,WAAW,EAAE;AAAA,MAClE,EAAE,UAAU,oBAAoB,QAAQ;AAAA,IAC1C;AACA,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,OACJ,QACA,SACe;AACf,UAAM,KAAK,QAAQ;AAAA,MACjB;AAAA,MACA;AAAA,MACA,EAAE,YAAY,oCAAoC,GAAG,OAAO;AAAA,MAC5D,EAAE,QAAQ;AAAA,IACZ;AAAA,EACF;AACF;AAEO,IAAM,QAAN,MAAY;AAAA,EACjB;AAAA,EACA;AAAA,EAEA,YAAY,QAAoB;AAC9B,SAAK,UAAU;AACf,SAAK,aAAa,IAAI,gBAAgB,MAAM;AAAA,EAC9C;AACF;AAEO,IAAM,kBAAN,MAAsB;AAAA,EAC3B;AAAA,EACA;AAAA,EACA;AAAA,EAEA,YAAY,QAAoB;AAC9B,SAAK,UAAU;AACf,SAAK,QAAQ,IAAI,qBAAqB,MAAM;AAC5C,SAAK,aAAa,IAAI,8BAA8B,MAAM;AAAA,EAC5D;AACF;AAEO,IAAM,uBAAN,MAA2B;AAAA,EAChC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEA,YAAY,QAAoB;AAC9B,SAAK,UAAU;AACf,SAAK,QAAQ,IAAI,8BAA8B,MAAM;AACrD,SAAK,eAAe,IAAI,qCAAqC,MAAM;AACnE,SAAK,aAAa,IAAI,mCAAmC,MAAM;AAC/D,SAAK,WAAW,IAAI,iCAAiC,MAAM;AAC3D,SAAK,cAAc,IAAI,oCAAoC,MAAM;AACjE,SAAK,SAAS,IAAI,+BAA+B,MAAM;AAAA,EACzD;AACF;AAEO,IAAM,gCAAN,MAAoC;AAAA,EACzC;AAAA,EAEA,YAAY,QAAoB;AAC9B,SAAK,UAAU;AAAA,EACjB;AAAA,EAEA,MAAM,KACJ,QAIC;AACD,UAAM,MAAM,MAAM,KAAK,QAAQ,KAAK,gCAAgC;AAAA,MAClE,YAAY;AAAA,MACZ,GAAG;AAAA,IACL,CAAC;AACD,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,IACJ,QAKC;AACD,UAAM,MAAM,MAAM,KAAK,QAAQ,KAAK,8BAA8B;AAAA,MAChE,YAAY;AAAA,MACZ,GAAG;AAAA,IACL,CAAC;AACD,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,OACJ,QAIA,QACA,SACuC;AACvC,UAAM,aAAa;AACnB,UAAM,MAAM,MAAM,KAAK,QAAQ;AAAA,MAC7B;AAAA,MACA;AAAA,MACA,EAAE,YAAY,GAAG,QAAQ,QAAQ,EAAE,GAAG,QAAQ,OAAO,WAAW,EAAE;AAAA,MAClE,EAAE,UAAU,oBAAoB,QAAQ;AAAA,IAC1C;AACA,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,IACJ,QAIA,QACA,SACuC;AACvC,UAAM,aAAa;AACnB,UAAM,MAAM,MAAM,KAAK,QAAQ;AAAA,MAC7B;AAAA,MACA;AAAA,MACA,EAAE,YAAY,GAAG,QAAQ,QAAQ,EAAE,GAAG,QAAQ,OAAO,WAAW,EAAE;AAAA,MAClE,EAAE,UAAU,oBAAoB,QAAQ;AAAA,IAC1C;AACA,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,OACJ,QACA,SACe;AACf,UAAM,KAAK,QAAQ;AAAA,MACjB;AAAA,MACA;AAAA,MACA,EAAE,YAAY,8BAA8B,GAAG,OAAO;AAAA,MACtD,EAAE,QAAQ;AAAA,IACZ;AAAA,EACF;AACF;AAEO,IAAM,uCAAN,MAA2C;AAAA,EAChD;AAAA,EAEA,YAAY,QAAoB;AAC9B,SAAK,UAAU;AAAA,EACjB;AAAA,EAEA,MAAM,KACJ,QAIC;AACD,UAAM,MAAM,MAAM,KAAK,QAAQ,KAAK,gCAAgC;AAAA,MAClE,YAAY;AAAA,MACZ,GAAG;AAAA,IACL,CAAC;AACD,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,IACJ,QAKC;AACD,UAAM,MAAM,MAAM,KAAK,QAAQ,KAAK,8BAA8B;AAAA,MAChE,YAAY;AAAA,MACZ,GAAG;AAAA,IACL,CAAC;AACD,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,OACJ,QAIA,QACA,SACuC;AACvC,UAAM,aAAa;AACnB,UAAM,MAAM,MAAM,KAAK,QAAQ;AAAA,MAC7B;AAAA,MACA;AAAA,MACA,EAAE,YAAY,GAAG,QAAQ,QAAQ,EAAE,GAAG,QAAQ,OAAO,WAAW,EAAE;AAAA,MAClE,EAAE,UAAU,oBAAoB,QAAQ;AAAA,IAC1C;AACA,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,IACJ,QAIA,QACA,SACuC;AACvC,UAAM,aAAa;AACnB,UAAM,MAAM,MAAM,KAAK,QAAQ;AAAA,MAC7B;AAAA,MACA;AAAA,MACA,EAAE,YAAY,GAAG,QAAQ,QAAQ,EAAE,GAAG,QAAQ,OAAO,WAAW,EAAE;AAAA,MAClE,EAAE,UAAU,oBAAoB,QAAQ;AAAA,IAC1C;AACA,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,OACJ,QACA,SACe;AACf,UAAM,KAAK,QAAQ;AAAA,MACjB;AAAA,MACA;AAAA,MACA,EAAE,YAAY,qCAAqC,GAAG,OAAO;AAAA,MAC7D,EAAE,QAAQ;AAAA,IACZ;AAAA,EACF;AACF;AAEO,IAAM,qCAAN,MAAyC;AAAA,EAC9C;AAAA,EAEA,YAAY,QAAoB;AAC9B,SAAK,UAAU;AAAA,EACjB;AAAA,EAEA,MAAM,KACJ,QAIC;AACD,UAAM,MAAM,MAAM,KAAK,QAAQ,KAAK,gCAAgC;AAAA,MAClE,YAAY;AAAA,MACZ,GAAG;AAAA,IACL,CAAC;AACD,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,IACJ,QAKC;AACD,UAAM,MAAM,MAAM,KAAK,QAAQ,KAAK,8BAA8B;AAAA,MAChE,YAAY;AAAA,MACZ,GAAG;AAAA,IACL,CAAC;AACD,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,OACJ,QAIA,QACA,SACuC;AACvC,UAAM,aAAa;AACnB,UAAM,MAAM,MAAM,KAAK,QAAQ;AAAA,MAC7B;AAAA,MACA;AAAA,MACA,EAAE,YAAY,GAAG,QAAQ,QAAQ,EAAE,GAAG,QAAQ,OAAO,WAAW,EAAE;AAAA,MAClE,EAAE,UAAU,oBAAoB,QAAQ;AAAA,IAC1C;AACA,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,IACJ,QAIA,QACA,SACuC;AACvC,UAAM,aAAa;AACnB,UAAM,MAAM,MAAM,KAAK,QAAQ;AAAA,MAC7B;AAAA,MACA;AAAA,MACA,EAAE,YAAY,GAAG,QAAQ,QAAQ,EAAE,GAAG,QAAQ,OAAO,WAAW,EAAE;AAAA,MAClE,EAAE,UAAU,oBAAoB,QAAQ;AAAA,IAC1C;AACA,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,OACJ,QACA,SACe;AACf,UAAM,KAAK,QAAQ;AAAA,MACjB;AAAA,MACA;AAAA,MACA,EAAE,YAAY,mCAAmC,GAAG,OAAO;AAAA,MAC3D,EAAE,QAAQ;AAAA,IACZ;AAAA,EACF;AACF;AAEO,IAAM,mCAAN,MAAuC;AAAA,EAC5C;AAAA,EAEA,YAAY,QAAoB;AAC9B,SAAK,UAAU;AAAA,EACjB;AAAA,EAEA,MAAM,KACJ,QAIC;AACD,UAAM,MAAM,MAAM,KAAK,QAAQ,KAAK,gCAAgC;AAAA,MAClE,YAAY;AAAA,MACZ,GAAG;AAAA,IACL,CAAC;AACD,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,IACJ,QAKC;AACD,UAAM,MAAM,MAAM,KAAK,QAAQ,KAAK,8BAA8B;AAAA,MAChE,YAAY;AAAA,MACZ,GAAG;AAAA,IACL,CAAC;AACD,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,OACJ,QAIA,QACA,SACuC;AACvC,UAAM,aAAa;AACnB,UAAM,MAAM,MAAM,KAAK,QAAQ;AAAA,MAC7B;AAAA,MACA;AAAA,MACA,EAAE,YAAY,GAAG,QAAQ,QAAQ,EAAE,GAAG,QAAQ,OAAO,WAAW,EAAE;AAAA,MAClE,EAAE,UAAU,oBAAoB,QAAQ;AAAA,IAC1C;AACA,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,IACJ,QAIA,QACA,SACuC;AACvC,UAAM,aAAa;AACnB,UAAM,MAAM,MAAM,KAAK,QAAQ;AAAA,MAC7B;AAAA,MACA;AAAA,MACA,EAAE,YAAY,GAAG,QAAQ,QAAQ,EAAE,GAAG,QAAQ,OAAO,WAAW,EAAE;AAAA,MAClE,EAAE,UAAU,oBAAoB,QAAQ;AAAA,IAC1C;AACA,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,OACJ,QACA,SACe;AACf,UAAM,KAAK,QAAQ;AAAA,MACjB;AAAA,MACA;AAAA,MACA,EAAE,YAAY,iCAAiC,GAAG,OAAO;AAAA,MACzD,EAAE,QAAQ;AAAA,IACZ;AAAA,EACF;AACF;AAEO,IAAM,sCAAN,MAA0C;AAAA,EAC/C;AAAA,EAEA,YAAY,QAAoB;AAC9B,SAAK,UAAU;AAAA,EACjB;AAAA,EAEA,MAAM,KACJ,QAIC;AACD,UAAM,MAAM,MAAM,KAAK,QAAQ,KAAK,gCAAgC;AAAA,MAClE,YAAY;AAAA,MACZ,GAAG;AAAA,IACL,CAAC;AACD,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,IACJ,QAKC;AACD,UAAM,MAAM,MAAM,KAAK,QAAQ,KAAK,8BAA8B;AAAA,MAChE,YAAY;AAAA,MACZ,GAAG;AAAA,IACL,CAAC;AACD,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,OACJ,QAIA,QACA,SACuC;AACvC,UAAM,aAAa;AACnB,UAAM,MAAM,MAAM,KAAK,QAAQ;AAAA,MAC7B;AAAA,MACA;AAAA,MACA,EAAE,YAAY,GAAG,QAAQ,QAAQ,EAAE,GAAG,QAAQ,OAAO,WAAW,EAAE;AAAA,MAClE,EAAE,UAAU,oBAAoB,QAAQ;AAAA,IAC1C;AACA,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,IACJ,QAIA,QACA,SACuC;AACvC,UAAM,aAAa;AACnB,UAAM,MAAM,MAAM,KAAK,QAAQ;AAAA,MAC7B;AAAA,MACA;AAAA,MACA,EAAE,YAAY,GAAG,QAAQ,QAAQ,EAAE,GAAG,QAAQ,OAAO,WAAW,EAAE;AAAA,MAClE,EAAE,UAAU,oBAAoB,QAAQ;AAAA,IAC1C;AACA,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,OACJ,QACA,SACe;AACf,UAAM,KAAK,QAAQ;AAAA,MACjB;AAAA,MACA;AAAA,MACA,EAAE,YAAY,oCAAoC,GAAG,OAAO;AAAA,MAC5D,EAAE,QAAQ;AAAA,IACZ;AAAA,EACF;AACF;AAEO,IAAM,iCAAN,MAAqC;AAAA,EAC1C;AAAA,EAEA,YAAY,QAAoB;AAC9B,SAAK,UAAU;AAAA,EACjB;AAAA,EAEA,MAAM,KACJ,QAIC;AACD,UAAM,MAAM,MAAM,KAAK,QAAQ,KAAK,gCAAgC;AAAA,MAClE,YAAY;AAAA,MACZ,GAAG;AAAA,IACL,CAAC;AACD,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,IACJ,QAKC;AACD,UAAM,MAAM,MAAM,KAAK,QAAQ,KAAK,8BAA8B;AAAA,MAChE,YAAY;AAAA,MACZ,GAAG;AAAA,IACL,CAAC;AACD,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,OACJ,QAIA,QACA,SACuC;AACvC,UAAM,aAAa;AACnB,UAAM,MAAM,MAAM,KAAK,QAAQ;AAAA,MAC7B;AAAA,MACA;AAAA,MACA,EAAE,YAAY,GAAG,QAAQ,QAAQ,EAAE,GAAG,QAAQ,OAAO,WAAW,EAAE;AAAA,MAClE,EAAE,UAAU,oBAAoB,QAAQ;AAAA,IAC1C;AACA,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,IACJ,QAIA,QACA,SACuC;AACvC,UAAM,aAAa;AACnB,UAAM,MAAM,MAAM,KAAK,QAAQ;AAAA,MAC7B;AAAA,MACA;AAAA,MACA,EAAE,YAAY,GAAG,QAAQ,QAAQ,EAAE,GAAG,QAAQ,OAAO,WAAW,EAAE;AAAA,MAClE,EAAE,UAAU,oBAAoB,QAAQ;AAAA,IAC1C;AACA,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,OACJ,QACA,SACe;AACf,UAAM,KAAK,QAAQ;AAAA,MACjB;AAAA,MACA;AAAA,MACA,EAAE,YAAY,+BAA+B,GAAG,OAAO;AAAA,MACvD,EAAE,QAAQ;AAAA,IACZ;AAAA,EACF;AACF;AAEO,IAAM,gCAAN,MAAoC;AAAA,EACzC;AAAA,EAEA,YAAY,QAAoB;AAC9B,SAAK,UAAU;AAAA,EACjB;AAAA,EAEA,MAAM,KACJ,QAIC;AACD,UAAM,MAAM,MAAM,KAAK,QAAQ,KAAK,gCAAgC;AAAA,MAClE,YAAY;AAAA,MACZ,GAAG;AAAA,IACL,CAAC;AACD,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,IACJ,QAKC;AACD,UAAM,MAAM,MAAM,KAAK,QAAQ,KAAK,8BAA8B;AAAA,MAChE,YAAY;AAAA,MACZ,GAAG;AAAA,IACL,CAAC;AACD,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,OACJ,QAIA,QACA,SACuC;AACvC,UAAM,aAAa;AACnB,UAAM,MAAM,MAAM,KAAK,QAAQ;AAAA,MAC7B;AAAA,MACA;AAAA,MACA,EAAE,YAAY,GAAG,QAAQ,QAAQ,EAAE,GAAG,QAAQ,OAAO,WAAW,EAAE;AAAA,MAClE,EAAE,UAAU,oBAAoB,QAAQ;AAAA,IAC1C;AACA,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,IACJ,QAIA,QACA,SACuC;AACvC,UAAM,aAAa;AACnB,UAAM,MAAM,MAAM,KAAK,QAAQ;AAAA,MAC7B;AAAA,MACA;AAAA,MACA,EAAE,YAAY,GAAG,QAAQ,QAAQ,EAAE,GAAG,QAAQ,OAAO,WAAW,EAAE;AAAA,MAClE,EAAE,UAAU,oBAAoB,QAAQ;AAAA,IAC1C;AACA,WAAO,IAAI;AAAA,EACb;AAAA,EAEA,MAAM,OACJ,QACA,SACe;AACf,UAAM,KAAK,QAAQ;AAAA,MACjB;AAAA,MACA;AAAA,MACA,EAAE,YAAY,6BAA6B,GAAG,OAAO;AAAA,MACrD,EAAE,QAAQ;AAAA,IACZ;AAAA,EACF;AACF;AAEO,IAAM,QAAN,MAAY;AAAA,EACjB;AAAA,EACA;AAAA,EAEA,YAAY,QAAoB;AAC9B,SAAK,UAAU;AACf,SAAK,UAAU,IAAI,aAAa,MAAM;AAAA,EACxC;AACF;AAEO,IAAM,eAAN,MAAmB;AAAA,EACxB;AAAA,EACA;AAAA,EAEA,YAAY,QAAoB;AAC9B,SAAK,UAAU;AACf,SAAK,OAAO,IAAI,iBAAiB,MAAM;AAAA,EACzC;AACF;AAEO,IAAM,mBAAN,MAAuB;AAAA,EAC5B;AAAA,EAEA,YAAY,QAAoB;AAC9B,SAAK,UAAU;AAAA,EACjB;AACF;","names":["ResponseType","fetch","XrpcClient","id","id","is$typed","validate","isMain","validateMain","is$typed","validate","id","hashMain","isMain","validateMain","isMain","validateMain","is$typed","validate","id","hashMain","isMain","validateMain","isMain","validateMain","is$typed","validate","id","hashMain","isMain","validateMain","isMain","validateMain","is$typed","validate","id","hashMain","isMain","validateMain","isMain","validateMain","is$typed","validate","id","hashMain","isMain","validateMain","isMain","validateMain","is$typed","validate","id","hashMain","isMain","validateMain","isMain","validateMain","is$typed","validate","id","hashMain","isMain","validateMain","is$typed","id","validate","is$typed","validate","id","defs_exports","isLargeBlob","isLargeImage","isSmallBlob","isSmallImage","isUri","validateLargeBlob","validateLargeImage","validateSmallBlob","validateSmallImage","validateUri","is$typed","validate","id","hashUri","isUri","validateUri","hashSmallBlob","isSmallBlob","validateSmallBlob","hashLargeBlob","isLargeBlob","validateLargeBlob","hashSmallImage","isSmallImage","validateSmallImage","hashLargeImage","isLargeImage","validateLargeImage","isMain","validateMain","is$typed","validate","id","hashMain","isMain","validateMain","isMain","validateMain","is$typed","validate","id","hashMain","isMain","validateMain","isMain","validateMain","is$typed","validate","id","hashMain","isMain","validateMain","isMain","validateMain","is$typed","validate","id","hashMain","isMain","validateMain","isMain","validateMain","is$typed","validate","id","hashMain","isMain","validateMain"]}