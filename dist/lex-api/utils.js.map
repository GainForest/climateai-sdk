{"version":3,"sources":["../../lex-api/util.ts"],"names":[],"mappings":";AAiBA,SAAS,SAAY,CAAA,EAAuB;AAC1C,EAAA,OAAO,CAAA,IAAK,IAAA,IAAQ,OAAO,CAAA,KAAM,QAAA;AACnC;AAEA,SAAS,OAAA,CACP,KAAA,EACA,EAAA,EACA,IAAA,EAC0B;AAC1B,EAAA,OAAO,IAAA,KAAS,SACZ,KAAA,KAAU,EAAA;AAAA;AAAA,IAEV,OAAO,UAAU,QAAA,IACf,KAAA,CAAM,WAAW,EAAA,CAAG,MAAA,GAAS,CAAA,GAAI,IAAA,CAAK,MAAA,IACtC,KAAA,CAAM,WAAW,EAAA,CAAG,MAAM,MAAM,EAAA,IAChC,KAAA,CAAM,WAAW,EAAE,CAAA,IACnB,KAAA,CAAM,QAAA,CAAS,IAAI;AAAA,GAAA;AAC3B;AAgBO,SAAS,QAAA,CACd,CAAA,EACA,EAAA,EACA,IAAA,EACgC;AAChC,EAAA,OAAO,QAAA,CAAS,CAAC,CAAA,IAAK,OAAA,IAAW,KAAK,OAAA,CAAQ,CAAA,CAAE,KAAA,EAAO,EAAA,EAAI,IAAI,CAAA;AACjE;AAEO,SAAS,WAAA,CACd,CAAA,EACA,EAAA,EACA,IAAA,EAC+C;AAC/C,EAAA,OACE,QAAA,CAAS,CAAC,CAAA,KACT,OAAA,IAAW,CAAA,GAAI,CAAA,CAAE,KAAA,KAAU,MAAA,IAAa,OAAA,CAAQ,CAAA,CAAE,KAAA,EAAO,EAAA,EAAI,IAAI,CAAA,GAAI,IAAA,CAAA;AAE1E;AAUO,SAAS,YAAiC,QAAA,EAAa;AAC5D,EAAA,OAAO,SAAa,CAAA,EAAkC;AACpD,IAAA,OAAO,QAAA,CAAS,CAAC,CAAA,CAAE,OAAA;AAAA,EACrB,CAAA;AACF","file":"utils.js","sourcesContent":["/**\n * GENERATED CODE - DO NOT MODIFY\n */\n\nimport { type ValidationResult } from '@atproto/lexicon'\n\nexport type OmitKey<T, K extends keyof T> = {\n  [K2 in keyof T as K2 extends K ? never : K2]: T[K2]\n}\n\nexport type $Typed<V, T extends string = string> = V & { $type: T }\nexport type Un$Typed<V extends { $type?: string }> = OmitKey<V, '$type'>\n\nexport type $Type<Id extends string, Hash extends string> = Hash extends 'main'\n  ? Id\n  : `${Id}#${Hash}`\n\nfunction isObject<V>(v: V): v is V & object {\n  return v != null && typeof v === 'object'\n}\n\nfunction is$type<Id extends string, Hash extends string>(\n  $type: unknown,\n  id: Id,\n  hash: Hash,\n): $type is $Type<Id, Hash> {\n  return hash === 'main'\n    ? $type === id\n    : // $type === `${id}#${hash}`\n      typeof $type === 'string' &&\n        $type.length === id.length + 1 + hash.length &&\n        $type.charCodeAt(id.length) === 35 /* '#' */ &&\n        $type.startsWith(id) &&\n        $type.endsWith(hash)\n}\n\nexport type $TypedObject<\n  V,\n  Id extends string,\n  Hash extends string,\n> = V extends {\n  $type: $Type<Id, Hash>\n}\n  ? V\n  : V extends { $type?: string }\n    ? V extends { $type?: infer T extends $Type<Id, Hash> }\n      ? V & { $type: T }\n      : never\n    : V & { $type: $Type<Id, Hash> }\n\nexport function is$typed<V, Id extends string, Hash extends string>(\n  v: V,\n  id: Id,\n  hash: Hash,\n): v is $TypedObject<V, Id, Hash> {\n  return isObject(v) && '$type' in v && is$type(v.$type, id, hash)\n}\n\nexport function maybe$typed<V, Id extends string, Hash extends string>(\n  v: V,\n  id: Id,\n  hash: Hash,\n): v is V & object & { $type?: $Type<Id, Hash> } {\n  return (\n    isObject(v) &&\n    ('$type' in v ? v.$type === undefined || is$type(v.$type, id, hash) : true)\n  )\n}\n\nexport type Validator<R = unknown> = (v: unknown) => ValidationResult<R>\nexport type ValidatorParam<V extends Validator> =\n  V extends Validator<infer R> ? R : never\n\n/**\n * Utility function that allows to convert a \"validate*\" utility function into a\n * type predicate.\n */\nexport function asPredicate<V extends Validator>(validate: V) {\n  return function <T>(v: T): v is T & ValidatorParam<V> {\n    return validate(v).success\n  }\n}\n"]}