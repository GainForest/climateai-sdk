{"version":3,"sources":["../../lex-api/util.ts"],"sourcesContent":["/**\n * GENERATED CODE - DO NOT MODIFY\n */\n\nimport { type ValidationResult } from '@atproto/lexicon'\n\nexport type OmitKey<T, K extends keyof T> = {\n  [K2 in keyof T as K2 extends K ? never : K2]: T[K2]\n}\n\nexport type $Typed<V, T extends string = string> = V & { $type: T }\nexport type Un$Typed<V extends { $type?: string }> = OmitKey<V, '$type'>\n\nexport type $Type<Id extends string, Hash extends string> = Hash extends 'main'\n  ? Id\n  : `${Id}#${Hash}`\n\nfunction isObject<V>(v: V): v is V & object {\n  return v != null && typeof v === 'object'\n}\n\nfunction is$type<Id extends string, Hash extends string>(\n  $type: unknown,\n  id: Id,\n  hash: Hash,\n): $type is $Type<Id, Hash> {\n  return hash === 'main'\n    ? $type === id\n    : // $type === `${id}#${hash}`\n      typeof $type === 'string' &&\n        $type.length === id.length + 1 + hash.length &&\n        $type.charCodeAt(id.length) === 35 /* '#' */ &&\n        $type.startsWith(id) &&\n        $type.endsWith(hash)\n}\n\nexport type $TypedObject<\n  V,\n  Id extends string,\n  Hash extends string,\n> = V extends {\n  $type: $Type<Id, Hash>\n}\n  ? V\n  : V extends { $type?: string }\n    ? V extends { $type?: infer T extends $Type<Id, Hash> }\n      ? V & { $type: T }\n      : never\n    : V & { $type: $Type<Id, Hash> }\n\nexport function is$typed<V, Id extends string, Hash extends string>(\n  v: V,\n  id: Id,\n  hash: Hash,\n): v is $TypedObject<V, Id, Hash> {\n  return isObject(v) && '$type' in v && is$type(v.$type, id, hash)\n}\n\nexport function maybe$typed<V, Id extends string, Hash extends string>(\n  v: V,\n  id: Id,\n  hash: Hash,\n): v is V & object & { $type?: $Type<Id, Hash> } {\n  return (\n    isObject(v) &&\n    ('$type' in v ? v.$type === undefined || is$type(v.$type, id, hash) : true)\n  )\n}\n\nexport type Validator<R = unknown> = (v: unknown) => ValidationResult<R>\nexport type ValidatorParam<V extends Validator> =\n  V extends Validator<infer R> ? R : never\n\n/**\n * Utility function that allows to convert a \"validate*\" utility function into a\n * type predicate.\n */\nexport function asPredicate<V extends Validator>(validate: V) {\n  return function <T>(v: T): v is T & ValidatorParam<V> {\n    return validate(v).success\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAiBA,SAAS,SAAY,GAAuB;AAC1C,SAAO,KAAK,QAAQ,OAAO,MAAM;AACnC;AAEA,SAAS,QACP,OACA,IACA,MAC0B;AAC1B,SAAO,SAAS,SACZ,UAAU;AAAA;AAAA,IAEV,OAAO,UAAU,YACf,MAAM,WAAW,GAAG,SAAS,IAAI,KAAK,UACtC,MAAM,WAAW,GAAG,MAAM,MAAM,MAChC,MAAM,WAAW,EAAE,KACnB,MAAM,SAAS,IAAI;AAAA;AAC3B;AAgBO,SAAS,SACd,GACA,IACA,MACgC;AAChC,SAAO,SAAS,CAAC,KAAK,WAAW,KAAK,QAAQ,EAAE,OAAO,IAAI,IAAI;AACjE;AAEO,SAAS,YACd,GACA,IACA,MAC+C;AAC/C,SACE,SAAS,CAAC,MACT,WAAW,IAAI,EAAE,UAAU,UAAa,QAAQ,EAAE,OAAO,IAAI,IAAI,IAAI;AAE1E;AAUO,SAAS,YAAiC,UAAa;AAC5D,SAAO,SAAa,GAAkC;AACpD,WAAO,SAAS,CAAC,EAAE;AAAA,EACrB;AACF;","names":[]}