{"version":3,"sources":["../../../src/utilities/transformer.ts","../../../src/zod-schemas/blobref.ts","../../../src/lib/isObject.ts"],"sourcesContent":["// utils/transformer.ts\nimport type { DataTransformer } from \"@trpc/server\";\nimport superjson, { type SuperJSONResult } from \"superjson\";\nimport { type BlobRefGenerator, toBlobRef } from \"@/zod-schemas/blobref\";\nimport { BlobRef } from \"@atproto/api\";\nimport { isObject } from \"@/lib/isObject\";\n\ntype ReplaceType<T, U, V> =\n  // If T directly extends U, substitute to V\n  T extends U\n    ? V\n    : // If T is an array, recursively apply ReplaceType on the element type\n    T extends (infer Item)[]\n    ? ReplaceType<Item, U, V>[]\n    : // If T is an object, recursively apply ReplaceType on all properties\n    T extends object\n    ? { [K in keyof T]: ReplaceType<T[K], U, V> }\n    : // Otherwise, keep original type\n      T;\n\ntype Serialize<T> = ReplaceType<T, BlobRef, BlobRefGenerator>;\n\nconst _serialize = <T>(data: T): Serialize<T> => {\n  return JSON.parse(JSON.stringify(data)) as Serialize<T>;\n};\n\nconst _deserialize = <T>(data: Serialize<T>): T => {\n  const isObj = isObject(data);\n  if (!isObj) {\n    if (Array.isArray(data)) {\n      return data.map(_deserialize) as T;\n    }\n    return data as T;\n  }\n  if (\"$type\" in data && data.$type === \"blob\" && \"ref\" in data) {\n    try {\n      return toBlobRef(data as unknown as BlobRefGenerator) as T;\n    } catch {\n      return data as T;\n    }\n  }\n\n  const obj = data as Record<string, unknown>;\n  return Object.fromEntries(\n    Object.entries(obj).map(([key, value]) => [key, _deserialize(value)])\n  ) as T;\n};\n\nexport const customTransformer: DataTransformer = {\n  serialize: (object) => {\n    // typeof object = object\n    // This logic runs for transforming the query or mutation parameters before they are sent to the server.\n    // Conversion of object to string is automatically handled by TRPC.\n    const atprotoSerialized = _serialize(object);\n    const serializedObject = superjson.serialize(atprotoSerialized);\n    return serializedObject;\n  },\n  deserialize: <T>(object: SuperJSONResult): T => {\n    // typeof object = { json: object }\n    // This logic runs for transforming the query or mutation response before it is received by the client.\n    // The received response is automatically converted from stringified JSON to object by TRPC.\n    const superjsonDeserialized = superjson.deserialize(object) as Serialize<T>;\n    const deserializedObject = _deserialize(superjsonDeserialized);\n    // console.log(\"deserialized object\", deserializedObject);\n    return deserializedObject as T;\n  },\n};\n\nexport type SerializedSuperjson<T> = Omit<SuperJSONResult, \"json\"> & {\n  json: Serialize<T>;\n};\n\nexport const serialize = <T>(data: T) => {\n  const result = customTransformer.serialize(data);\n  return result as SerializedSuperjson<T>;\n};\n\nexport const deserialize = <T>(object: SerializedSuperjson<T>): T => {\n  return customTransformer.deserialize(object);\n};\n","import z from \"zod\";\nimport { CID } from \"multiformats/cid\";\nimport type { Version } from \"multiformats/cid\";\nimport { BlobRef } from \"@atproto/lexicon\";\n\nexport const BlobRefGeneratorSchema = z.object({\n  $type: z.literal(\"blob-ref-generator\"),\n  ref: z.object({\n    $link: z.string(),\n  }),\n  mimeType: z.string(),\n  size: z.number(),\n});\n\nexport type BlobRefGenerator = z.infer<typeof BlobRefGeneratorSchema>;\n\nexport const toBlobRef = (input: BlobRefGenerator) => {\n  const validCID: CID<unknown, number, number, Version> = CID.parse(\n    input.ref.$link\n  );\n  return BlobRef.fromJsonRef({\n    $type: \"blob\",\n    ref: validCID,\n    mimeType: input.mimeType,\n    size: input.size,\n  });\n};\n\nexport const toBlobRefGenerator = (blobRef: BlobRef): BlobRefGenerator => {\n  const json = blobRef.toJSON();\n  return {\n    $type: \"blob-ref-generator\",\n    ref: json.ref,\n    mimeType: json.mimeType,\n    size: json.size,\n  };\n};\n","export const isObject = (value: unknown): value is object => {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    !Array.isArray(value) &&\n    !(value instanceof RegExp) &&\n    !(value instanceof Date) &&\n    !(value instanceof Set) &&\n    !(value instanceof Map)\n  );\n};\n"],"mappings":";AAEA,OAAO,eAAyC;;;ACFhD,OAAO,OAAO;AACd,SAAS,WAAW;AAEpB,SAAS,eAAe;AAEjB,IAAM,yBAAyB,EAAE,OAAO;AAAA,EAC7C,OAAO,EAAE,QAAQ,oBAAoB;AAAA,EACrC,KAAK,EAAE,OAAO;AAAA,IACZ,OAAO,EAAE,OAAO;AAAA,EAClB,CAAC;AAAA,EACD,UAAU,EAAE,OAAO;AAAA,EACnB,MAAM,EAAE,OAAO;AACjB,CAAC;AAIM,IAAM,YAAY,CAAC,UAA4B;AACpD,QAAM,WAAkD,IAAI;AAAA,IAC1D,MAAM,IAAI;AAAA,EACZ;AACA,SAAO,QAAQ,YAAY;AAAA,IACzB,OAAO;AAAA,IACP,KAAK;AAAA,IACL,UAAU,MAAM;AAAA,IAChB,MAAM,MAAM;AAAA,EACd,CAAC;AACH;;;AC1BO,IAAM,WAAW,CAAC,UAAoC;AAC3D,SACE,OAAO,UAAU,YACjB,UAAU,QACV,CAAC,MAAM,QAAQ,KAAK,KACpB,EAAE,iBAAiB,WACnB,EAAE,iBAAiB,SACnB,EAAE,iBAAiB,QACnB,EAAE,iBAAiB;AAEvB;;;AFYA,IAAM,aAAa,CAAI,SAA0B;AAC/C,SAAO,KAAK,MAAM,KAAK,UAAU,IAAI,CAAC;AACxC;AAEA,IAAM,eAAe,CAAI,SAA0B;AACjD,QAAM,QAAQ,SAAS,IAAI;AAC3B,MAAI,CAAC,OAAO;AACV,QAAI,MAAM,QAAQ,IAAI,GAAG;AACvB,aAAO,KAAK,IAAI,YAAY;AAAA,IAC9B;AACA,WAAO;AAAA,EACT;AACA,MAAI,WAAW,QAAQ,KAAK,UAAU,UAAU,SAAS,MAAM;AAC7D,QAAI;AACF,aAAO,UAAU,IAAmC;AAAA,IACtD,QAAQ;AACN,aAAO;AAAA,IACT;AAAA,EACF;AAEA,QAAM,MAAM;AACZ,SAAO,OAAO;AAAA,IACZ,OAAO,QAAQ,GAAG,EAAE,IAAI,CAAC,CAAC,KAAK,KAAK,MAAM,CAAC,KAAK,aAAa,KAAK,CAAC,CAAC;AAAA,EACtE;AACF;AAEO,IAAM,oBAAqC;AAAA,EAChD,WAAW,CAAC,WAAW;AAIrB,UAAM,oBAAoB,WAAW,MAAM;AAC3C,UAAM,mBAAmB,UAAU,UAAU,iBAAiB;AAC9D,WAAO;AAAA,EACT;AAAA,EACA,aAAa,CAAI,WAA+B;AAI9C,UAAM,wBAAwB,UAAU,YAAY,MAAM;AAC1D,UAAM,qBAAqB,aAAa,qBAAqB;AAE7D,WAAO;AAAA,EACT;AACF;AAMO,IAAM,YAAY,CAAI,SAAY;AACvC,QAAM,SAAS,kBAAkB,UAAU,IAAI;AAC/C,SAAO;AACT;AAEO,IAAM,cAAc,CAAI,WAAsC;AACnE,SAAO,kBAAkB,YAAY,MAAM;AAC7C;","names":[]}