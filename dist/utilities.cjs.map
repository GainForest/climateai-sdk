{"version":3,"sources":["../src/_internal/utilities/atproto/getBlobUrl.ts","../src/_internal/utilities/atproto/parseAtUri.ts","../src/_internal/server/utils/claims.ts","../src/_internal/zod-schemas/blobref.ts","../src/_internal/lib/isObject.ts","../src/_internal/utilities/transform/index.ts","../src/_internal/lib/geojson/computations.ts","../src/_internal/lib/geojson/validate.ts"],"names":["BlobRef","z","CID","superjson","geometry","featureCollection","centerOfMass","turfCentroid","centroidPosition","bbox","turfBbox","centroid","turfLength","areaSqMeters","turfArea"],"mappings":"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","file":"utilities.cjs","sourcesContent":["import {\n  type Uri as GFUri,\n  type Image as GFImage,\n  type ImageThumbnail as GFImageThumbnail,\n} from \"@/../lex-api/types/app/gainforest/common/defs\";\nimport {\n  type LargeBlob,\n  type LargeImage,\n  type SmallBlob,\n  type SmallImage,\n  type Uri,\n} from \"@/../lex-api/types/org/hypercerts/defs\";\nimport type { $Typed } from \"@/../lex-api/util\";\nimport type { BlobRefGenerator } from \"@/_internal/zod-schemas/blobref\";\nimport { BlobRef } from \"@atproto/api\";\nimport { SupportedPDSDomain } from \"../..\";\n\ntype SupportedImageData =\n  | string\n  | BlobRef\n  | BlobRefGenerator\n  // org.hypercerts.defs types\n  | $Typed<Uri | SmallImage | LargeImage | SmallBlob | LargeBlob>\n  | Uri\n  | SmallImage\n  | LargeImage\n  | SmallBlob\n  | LargeBlob\n  // app.gainforest.common.defs types\n  | $Typed<GFUri | GFImage | GFImageThumbnail>\n  | GFUri\n  | GFImage\n  | GFImageThumbnail;\n\nconst getBlobUrl = <T extends SupportedPDSDomain>(\n  did: string,\n  imageData: SupportedImageData,\n  pdsDomain: T\n) => {\n  if (typeof imageData === \"string\") {\n    const imageUrl = new URL(imageData);\n    return imageUrl.toString();\n  }\n\n  const isBlobRef =\n    imageData instanceof BlobRef ||\n    (\"ref\" in imageData && \"mimeType\" in imageData && \"size\" in imageData);\n  if (isBlobRef) {\n    const ref = imageData.ref as unknown as { $link?: string } | string;\n    const cid = typeof ref === \"string\" ? ref : (ref?.$link ?? String(ref));\n    const encodedCid = encodeURIComponent(cid);\n    return `https://${pdsDomain}/xrpc/com.atproto.sync.getBlob?did=${did}&cid=${encodedCid}`;\n  }\n\n  // Handle $Typed cases - URI types\n  if (\n    imageData.$type === \"app.gainforest.common.defs#uri\" ||\n    imageData.$type === \"org.hypercerts.defs#uri\"\n  ) {\n    return imageData.uri;\n  }\n\n  // Handle org.hypercerts.defs blob types\n  if (\n    imageData.$type === \"org.hypercerts.defs#smallBlob\" ||\n    imageData.$type === \"org.hypercerts.defs#largeBlob\"\n  ) {\n    return getBlobUrl(did, imageData.blob, pdsDomain);\n  }\n\n  // Handle org.hypercerts.defs image types (use 'image' property)\n  if (\n    imageData.$type === \"org.hypercerts.defs#smallImage\" ||\n    imageData.$type === \"org.hypercerts.defs#largeImage\"\n  ) {\n    return getBlobUrl(did, imageData.image, pdsDomain);\n  }\n\n  // Handle app.gainforest.common.defs image types (use 'file' property)\n  if (\n    imageData.$type === \"app.gainforest.common.defs#image\" ||\n    imageData.$type === \"app.gainforest.common.defs#imageThumbnail\"\n  ) {\n    return getBlobUrl(did, imageData.file, pdsDomain);\n  }\n\n  // Fallback for untyped objects - check by property presence\n  if (\"blob\" in imageData) {\n    return getBlobUrl(did, imageData.blob, pdsDomain);\n  }\n\n  if (\"image\" in imageData) {\n    return getBlobUrl(did, imageData.image, pdsDomain);\n  }\n\n  if (\"file\" in imageData) {\n    return getBlobUrl(did, imageData.file, pdsDomain);\n  }\n\n  if (\"uri\" in imageData) {\n    return imageData.uri;\n  }\n\n  // Line for compile time check that all cases are handled. THIS SHOULD NEVER BE REACHED.\n  const imageDataTypeCheck = imageData satisfies never;\n  return imageDataTypeCheck;\n};\n\nexport { getBlobUrl };\n","const parseAtUri = (atUri: string) => {\n  let cleanedAtUri = atUri.replace(\"at://\", \"\");\n\n  const splitUri = cleanedAtUri.split(\"/\");\n\n  const did = splitUri.at(0) ?? \"\";\n  const collection = splitUri.at(1) ?? \"\";\n  const rkey = splitUri.at(2) ?? \"self\";\n\n  return { did, collection, rkey };\n};\n\nexport { parseAtUri };\n","import type { Ecocert } from \"@/_internal/types/Ecocert\";\nimport type { OrganizationWithActivities as OrganizationWithActivitiesType } from \"@/_internal/server/routers/atproto/hypercerts/claim/activity/getAllAcrossOrgs\";\nimport { getBlobUrl } from \"@/_internal/utilities/atproto\";\nimport type { SupportedPDSDomain } from \"@/_internal/index\";\n\nexport const getEcocertsFromClaimActivities = (\n  activitiesWithOrgInfo: OrganizationWithActivitiesType[],\n  pdsDomain: SupportedPDSDomain\n): Ecocert[] => {\n  const ecocerts: Ecocert[] = [];\n  for (const activityWithOrgInfo of activitiesWithOrgInfo) {\n    const logo = activityWithOrgInfo.organizationInfo.logo;\n    const logoUrl =\n      logo ?\n        getBlobUrl(activityWithOrgInfo.repo.did, logo.image, pdsDomain)\n      : null;\n    for (const activity of activityWithOrgInfo.activities) {\n      ecocerts.push({\n        repo: {\n          did: activityWithOrgInfo.repo.did,\n        },\n        organizationInfo: {\n          name: activityWithOrgInfo.organizationInfo.displayName,\n          logoUrl: logoUrl,\n        },\n        claimActivity: activity,\n      });\n    }\n  }\n  return ecocerts;\n};\n","import z from \"zod\";\nimport { CID } from \"multiformats/cid\";\nimport type { Version } from \"multiformats/cid\";\nimport { BlobRef } from \"@atproto/api\";\n\nconst BlobRefGeneratorSchema = z.object({\n  $type: z.literal(\"blob-ref-generator\"),\n  ref: z.object({\n    $link: z.string(),\n  }),\n  mimeType: z.string(),\n  size: z.number(),\n});\n\ntype BlobRefGenerator = z.infer<typeof BlobRefGeneratorSchema>;\n\nconst toBlobRef = (input: BlobRefGenerator) => {\n  const validCID: CID<unknown, number, number, Version> = CID.parse(\n    input.ref.$link\n  );\n  return BlobRef.fromJsonRef({\n    $type: \"blob\",\n    ref: validCID,\n    mimeType: input.mimeType,\n    size: input.size,\n  });\n};\n\nconst toBlobRefGenerator = (blobRef: BlobRef): BlobRefGenerator => {\n  const json = blobRef.toJSON() as Omit<BlobRefGenerator, \"$type\"> & {\n    $type: \"blob\";\n  };\n  return {\n    $type: \"blob-ref-generator\",\n    ref: json.ref,\n    mimeType: json.mimeType,\n    size: json.size,\n  };\n};\n\nexport {\n  BlobRefGeneratorSchema,\n  toBlobRef,\n  toBlobRefGenerator,\n  type BlobRefGenerator,\n  BlobRef,\n};\n","export const isObject = (value: unknown): value is object => {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    !Array.isArray(value) &&\n    !(value instanceof RegExp) &&\n    !(value instanceof Date) &&\n    !(value instanceof Set) &&\n    !(value instanceof Map)\n  );\n};\n","// utils/transformer.ts\nimport type { DataTransformer } from \"@trpc/server\";\nimport superjson, { type SuperJSONResult } from \"superjson\";\nimport {\n  type BlobRefGenerator,\n  toBlobRef,\n} from \"@/_internal/zod-schemas/blobref\";\nimport { BlobRef } from \"@atproto/api\";\nimport { isObject } from \"@/_internal/lib/isObject\";\n\ntype ReplaceType<T, U, V> =\n  // If T directly extends U, substitute to V\n  T extends U ? V\n  : // If T is an array, recursively apply ReplaceType on the element type\n  T extends (infer Item)[] ? ReplaceType<Item, U, V>[]\n  : // If T is an object, recursively apply ReplaceType on all properties\n  T extends object ? { [K in keyof T]: ReplaceType<T[K], U, V> }\n  : // Otherwise, keep original type\n    T;\n\ntype Serialize<T> = ReplaceType<T, BlobRef, BlobRefGenerator>;\n\nconst _serialize = <T>(data: T): Serialize<T> => {\n  return JSON.parse(JSON.stringify(data)) as Serialize<T>;\n};\n\nconst _deserialize = <T>(data: Serialize<T>): T => {\n  const isObj = isObject(data);\n  if (!isObj) {\n    if (Array.isArray(data)) {\n      return data.map(_deserialize) as T;\n    }\n    return data as T;\n  }\n  if (\"$type\" in data && data.$type === \"blob\" && \"ref\" in data) {\n    try {\n      return toBlobRef(data as unknown as BlobRefGenerator) as T;\n    } catch {\n      return data as T;\n    }\n  }\n\n  const obj = data as Record<string, unknown>;\n  return Object.fromEntries(\n    Object.entries(obj).map(([key, value]) => [key, _deserialize(value)])\n  ) as T;\n};\n\nexport const customTransformer: DataTransformer = {\n  serialize: (object) => {\n    // typeof object = object\n    // This logic runs for transforming the query or mutation parameters before they are sent to the server.\n    // Conversion of object to string is automatically handled by TRPC.\n    const atprotoSerialized = _serialize(object);\n    const serializedObject = superjson.serialize(atprotoSerialized);\n    return serializedObject;\n  },\n  deserialize: <T>(object: SuperJSONResult): T => {\n    // typeof object = { json: object }\n    // This logic runs for transforming the query or mutation response before it is received by the client.\n    // The received response is automatically converted from stringified JSON to object by TRPC.\n    const superjsonDeserialized = superjson.deserialize(object) as Serialize<T>;\n    const deserializedObject = _deserialize(superjsonDeserialized);\n    // console.log(\"deserialized object\", deserializedObject);\n    return deserializedObject as T;\n  },\n};\n\nexport type SerializedSuperjson<T> = Omit<SuperJSONResult, \"json\"> & {\n  json: Serialize<T>;\n};\n\nexport const serialize = <T>(data: T) => {\n  const result = customTransformer.serialize(data);\n  return result as SerializedSuperjson<T>;\n};\n\nexport const deserialize = <T>(object: SerializedSuperjson<T>): T => {\n  return customTransformer.deserialize(object);\n};\n","import type {\n  Feature,\n  FeatureCollection,\n  GeoJsonObject,\n  Geometry,\n  GeometryCollection,\n  LineString,\n  MultiLineString,\n  MultiPoint,\n  MultiPolygon,\n  Point,\n  Polygon,\n  Position,\n} from \"geojson\";\nimport {\n  area as turfArea,\n  bbox as turfBbox,\n  centerOfMass,\n  centroid as turfCentroid,\n  featureCollection,\n  length as turfLength,\n} from \"@turf/turf\";\n\nexport type Coordinates = {\n  lat: number;\n  lon: number;\n};\n\nexport type PolygonMetrics = {\n  areaSqMeters: number | null;\n  areaHectares: number | null;\n  centroid: Coordinates | null;\n  bbox: [number, number, number, number] | null;\n  message: string;\n};\n\nexport const HECTARES_PER_SQUARE_METER = 0.0001;\n\nconst isFeatureCollection = (\n  value: GeoJsonObject\n): value is FeatureCollection => value.type === \"FeatureCollection\";\n\nconst isFeature = (value: GeoJsonObject): value is Feature =>\n  value.type === \"Feature\";\n\nconst isGeometryCollection = (value: Geometry): value is GeometryCollection =>\n  value.type === \"GeometryCollection\";\n\nconst isPolygon = (value: Geometry): value is Polygon =>\n  value.type === \"Polygon\";\n\nconst isMultiPolygon = (value: Geometry): value is MultiPolygon =>\n  value.type === \"MultiPolygon\";\n\nconst isLineString = (value: Geometry): value is LineString =>\n  value.type === \"LineString\";\n\nconst isMultiLineString = (value: Geometry): value is MultiLineString =>\n  value.type === \"MultiLineString\";\n\nconst isPoint = (value: Geometry): value is Point => value.type === \"Point\";\n\nconst isMultiPoint = (value: Geometry): value is MultiPoint =>\n  value.type === \"MultiPoint\";\n\nconst isLineStringClosed = (lineString: LineString): boolean => {\n  const coords = lineString.coordinates;\n  if (coords.length < 4) return false; // Need at least 4 points for a closed ring\n\n  const first = coords[0];\n  const last = coords[coords.length - 1];\n\n  if (!first || !last || first.length < 2 || last.length < 2) return false;\n\n  const firstLon = first[0];\n  const firstLat = first[1];\n  const lastLon = last[0];\n  const lastLat = last[1];\n\n  if (\n    firstLon === undefined ||\n    firstLat === undefined ||\n    lastLon === undefined ||\n    lastLat === undefined\n  ) {\n    return false;\n  }\n\n  // Check if first and last points are the same (with small tolerance for floating point)\n  const tolerance = 1e-10;\n  return (\n    Math.abs(firstLon - lastLon) < tolerance &&\n    Math.abs(firstLat - lastLat) < tolerance\n  );\n};\n\nconst lineStringToPolygon = (lineString: LineString): Polygon | null => {\n  if (!isLineStringClosed(lineString)) return null;\n\n  // Convert closed LineString to Polygon\n  // A Polygon is an array of LinearRings, where the first is the exterior ring\n  return {\n    type: \"Polygon\",\n    coordinates: [lineString.coordinates],\n  };\n};\n\nconst toFeature = (geometry: Geometry): Feature<Geometry> => ({\n  type: \"Feature\",\n  geometry,\n  properties: {},\n});\n\nexport const extractPolygonFeatures = (\n  input: GeoJsonObject\n): Feature<Polygon | MultiPolygon>[] => {\n  if (isFeatureCollection(input)) {\n    return input.features.flatMap((feature) => extractPolygonFeatures(feature));\n  }\n\n  if (isFeature(input)) {\n    const geometry = input.geometry;\n    if (!geometry) return [];\n\n    if (isGeometryCollection(geometry)) {\n      return geometry.geometries.flatMap((subGeometry) =>\n        extractPolygonFeatures(toFeature(subGeometry))\n      );\n    }\n\n    if (isPolygon(geometry) || isMultiPolygon(geometry)) {\n      return [input as Feature<Polygon | MultiPolygon>];\n    }\n\n    return [];\n  }\n\n  const geometry = input as Geometry;\n\n  if (isGeometryCollection(geometry)) {\n    return geometry.geometries.flatMap((subGeometry) =>\n      extractPolygonFeatures(toFeature(subGeometry))\n    );\n  }\n\n  if (isPolygon(geometry) || isMultiPolygon(geometry)) {\n    return [toFeature(geometry) as Feature<Polygon | MultiPolygon>];\n  }\n\n  return [];\n};\n\nexport const extractLineStringFeatures = (\n  input: GeoJsonObject\n): Feature<LineString | MultiLineString>[] => {\n  if (isFeatureCollection(input)) {\n    return input.features.flatMap((feature) =>\n      extractLineStringFeatures(feature)\n    );\n  }\n\n  if (isFeature(input)) {\n    const geometry = input.geometry;\n    if (!geometry) return [];\n\n    if (isGeometryCollection(geometry)) {\n      return geometry.geometries.flatMap((subGeometry) =>\n        extractLineStringFeatures(toFeature(subGeometry))\n      );\n    }\n\n    if (isLineString(geometry) || isMultiLineString(geometry)) {\n      return [input as Feature<LineString | MultiLineString>];\n    }\n\n    return [];\n  }\n\n  const geometry = input as Geometry;\n\n  if (isGeometryCollection(geometry)) {\n    return geometry.geometries.flatMap((subGeometry) =>\n      extractLineStringFeatures(toFeature(subGeometry))\n    );\n  }\n\n  if (isLineString(geometry) || isMultiLineString(geometry)) {\n    return [toFeature(geometry) as Feature<LineString | MultiLineString>];\n  }\n\n  return [];\n};\n\nexport const extractPointFeatures = (\n  input: GeoJsonObject\n): Feature<Point | MultiPoint>[] => {\n  if (isFeatureCollection(input)) {\n    return input.features.flatMap((feature) => extractPointFeatures(feature));\n  }\n\n  if (isFeature(input)) {\n    const geometry = input.geometry;\n    if (!geometry) return [];\n\n    if (isGeometryCollection(geometry)) {\n      return geometry.geometries.flatMap((subGeometry) =>\n        extractPointFeatures(toFeature(subGeometry))\n      );\n    }\n\n    if (isPoint(geometry) || isMultiPoint(geometry)) {\n      return [input as Feature<Point | MultiPoint>];\n    }\n\n    return [];\n  }\n\n  const geometry = input as Geometry;\n\n  if (isGeometryCollection(geometry)) {\n    return geometry.geometries.flatMap((subGeometry) =>\n      extractPointFeatures(toFeature(subGeometry))\n    );\n  }\n\n  if (isPoint(geometry) || isMultiPoint(geometry)) {\n    return [toFeature(geometry) as Feature<Point | MultiPoint>];\n  }\n\n  return [];\n};\n\nconst computeCentroid = (\n  features: Feature<Polygon | MultiPolygon>[]\n): Position | null => {\n  if (features.length === 0) return null;\n\n  const collection = featureCollection(features);\n\n  try {\n    const { geometry } = centerOfMass(collection);\n    return geometry.coordinates;\n  } catch {\n    try {\n      const { geometry } = turfCentroid(collection);\n      return geometry.coordinates;\n    } catch {\n      return null;\n    }\n  }\n};\n\nconst computeCentroidForLineStrings = (\n  features: Feature<LineString | MultiLineString>[]\n): Position | null => {\n  if (features.length === 0) return null;\n\n  const collection = featureCollection(features);\n\n  try {\n    const { geometry } = centerOfMass(collection);\n    return geometry.coordinates;\n  } catch {\n    try {\n      const { geometry } = turfCentroid(collection);\n      return geometry.coordinates;\n    } catch {\n      return null;\n    }\n  }\n};\n\nconst computeCentroidForPoints = (\n  features: Feature<Point | MultiPoint>[]\n): Position | null => {\n  if (features.length === 0) return null;\n\n  const collection = featureCollection(features);\n\n  try {\n    const { geometry } = centerOfMass(collection);\n    return geometry.coordinates;\n  } catch {\n    try {\n      const { geometry } = turfCentroid(collection);\n      return geometry.coordinates;\n    } catch {\n      return null;\n    }\n  }\n};\n\nconst computeCentroidForMixed = (\n  features: Feature<Geometry>[]\n): Position | null => {\n  if (features.length === 0) return null;\n\n  const collection = featureCollection(features);\n\n  try {\n    const { geometry } = centerOfMass(collection);\n    return geometry.coordinates;\n  } catch {\n    try {\n      const { geometry } = turfCentroid(collection);\n      return geometry.coordinates;\n    } catch {\n      return null;\n    }\n  }\n};\n\nexport const computePolygonMetrics = (\n  geoJson: GeoJsonObject\n): PolygonMetrics => {\n  const polygonFeatures = extractPolygonFeatures(geoJson);\n  const lineStringFeatures = extractLineStringFeatures(geoJson);\n  const pointFeatures = extractPointFeatures(geoJson);\n\n  // Try to convert closed LineStrings to Polygons\n  const convertedPolygons: Feature<Polygon>[] = [];\n  for (const lineStringFeature of lineStringFeatures) {\n    if (lineStringFeature.geometry.type === \"LineString\") {\n      const polygon = lineStringToPolygon(lineStringFeature.geometry);\n      if (polygon) {\n        convertedPolygons.push({\n          type: \"Feature\",\n          geometry: polygon,\n          properties: lineStringFeature.properties,\n        });\n      }\n    } else if (lineStringFeature.geometry.type === \"MultiLineString\") {\n      // Handle MultiLineString - convert each closed LineString\n      for (const lineString of lineStringFeature.geometry.coordinates) {\n        const ls: LineString = { type: \"LineString\", coordinates: lineString };\n        const polygon = lineStringToPolygon(ls);\n        if (polygon) {\n          convertedPolygons.push({\n            type: \"Feature\",\n            geometry: polygon,\n            properties: lineStringFeature.properties,\n          });\n        }\n      }\n    }\n  }\n\n  // Combine original polygons with converted ones\n  const allPolygonFeatures = [...polygonFeatures, ...convertedPolygons];\n\n  // Handle Point geometries only\n  if (\n    pointFeatures.length > 0 &&\n    allPolygonFeatures.length === 0 &&\n    lineStringFeatures.length === 0\n  ) {\n    const centroidPosition = computeCentroidForPoints(pointFeatures);\n    const bbox = turfBbox(featureCollection(pointFeatures)) as [\n      number,\n      number,\n      number,\n      number\n    ];\n\n    let centroid: Coordinates | null = null;\n\n    if (\n      centroidPosition &&\n      centroidPosition[0] !== undefined &&\n      centroidPosition[1] !== undefined\n    ) {\n      const [lon, lat] = centroidPosition;\n      centroid = { lat, lon };\n    }\n\n    return {\n      areaSqMeters: null,\n      areaHectares: null,\n      centroid,\n      bbox,\n      message: centroid ? \"Success (Point)\" : \"Centroid calculation failed\",\n    };\n  }\n\n  // Handle LineString geometries (including closed ones that were converted)\n  if (lineStringFeatures.length > 0 && allPolygonFeatures.length === 0) {\n    const lengthMeters = lineStringFeatures.reduce(\n      (acc, feature) => acc + turfLength(feature, { units: \"meters\" }),\n      0\n    );\n\n    const centroidPosition = computeCentroidForLineStrings(lineStringFeatures);\n    const bbox = turfBbox(featureCollection(lineStringFeatures)) as [\n      number,\n      number,\n      number,\n      number\n    ];\n\n    let centroid: Coordinates | null = null;\n\n    if (\n      centroidPosition &&\n      centroidPosition[0] !== undefined &&\n      centroidPosition[1] !== undefined\n    ) {\n      const [lon, lat] = centroidPosition;\n      centroid = { lat, lon };\n    }\n\n    return {\n      areaSqMeters: null,\n      areaHectares: null,\n      centroid,\n      bbox,\n      message: centroid\n        ? \"Success (LineString)\"\n        : \"Centroid calculation failed\",\n    };\n  }\n\n  // Handle mixed geometries (Polygon, LineString, and/or Point)\n  const hasPolygons = allPolygonFeatures.length > 0;\n  const hasLineStrings = lineStringFeatures.length > 0;\n  const hasPoints = pointFeatures.length > 0;\n  const geometryTypeCount =\n    (hasPolygons ? 1 : 0) + (hasLineStrings ? 1 : 0) + (hasPoints ? 1 : 0);\n\n  if (geometryTypeCount > 1) {\n    const areaSqMeters = allPolygonFeatures.reduce(\n      (acc, feature) => acc + turfArea(feature),\n      0\n    );\n\n    const allFeatures = [\n      ...allPolygonFeatures,\n      ...lineStringFeatures,\n      ...pointFeatures,\n    ] as Feature<Geometry>[];\n\n    const centroidPosition = computeCentroidForMixed(allFeatures);\n    const bbox = turfBbox(featureCollection(allFeatures)) as [\n      number,\n      number,\n      number,\n      number\n    ];\n\n    let centroid: Coordinates | null = null;\n\n    if (\n      centroidPosition &&\n      centroidPosition[0] !== undefined &&\n      centroidPosition[1] !== undefined\n    ) {\n      const [lon, lat] = centroidPosition;\n      centroid = { lat, lon };\n    }\n\n    const typeLabels = [];\n    if (hasPolygons) typeLabels.push(\"Polygon\");\n    if (hasLineStrings) typeLabels.push(\"LineString\");\n    if (hasPoints) typeLabels.push(\"Point\");\n\n    return {\n      areaSqMeters,\n      areaHectares: areaSqMeters * HECTARES_PER_SQUARE_METER,\n      centroid,\n      bbox,\n      message: centroid\n        ? `Success (mixed: ${typeLabels.join(\", \")})`\n        : \"Centroid calculation failed\",\n    };\n  }\n\n  // Handle Polygon geometries only (including converted closed LineStrings)\n  if (\n    allPolygonFeatures.length === 0 &&\n    lineStringFeatures.length === 0 &&\n    pointFeatures.length === 0\n  ) {\n    return {\n      areaSqMeters: null,\n      areaHectares: null,\n      centroid: null,\n      bbox: null,\n      message: \"No polygons found\",\n    };\n  }\n\n  const areaSqMeters = allPolygonFeatures.reduce(\n    (acc, feature) => acc + turfArea(feature),\n    0\n  );\n\n  const centroidPosition = computeCentroid(allPolygonFeatures);\n  const bbox = turfBbox(featureCollection(allPolygonFeatures)) as [\n    number,\n    number,\n    number,\n    number\n  ];\n\n  let centroid: Coordinates | null = null;\n\n  if (\n    centroidPosition &&\n    centroidPosition[0] !== undefined &&\n    centroidPosition[1] !== undefined\n  ) {\n    const [lon, lat] = centroidPosition;\n    centroid = { lat, lon };\n  }\n\n  return {\n    areaSqMeters,\n    areaHectares: areaSqMeters * HECTARES_PER_SQUARE_METER,\n    centroid,\n    bbox,\n    message: centroid ? \"Success\" : \"Centroid calculation failed\",\n  };\n};\n\nexport const toFeatureCollection = (\n  geoJson: GeoJsonObject\n): FeatureCollection => {\n  if (isFeatureCollection(geoJson)) return geoJson;\n\n  if (isFeature(geoJson)) {\n    return featureCollection([geoJson]);\n  }\n\n  return featureCollection([toFeature(geoJson as Geometry)]);\n};\n","import type { GeoJsonObject } from \"geojson\";\n\n/**\n * Validates if an unknown object is a valid GeoJSON object.\n * @param value - The value to validate\n * @returns The validated GeoJSON object\n * @throws Error if the value is not a valid GeoJSON object\n */\nexport function validateGeojsonOrThrow(value: unknown): GeoJsonObject {\n  if (value === null || typeof value !== \"object\") {\n    throw new Error(\"GeoJSON must be an object\");\n  }\n\n  const obj = value as Record<string, unknown>;\n\n  if (!(\"type\" in obj) || typeof obj.type !== \"string\") {\n    throw new Error(\"GeoJSON must have a 'type' property of type string\");\n  }\n\n  const type = obj.type;\n\n  // Validate FeatureCollection\n  if (type === \"FeatureCollection\") {\n    if (!(\"features\" in obj) || !Array.isArray(obj.features)) {\n      throw new Error(\n        \"FeatureCollection must have a 'features' property of type array\"\n      );\n    }\n\n    // Validate each feature in the collection\n    for (let i = 0; i < obj.features.length; i++) {\n      try {\n        validateGeojsonOrThrow(obj.features[i]);\n      } catch (error) {\n        throw new Error(\n          `FeatureCollection.features[${i}] is invalid: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    }\n\n    return obj as unknown as GeoJsonObject;\n  }\n\n  // Validate Feature\n  if (type === \"Feature\") {\n    if (!(\"geometry\" in obj)) {\n      throw new Error(\"Feature must have a 'geometry' property\");\n    }\n\n    if (obj.geometry !== null) {\n      try {\n        validateGeometry(obj.geometry);\n      } catch (error) {\n        throw new Error(\n          `Feature.geometry is invalid: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    }\n\n    if (!(\"properties\" in obj)) {\n      throw new Error(\"Feature must have a 'properties' property\");\n    }\n\n    if (obj.properties !== null && typeof obj.properties !== \"object\") {\n      throw new Error(\"Feature.properties must be an object or null\");\n    }\n\n    return obj as unknown as GeoJsonObject;\n  }\n\n  // Validate Geometry types\n  try {\n    validateGeometry(obj);\n    return obj as unknown as GeoJsonObject;\n  } catch (error) {\n    throw new Error(\n      `Invalid GeoJSON type '${type}': ${error instanceof Error ? error.message : String(error)}`\n    );\n  }\n}\n\n/**\n * Validates a GeoJSON geometry object\n */\nfunction validateGeometry(value: unknown): void {\n  if (value === null || typeof value !== \"object\") {\n    throw new Error(\"Geometry must be an object\");\n  }\n\n  const geometry = value as Record<string, unknown>;\n\n  if (!(\"type\" in geometry) || typeof geometry.type !== \"string\") {\n    throw new Error(\"Geometry must have a 'type' property of type string\");\n  }\n\n  const type = geometry.type;\n\n  // Validate GeometryCollection\n  if (type === \"GeometryCollection\") {\n    if (!(\"geometries\" in geometry) || !Array.isArray(geometry.geometries)) {\n      throw new Error(\n        \"GeometryCollection must have a 'geometries' property of type array\"\n      );\n    }\n\n    for (let i = 0; i < geometry.geometries.length; i++) {\n      try {\n        validateGeometry(geometry.geometries[i]);\n      } catch (error) {\n        throw new Error(\n          `GeometryCollection.geometries[${i}] is invalid: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    }\n\n    return;\n  }\n\n  // Validate coordinates-based geometries\n  const coordinateGeometries = [\n    \"Point\",\n    \"LineString\",\n    \"Polygon\",\n    \"MultiPoint\",\n    \"MultiLineString\",\n    \"MultiPolygon\",\n  ];\n\n  if (coordinateGeometries.includes(type)) {\n    if (!(\"coordinates\" in geometry)) {\n      throw new Error(`${type} must have a 'coordinates' property`);\n    }\n\n    validateCoordinates(geometry.coordinates, type);\n    return;\n  }\n\n  throw new Error(`Unknown geometry type: ${type}`);\n}\n\n/**\n * Validates coordinates based on geometry type\n */\nfunction validateCoordinates(coordinates: unknown, type: string): void {\n  if (!Array.isArray(coordinates)) {\n    throw new Error(\"Coordinates must be an array\");\n  }\n\n  switch (type) {\n    case \"Point\":\n      validatePosition(coordinates);\n      break;\n    case \"LineString\":\n      validateLineString(coordinates);\n      break;\n    case \"Polygon\":\n      validatePolygon(coordinates);\n      break;\n    case \"MultiPoint\":\n      validateMultiPoint(coordinates);\n      break;\n    case \"MultiLineString\":\n      validateMultiLineString(coordinates);\n      break;\n    case \"MultiPolygon\":\n      validateMultiPolygon(coordinates);\n      break;\n  }\n}\n\n/**\n * Validates a Position (longitude, latitude, optional elevation)\n */\nfunction validatePosition(value: unknown): void {\n  if (!Array.isArray(value)) {\n    throw new Error(\"Position must be an array\");\n  }\n\n  if (value.length < 2) {\n    throw new Error(\n      \"Position must have at least 2 elements (longitude, latitude)\"\n    );\n  }\n\n  if (typeof value[0] !== \"number\" || typeof value[1] !== \"number\") {\n    throw new Error(\"Position must have numbers for longitude and latitude\");\n  }\n\n  // Validate optional elevation\n  if (value.length > 2 && typeof value[2] !== \"number\") {\n    throw new Error(\n      \"Position elevation (3rd element) must be a number if present\"\n    );\n  }\n\n  // Validate longitude range\n  if (value[0] < -180 || value[0] > 180) {\n    throw new Error(\"Longitude must be between -180 and 180\");\n  }\n\n  // Validate latitude range\n  if (value[1] < -90 || value[1] > 90) {\n    throw new Error(\"Latitude must be between -90 and 90\");\n  }\n}\n\n/**\n * Validates a LineString (array of Positions)\n */\nfunction validateLineString(value: unknown): void {\n  if (!Array.isArray(value)) {\n    throw new Error(\"LineString must be an array\");\n  }\n\n  if (value.length < 2) {\n    throw new Error(\"LineString must have at least 2 positions\");\n  }\n\n  for (let i = 0; i < value.length; i++) {\n    try {\n      validatePosition(value[i]);\n    } catch (error) {\n      throw new Error(\n        `LineString[${i}] is invalid: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n}\n\n/**\n * Validates a Polygon (array of LinearRings, where first is exterior and rest are holes)\n */\nfunction validatePolygon(value: unknown): void {\n  if (!Array.isArray(value)) {\n    throw new Error(\"Polygon must be an array\");\n  }\n\n  if (value.length === 0) {\n    throw new Error(\"Polygon must have at least one LinearRing\");\n  }\n\n  for (let i = 0; i < value.length; i++) {\n    try {\n      validateLinearRing(value[i]);\n    } catch (error) {\n      throw new Error(\n        `Polygon[${i}] is invalid: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n}\n\n/**\n * Validates a LinearRing (closed LineString with at least 4 positions)\n */\nfunction validateLinearRing(value: unknown): void {\n  if (!Array.isArray(value)) {\n    throw new Error(\"LinearRing must be an array\");\n  }\n\n  if (value.length < 4) {\n    throw new Error(\"LinearRing must have at least 4 positions\");\n  }\n\n  // Validate all positions\n  for (let i = 0; i < value.length; i++) {\n    try {\n      validatePosition(value[i]);\n    } catch (error) {\n      throw new Error(\n        `LinearRing[${i}] is invalid: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  // Check if ring is closed (first and last positions are the same)\n  const first = value[0] as number[];\n  const last = value[value.length - 1] as number[];\n  if (\n    first[0] !== last[0] ||\n    first[1] !== last[1] ||\n    (first.length > 2 && first[2] !== last[2])\n  ) {\n    throw new Error(\n      \"LinearRing must be closed (first and last positions must be equal)\"\n    );\n  }\n}\n\n/**\n * Validates a MultiPoint (array of Positions)\n */\nfunction validateMultiPoint(value: unknown): void {\n  if (!Array.isArray(value)) {\n    throw new Error(\"MultiPoint must be an array\");\n  }\n\n  for (let i = 0; i < value.length; i++) {\n    try {\n      validatePosition(value[i]);\n    } catch (error) {\n      throw new Error(\n        `MultiPoint[${i}] is invalid: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n}\n\n/**\n * Validates a MultiLineString (array of LineStrings)\n */\nfunction validateMultiLineString(value: unknown): void {\n  if (!Array.isArray(value)) {\n    throw new Error(\"MultiLineString must be an array\");\n  }\n\n  for (let i = 0; i < value.length; i++) {\n    try {\n      validateLineString(value[i]);\n    } catch (error) {\n      throw new Error(\n        `MultiLineString[${i}] is invalid: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n}\n\n/**\n * Validates a MultiPolygon (array of Polygons)\n */\nfunction validateMultiPolygon(value: unknown): void {\n  if (!Array.isArray(value)) {\n    throw new Error(\"MultiPolygon must be an array\");\n  }\n\n  for (let i = 0; i < value.length; i++) {\n    try {\n      validatePolygon(value[i]);\n    } catch (error) {\n      throw new Error(\n        `MultiPolygon[${i}] is invalid: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n}\n"]}