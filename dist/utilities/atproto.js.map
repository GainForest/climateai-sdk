{"version":3,"sources":["../../src/_internal/utilities/atproto/getBlobUrl.ts","../../src/_internal/utilities/atproto/parseAtUri.ts"],"names":[],"mappings":";;;AAYA,IAAM,UAAA,GAAa,CACjB,GAAA,EACA,SAAA,EAUA,SAAA,KACG;AACH,EAAA,IAAI,OAAO,cAAc,QAAA,EAAU;AACjC,IAAA,MAAM,QAAA,GAAW,IAAI,GAAA,CAAI,SAAS,CAAA;AAClC,IAAA,OAAO,SAAS,QAAA,EAAS;AAAA,EAC3B;AAEA,EAAA,MAAM,YACJ,SAAA,YAAqB,OAAA,IACpB,SAAS,SAAA,IAAa,UAAA,IAAc,aAAa,MAAA,IAAU,SAAA;AAC9D,EAAA,IAAI,SAAA,EAAW;AACb,IAAA,MAAM,MAAM,SAAA,CAAU,GAAA;AACtB,IAAA,MAAM,GAAA,GAAM,OAAO,GAAA,KAAQ,QAAA,GAAW,MAAO,GAAA,EAAK,KAAA,IAAS,OAAO,GAAG,CAAA;AACrE,IAAA,MAAM,UAAA,GAAa,mBAAmB,GAAG,CAAA;AACzC,IAAA,OAAO,CAAA,QAAA,EAAW,SAAS,CAAA,mCAAA,EAAsC,GAAG,QAAQ,UAAU,CAAA,CAAA;AAAA,EACxF;AAGA,EAAA,IAAI,SAAA,CAAU,UAAU,gCAAA,EAAkC;AACxD,IAAA,MAAM,MAAM,SAAA,CAAU,GAAA;AAMtB,IAAA,OAAO,GAAA;AAAA,EACT;AAEA,EAAA,IACE,SAAA,CAAU,KAAA,KAAU,sCAAA,IACpB,SAAA,CAAU,UAAU,sCAAA,EACpB;AACA,IAAA,MAAM,OAAO,SAAA,CAAU,IAAA;AACvB,IAAA,OAAO,UAAA,CAAW,GAAA,EAAK,IAAA,EAAM,SAAS,CAAA;AAAA,EACxC;AAEA,EAAA,IACE,SAAA,CAAU,KAAA,KAAU,uCAAA,IACpB,SAAA,CAAU,UAAU,uCAAA,EACpB;AACA,IAAA,MAAM,QAAQ,SAAA,CAAU,KAAA;AACxB,IAAA,OAAO,UAAA,CAAW,GAAA,EAAK,KAAA,EAAO,SAAS,CAAA;AAAA,EACzC;AAEA,EAAA,IAAI,UAAU,SAAA,EAAW;AACvB,IAAA,MAAM,OAAO,SAAA,CAAU,IAAA;AACvB,IAAA,OAAO,UAAA,CAAW,GAAA,EAAK,IAAA,EAAM,SAAS,CAAA;AAAA,EACxC;AAEA,EAAA,IAAI,WAAW,SAAA,EAAW;AACxB,IAAA,MAAM,QAAQ,SAAA,CAAU,KAAA;AACxB,IAAA,OAAO,UAAA,CAAW,GAAA,EAAK,KAAA,EAAO,SAAS,CAAA;AAAA,EACzC;AAEA,EAAA,IAAI,SAAS,SAAA,EAAW;AACtB,IAAA,MAAM,MAAM,SAAA,CAAU,GAAA;AACtB,IAAA,OAAO,GAAA;AAAA,EACT;AAGA,EAAA,MAAM,kBAAA,GAAqB,SAAA;AAC3B,EAAA,OAAO,kBAAA;AACT;;;ACtFA,IAAM,UAAA,GAAa,CAAC,KAAA,KAAkB;AACpC,EAAA,IAAI,YAAA,GAAe,KAAA,CAAM,OAAA,CAAQ,OAAA,EAAS,EAAE,CAAA;AAE5C,EAAA,MAAM,QAAA,GAAW,YAAA,CAAa,KAAA,CAAM,GAAG,CAAA;AAEvC,EAAA,MAAM,GAAA,GAAM,QAAA,CAAS,EAAA,CAAG,CAAC,CAAA,IAAK,EAAA;AAC9B,EAAA,MAAM,UAAA,GAAa,QAAA,CAAS,EAAA,CAAG,CAAC,CAAA,IAAK,EAAA;AACrC,EAAA,MAAM,IAAA,GAAO,QAAA,CAAS,EAAA,CAAG,CAAC,CAAA,IAAK,MAAA;AAE/B,EAAA,OAAO,EAAE,GAAA,EAAK,UAAA,EAAY,IAAA,EAAK;AACjC","file":"atproto.js","sourcesContent":["import {\n  type LargeBlob,\n  type LargeImage,\n  type SmallBlob,\n  type SmallImage,\n  type Uri,\n} from \"@/../lex-api/types/app/gainforest/common/defs\";\nimport type { $Typed } from \"@/../lex-api/util\";\nimport type { BlobRefGenerator } from \"@/_internal/zod-schemas/blobref\";\nimport { BlobRef } from \"@atproto/api\";\nimport { SupportedPDSDomain } from \"../..\";\n\nconst getBlobUrl = <T extends SupportedPDSDomain>(\n  did: string,\n  imageData:\n    | string\n    | BlobRef\n    | BlobRefGenerator\n    | $Typed<Uri | SmallImage | LargeImage | SmallBlob | LargeBlob>\n    | Uri\n    | SmallImage\n    | LargeImage\n    | SmallBlob\n    | LargeBlob,\n  pdsDomain: T\n) => {\n  if (typeof imageData === \"string\") {\n    const imageUrl = new URL(imageData);\n    return imageUrl.toString();\n  }\n\n  const isBlobRef =\n    imageData instanceof BlobRef ||\n    (\"ref\" in imageData && \"mimeType\" in imageData && \"size\" in imageData);\n  if (isBlobRef) {\n    const ref = imageData.ref as unknown as { $link?: string } | string;\n    const cid = typeof ref === \"string\" ? ref : (ref?.$link ?? String(ref));\n    const encodedCid = encodeURIComponent(cid);\n    return `https://${pdsDomain}/xrpc/com.atproto.sync.getBlob?did=${did}&cid=${encodedCid}`;\n  }\n\n  // Handle $Typed cases\n  if (imageData.$type === \"app.gainforest.common.defs#uri\") {\n    const uri = imageData.uri;\n    // TODO: handle other URI types\n    // if (uri.startsWith(\"at://\")) {\n    //   const { did: uriDid, rkey: uriRkey } = parseAtUri(uri);\n    //   return `${PDS_URL}/xrpc/com.atproto.repo.getRecord?did=${uriDid}&rkey=${uriRkey}`;\n    // }\n    return uri;\n  }\n\n  if (\n    imageData.$type === \"app.gainforest.common.defs#smallBlob\" ||\n    imageData.$type === \"app.gainforest.common.defs#largeBlob\"\n  ) {\n    const blob = imageData.blob;\n    return getBlobUrl(did, blob, pdsDomain);\n  }\n\n  if (\n    imageData.$type === \"app.gainforest.common.defs#smallImage\" ||\n    imageData.$type === \"app.gainforest.common.defs#largeImage\"\n  ) {\n    const image = imageData.image;\n    return getBlobUrl(did, image, pdsDomain);\n  }\n\n  if (\"blob\" in imageData) {\n    const blob = imageData.blob;\n    return getBlobUrl(did, blob, pdsDomain);\n  }\n\n  if (\"image\" in imageData) {\n    const image = imageData.image;\n    return getBlobUrl(did, image, pdsDomain);\n  }\n\n  if (\"uri\" in imageData) {\n    const uri = imageData.uri;\n    return uri;\n  }\n\n  // Line for compile time check that all cases are handled. THIS SHOULD NEVER BE REACHED.\n  const imageDataTypeCheck = imageData satisfies never;\n  return imageDataTypeCheck;\n};\n\nexport { getBlobUrl };\n","const parseAtUri = (atUri: string) => {\n  let cleanedAtUri = atUri.replace(\"at://\", \"\");\n\n  const splitUri = cleanedAtUri.split(\"/\");\n\n  const did = splitUri.at(0) ?? \"\";\n  const collection = splitUri.at(1) ?? \"\";\n  const rkey = splitUri.at(2) ?? \"self\";\n\n  return { did, collection, rkey };\n};\n\nexport { parseAtUri };\n"]}