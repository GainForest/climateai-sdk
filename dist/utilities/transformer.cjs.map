{"version":3,"sources":["../../src/utilities/transformer.ts"],"sourcesContent":["// utils/transformer.ts\nimport type { DataTransformer } from \"@trpc/server\";\nimport superjson, { type SuperJSONResult } from \"superjson\";\nimport { type BlobRefGenerator, toBlobRef } from \"@/zod-schemas/blobref\";\nimport { BlobRef } from \"@atproto/api\";\nimport { isObject } from \"@/lib/isObject\";\n\ntype ReplaceType<T, U, V> =\n  // If T directly extends U, substitute to V\n  T extends U\n    ? V\n    : // If T is an array, recursively apply ReplaceType on the element type\n    T extends (infer Item)[]\n    ? ReplaceType<Item, U, V>[]\n    : // If T is an object, recursively apply ReplaceType on all properties\n    T extends object\n    ? { [K in keyof T]: ReplaceType<T[K], U, V> }\n    : // Otherwise, keep original type\n      T;\n\ntype Serialize<T> = ReplaceType<T, BlobRef, BlobRefGenerator>;\n\nconst _serialize = <T>(data: T): Serialize<T> => {\n  return JSON.parse(JSON.stringify(data)) as Serialize<T>;\n};\n\nconst _deserialize = <T>(data: Serialize<T>): T => {\n  const isObj = isObject(data);\n  if (!isObj) {\n    if (Array.isArray(data)) {\n      return data.map(_deserialize) as T;\n    }\n    return data as T;\n  }\n  if (\"$type\" in data && data.$type === \"blob\" && \"ref\" in data) {\n    try {\n      return toBlobRef(data as unknown as BlobRefGenerator) as T;\n    } catch {\n      return data as T;\n    }\n  }\n\n  const obj = data as Record<string, unknown>;\n  return Object.fromEntries(\n    Object.entries(obj).map(([key, value]) => [key, _deserialize(value)])\n  ) as T;\n};\n\nexport const customTransformer: DataTransformer = {\n  serialize: (object) => {\n    // typeof object = object\n    // This logic runs for transforming the query or mutation parameters before they are sent to the server.\n    // Conversion of object to string is automatically handled by TRPC.\n    const atprotoSerialized = _serialize(object);\n    const serializedObject = superjson.serialize(atprotoSerialized);\n    return serializedObject;\n  },\n  deserialize: <T>(object: SuperJSONResult): T => {\n    // typeof object = { json: object }\n    // This logic runs for transforming the query or mutation response before it is received by the client.\n    // The received response is automatically converted from stringified JSON to object by TRPC.\n    const superjsonDeserialized = superjson.deserialize(object) as Serialize<T>;\n    const deserializedObject = _deserialize(superjsonDeserialized);\n    // console.log(\"deserialized object\", deserializedObject);\n    return deserializedObject as T;\n  },\n};\n\nexport type SerializedSuperjson<T> = Omit<SuperJSONResult, \"json\"> & {\n  json: Serialize<T>;\n};\n\nexport const serialize = <T>(data: T) => {\n  const result = customTransformer.serialize(data);\n  return result as SerializedSuperjson<T>;\n};\n\nexport const deserialize = <T>(object: SerializedSuperjson<T>): T => {\n  return customTransformer.deserialize(object);\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA,uBAAgD;AAChD,qBAAiD;AAEjD,sBAAyB;AAiBzB,IAAM,aAAa,CAAI,SAA0B;AAC/C,SAAO,KAAK,MAAM,KAAK,UAAU,IAAI,CAAC;AACxC;AAEA,IAAM,eAAe,CAAI,SAA0B;AACjD,QAAM,YAAQ,0BAAS,IAAI;AAC3B,MAAI,CAAC,OAAO;AACV,QAAI,MAAM,QAAQ,IAAI,GAAG;AACvB,aAAO,KAAK,IAAI,YAAY;AAAA,IAC9B;AACA,WAAO;AAAA,EACT;AACA,MAAI,WAAW,QAAQ,KAAK,UAAU,UAAU,SAAS,MAAM;AAC7D,QAAI;AACF,iBAAO,0BAAU,IAAmC;AAAA,IACtD,QAAQ;AACN,aAAO;AAAA,IACT;AAAA,EACF;AAEA,QAAM,MAAM;AACZ,SAAO,OAAO;AAAA,IACZ,OAAO,QAAQ,GAAG,EAAE,IAAI,CAAC,CAAC,KAAK,KAAK,MAAM,CAAC,KAAK,aAAa,KAAK,CAAC,CAAC;AAAA,EACtE;AACF;AAEO,IAAM,oBAAqC;AAAA,EAChD,WAAW,CAAC,WAAW;AAIrB,UAAM,oBAAoB,WAAW,MAAM;AAC3C,UAAM,mBAAmB,iBAAAA,QAAU,UAAU,iBAAiB;AAC9D,WAAO;AAAA,EACT;AAAA,EACA,aAAa,CAAI,WAA+B;AAI9C,UAAM,wBAAwB,iBAAAA,QAAU,YAAY,MAAM;AAC1D,UAAM,qBAAqB,aAAa,qBAAqB;AAE7D,WAAO;AAAA,EACT;AACF;AAMO,IAAM,YAAY,CAAI,SAAY;AACvC,QAAM,SAAS,kBAAkB,UAAU,IAAI;AAC/C,SAAO;AACT;AAEO,IAAM,cAAc,CAAI,WAAsC;AACnE,SAAO,kBAAkB,YAAY,MAAM;AAC7C;","names":["superjson"]}