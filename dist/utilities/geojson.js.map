{"version":3,"sources":["../../src/_internal/lib/geojson/computations.ts","../../src/_internal/lib/geojson/validate.ts"],"names":["geometry","turfCentroid","centroidPosition","bbox","turfBbox","centroid","turfLength","areaSqMeters","turfArea"],"mappings":"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","file":"geojson.js","sourcesContent":["import type {\n  Feature,\n  FeatureCollection,\n  GeoJsonObject,\n  Geometry,\n  GeometryCollection,\n  LineString,\n  MultiLineString,\n  MultiPoint,\n  MultiPolygon,\n  Point,\n  Polygon,\n  Position,\n} from \"geojson\";\nimport {\n  area as turfArea,\n  bbox as turfBbox,\n  centerOfMass,\n  centroid as turfCentroid,\n  featureCollection,\n  length as turfLength,\n} from \"@turf/turf\";\n\nexport type Coordinates = {\n  lat: number;\n  lon: number;\n};\n\nexport type PolygonMetrics = {\n  areaSqMeters: number | null;\n  areaHectares: number | null;\n  centroid: Coordinates | null;\n  bbox: [number, number, number, number] | null;\n  message: string;\n};\n\nexport const HECTARES_PER_SQUARE_METER = 0.0001;\n\nconst isFeatureCollection = (\n  value: GeoJsonObject\n): value is FeatureCollection => value.type === \"FeatureCollection\";\n\nconst isFeature = (value: GeoJsonObject): value is Feature =>\n  value.type === \"Feature\";\n\nconst isGeometryCollection = (value: Geometry): value is GeometryCollection =>\n  value.type === \"GeometryCollection\";\n\nconst isPolygon = (value: Geometry): value is Polygon =>\n  value.type === \"Polygon\";\n\nconst isMultiPolygon = (value: Geometry): value is MultiPolygon =>\n  value.type === \"MultiPolygon\";\n\nconst isLineString = (value: Geometry): value is LineString =>\n  value.type === \"LineString\";\n\nconst isMultiLineString = (value: Geometry): value is MultiLineString =>\n  value.type === \"MultiLineString\";\n\nconst isPoint = (value: Geometry): value is Point => value.type === \"Point\";\n\nconst isMultiPoint = (value: Geometry): value is MultiPoint =>\n  value.type === \"MultiPoint\";\n\nconst isLineStringClosed = (lineString: LineString): boolean => {\n  const coords = lineString.coordinates;\n  if (coords.length < 4) return false; // Need at least 4 points for a closed ring\n\n  const first = coords[0];\n  const last = coords[coords.length - 1];\n\n  if (!first || !last || first.length < 2 || last.length < 2) return false;\n\n  const firstLon = first[0];\n  const firstLat = first[1];\n  const lastLon = last[0];\n  const lastLat = last[1];\n\n  if (\n    firstLon === undefined ||\n    firstLat === undefined ||\n    lastLon === undefined ||\n    lastLat === undefined\n  ) {\n    return false;\n  }\n\n  // Check if first and last points are the same (with small tolerance for floating point)\n  const tolerance = 1e-10;\n  return (\n    Math.abs(firstLon - lastLon) < tolerance &&\n    Math.abs(firstLat - lastLat) < tolerance\n  );\n};\n\nconst lineStringToPolygon = (lineString: LineString): Polygon | null => {\n  if (!isLineStringClosed(lineString)) return null;\n\n  // Convert closed LineString to Polygon\n  // A Polygon is an array of LinearRings, where the first is the exterior ring\n  return {\n    type: \"Polygon\",\n    coordinates: [lineString.coordinates],\n  };\n};\n\nconst toFeature = (geometry: Geometry): Feature<Geometry> => ({\n  type: \"Feature\",\n  geometry,\n  properties: {},\n});\n\nexport const extractPolygonFeatures = (\n  input: GeoJsonObject\n): Feature<Polygon | MultiPolygon>[] => {\n  if (isFeatureCollection(input)) {\n    return input.features.flatMap((feature) => extractPolygonFeatures(feature));\n  }\n\n  if (isFeature(input)) {\n    const geometry = input.geometry;\n    if (!geometry) return [];\n\n    if (isGeometryCollection(geometry)) {\n      return geometry.geometries.flatMap((subGeometry) =>\n        extractPolygonFeatures(toFeature(subGeometry))\n      );\n    }\n\n    if (isPolygon(geometry) || isMultiPolygon(geometry)) {\n      return [input as Feature<Polygon | MultiPolygon>];\n    }\n\n    return [];\n  }\n\n  const geometry = input as Geometry;\n\n  if (isGeometryCollection(geometry)) {\n    return geometry.geometries.flatMap((subGeometry) =>\n      extractPolygonFeatures(toFeature(subGeometry))\n    );\n  }\n\n  if (isPolygon(geometry) || isMultiPolygon(geometry)) {\n    return [toFeature(geometry) as Feature<Polygon | MultiPolygon>];\n  }\n\n  return [];\n};\n\nexport const extractLineStringFeatures = (\n  input: GeoJsonObject\n): Feature<LineString | MultiLineString>[] => {\n  if (isFeatureCollection(input)) {\n    return input.features.flatMap((feature) =>\n      extractLineStringFeatures(feature)\n    );\n  }\n\n  if (isFeature(input)) {\n    const geometry = input.geometry;\n    if (!geometry) return [];\n\n    if (isGeometryCollection(geometry)) {\n      return geometry.geometries.flatMap((subGeometry) =>\n        extractLineStringFeatures(toFeature(subGeometry))\n      );\n    }\n\n    if (isLineString(geometry) || isMultiLineString(geometry)) {\n      return [input as Feature<LineString | MultiLineString>];\n    }\n\n    return [];\n  }\n\n  const geometry = input as Geometry;\n\n  if (isGeometryCollection(geometry)) {\n    return geometry.geometries.flatMap((subGeometry) =>\n      extractLineStringFeatures(toFeature(subGeometry))\n    );\n  }\n\n  if (isLineString(geometry) || isMultiLineString(geometry)) {\n    return [toFeature(geometry) as Feature<LineString | MultiLineString>];\n  }\n\n  return [];\n};\n\nexport const extractPointFeatures = (\n  input: GeoJsonObject\n): Feature<Point | MultiPoint>[] => {\n  if (isFeatureCollection(input)) {\n    return input.features.flatMap((feature) => extractPointFeatures(feature));\n  }\n\n  if (isFeature(input)) {\n    const geometry = input.geometry;\n    if (!geometry) return [];\n\n    if (isGeometryCollection(geometry)) {\n      return geometry.geometries.flatMap((subGeometry) =>\n        extractPointFeatures(toFeature(subGeometry))\n      );\n    }\n\n    if (isPoint(geometry) || isMultiPoint(geometry)) {\n      return [input as Feature<Point | MultiPoint>];\n    }\n\n    return [];\n  }\n\n  const geometry = input as Geometry;\n\n  if (isGeometryCollection(geometry)) {\n    return geometry.geometries.flatMap((subGeometry) =>\n      extractPointFeatures(toFeature(subGeometry))\n    );\n  }\n\n  if (isPoint(geometry) || isMultiPoint(geometry)) {\n    return [toFeature(geometry) as Feature<Point | MultiPoint>];\n  }\n\n  return [];\n};\n\nconst computeCentroid = (\n  features: Feature<Polygon | MultiPolygon>[]\n): Position | null => {\n  if (features.length === 0) return null;\n\n  const collection = featureCollection(features);\n\n  try {\n    const { geometry } = centerOfMass(collection);\n    return geometry.coordinates;\n  } catch {\n    try {\n      const { geometry } = turfCentroid(collection);\n      return geometry.coordinates;\n    } catch {\n      return null;\n    }\n  }\n};\n\nconst computeCentroidForLineStrings = (\n  features: Feature<LineString | MultiLineString>[]\n): Position | null => {\n  if (features.length === 0) return null;\n\n  const collection = featureCollection(features);\n\n  try {\n    const { geometry } = centerOfMass(collection);\n    return geometry.coordinates;\n  } catch {\n    try {\n      const { geometry } = turfCentroid(collection);\n      return geometry.coordinates;\n    } catch {\n      return null;\n    }\n  }\n};\n\nconst computeCentroidForPoints = (\n  features: Feature<Point | MultiPoint>[]\n): Position | null => {\n  if (features.length === 0) return null;\n\n  const collection = featureCollection(features);\n\n  try {\n    const { geometry } = centerOfMass(collection);\n    return geometry.coordinates;\n  } catch {\n    try {\n      const { geometry } = turfCentroid(collection);\n      return geometry.coordinates;\n    } catch {\n      return null;\n    }\n  }\n};\n\nconst computeCentroidForMixed = (\n  features: Feature<Geometry>[]\n): Position | null => {\n  if (features.length === 0) return null;\n\n  const collection = featureCollection(features);\n\n  try {\n    const { geometry } = centerOfMass(collection);\n    return geometry.coordinates;\n  } catch {\n    try {\n      const { geometry } = turfCentroid(collection);\n      return geometry.coordinates;\n    } catch {\n      return null;\n    }\n  }\n};\n\nexport const computePolygonMetrics = (\n  geoJson: GeoJsonObject\n): PolygonMetrics => {\n  const polygonFeatures = extractPolygonFeatures(geoJson);\n  const lineStringFeatures = extractLineStringFeatures(geoJson);\n  const pointFeatures = extractPointFeatures(geoJson);\n\n  // Try to convert closed LineStrings to Polygons\n  const convertedPolygons: Feature<Polygon>[] = [];\n  for (const lineStringFeature of lineStringFeatures) {\n    if (lineStringFeature.geometry.type === \"LineString\") {\n      const polygon = lineStringToPolygon(lineStringFeature.geometry);\n      if (polygon) {\n        convertedPolygons.push({\n          type: \"Feature\",\n          geometry: polygon,\n          properties: lineStringFeature.properties,\n        });\n      }\n    } else if (lineStringFeature.geometry.type === \"MultiLineString\") {\n      // Handle MultiLineString - convert each closed LineString\n      for (const lineString of lineStringFeature.geometry.coordinates) {\n        const ls: LineString = { type: \"LineString\", coordinates: lineString };\n        const polygon = lineStringToPolygon(ls);\n        if (polygon) {\n          convertedPolygons.push({\n            type: \"Feature\",\n            geometry: polygon,\n            properties: lineStringFeature.properties,\n          });\n        }\n      }\n    }\n  }\n\n  // Combine original polygons with converted ones\n  const allPolygonFeatures = [...polygonFeatures, ...convertedPolygons];\n\n  // Handle Point geometries only\n  if (\n    pointFeatures.length > 0 &&\n    allPolygonFeatures.length === 0 &&\n    lineStringFeatures.length === 0\n  ) {\n    const centroidPosition = computeCentroidForPoints(pointFeatures);\n    const bbox = turfBbox(featureCollection(pointFeatures)) as [\n      number,\n      number,\n      number,\n      number\n    ];\n\n    let centroid: Coordinates | null = null;\n\n    if (\n      centroidPosition &&\n      centroidPosition[0] !== undefined &&\n      centroidPosition[1] !== undefined\n    ) {\n      const [lon, lat] = centroidPosition;\n      centroid = { lat, lon };\n    }\n\n    return {\n      areaSqMeters: null,\n      areaHectares: null,\n      centroid,\n      bbox,\n      message: centroid ? \"Success (Point)\" : \"Centroid calculation failed\",\n    };\n  }\n\n  // Handle LineString geometries (including closed ones that were converted)\n  if (lineStringFeatures.length > 0 && allPolygonFeatures.length === 0) {\n    const lengthMeters = lineStringFeatures.reduce(\n      (acc, feature) => acc + turfLength(feature, { units: \"meters\" }),\n      0\n    );\n\n    const centroidPosition = computeCentroidForLineStrings(lineStringFeatures);\n    const bbox = turfBbox(featureCollection(lineStringFeatures)) as [\n      number,\n      number,\n      number,\n      number\n    ];\n\n    let centroid: Coordinates | null = null;\n\n    if (\n      centroidPosition &&\n      centroidPosition[0] !== undefined &&\n      centroidPosition[1] !== undefined\n    ) {\n      const [lon, lat] = centroidPosition;\n      centroid = { lat, lon };\n    }\n\n    return {\n      areaSqMeters: null,\n      areaHectares: null,\n      centroid,\n      bbox,\n      message: centroid\n        ? \"Success (LineString)\"\n        : \"Centroid calculation failed\",\n    };\n  }\n\n  // Handle mixed geometries (Polygon, LineString, and/or Point)\n  const hasPolygons = allPolygonFeatures.length > 0;\n  const hasLineStrings = lineStringFeatures.length > 0;\n  const hasPoints = pointFeatures.length > 0;\n  const geometryTypeCount =\n    (hasPolygons ? 1 : 0) + (hasLineStrings ? 1 : 0) + (hasPoints ? 1 : 0);\n\n  if (geometryTypeCount > 1) {\n    const areaSqMeters = allPolygonFeatures.reduce(\n      (acc, feature) => acc + turfArea(feature),\n      0\n    );\n\n    const allFeatures = [\n      ...allPolygonFeatures,\n      ...lineStringFeatures,\n      ...pointFeatures,\n    ] as Feature<Geometry>[];\n\n    const centroidPosition = computeCentroidForMixed(allFeatures);\n    const bbox = turfBbox(featureCollection(allFeatures)) as [\n      number,\n      number,\n      number,\n      number\n    ];\n\n    let centroid: Coordinates | null = null;\n\n    if (\n      centroidPosition &&\n      centroidPosition[0] !== undefined &&\n      centroidPosition[1] !== undefined\n    ) {\n      const [lon, lat] = centroidPosition;\n      centroid = { lat, lon };\n    }\n\n    const typeLabels = [];\n    if (hasPolygons) typeLabels.push(\"Polygon\");\n    if (hasLineStrings) typeLabels.push(\"LineString\");\n    if (hasPoints) typeLabels.push(\"Point\");\n\n    return {\n      areaSqMeters,\n      areaHectares: areaSqMeters * HECTARES_PER_SQUARE_METER,\n      centroid,\n      bbox,\n      message: centroid\n        ? `Success (mixed: ${typeLabels.join(\", \")})`\n        : \"Centroid calculation failed\",\n    };\n  }\n\n  // Handle Polygon geometries only (including converted closed LineStrings)\n  if (\n    allPolygonFeatures.length === 0 &&\n    lineStringFeatures.length === 0 &&\n    pointFeatures.length === 0\n  ) {\n    return {\n      areaSqMeters: null,\n      areaHectares: null,\n      centroid: null,\n      bbox: null,\n      message: \"No polygons found\",\n    };\n  }\n\n  const areaSqMeters = allPolygonFeatures.reduce(\n    (acc, feature) => acc + turfArea(feature),\n    0\n  );\n\n  const centroidPosition = computeCentroid(allPolygonFeatures);\n  const bbox = turfBbox(featureCollection(allPolygonFeatures)) as [\n    number,\n    number,\n    number,\n    number\n  ];\n\n  let centroid: Coordinates | null = null;\n\n  if (\n    centroidPosition &&\n    centroidPosition[0] !== undefined &&\n    centroidPosition[1] !== undefined\n  ) {\n    const [lon, lat] = centroidPosition;\n    centroid = { lat, lon };\n  }\n\n  return {\n    areaSqMeters,\n    areaHectares: areaSqMeters * HECTARES_PER_SQUARE_METER,\n    centroid,\n    bbox,\n    message: centroid ? \"Success\" : \"Centroid calculation failed\",\n  };\n};\n\nexport const toFeatureCollection = (\n  geoJson: GeoJsonObject\n): FeatureCollection => {\n  if (isFeatureCollection(geoJson)) return geoJson;\n\n  if (isFeature(geoJson)) {\n    return featureCollection([geoJson]);\n  }\n\n  return featureCollection([toFeature(geoJson as Geometry)]);\n};\n","import type { GeoJsonObject } from \"geojson\";\n\n/**\n * Validates if an unknown object is a valid GeoJSON object.\n * @param value - The value to validate\n * @returns The validated GeoJSON object\n * @throws Error if the value is not a valid GeoJSON object\n */\nexport function validateGeojsonOrThrow(value: unknown): GeoJsonObject {\n  if (value === null || typeof value !== \"object\") {\n    throw new Error(\"GeoJSON must be an object\");\n  }\n\n  const obj = value as Record<string, unknown>;\n\n  if (!(\"type\" in obj) || typeof obj.type !== \"string\") {\n    throw new Error(\"GeoJSON must have a 'type' property of type string\");\n  }\n\n  const type = obj.type;\n\n  // Validate FeatureCollection\n  if (type === \"FeatureCollection\") {\n    if (!(\"features\" in obj) || !Array.isArray(obj.features)) {\n      throw new Error(\n        \"FeatureCollection must have a 'features' property of type array\"\n      );\n    }\n\n    // Validate each feature in the collection\n    for (let i = 0; i < obj.features.length; i++) {\n      try {\n        validateGeojsonOrThrow(obj.features[i]);\n      } catch (error) {\n        throw new Error(\n          `FeatureCollection.features[${i}] is invalid: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    }\n\n    return obj as unknown as GeoJsonObject;\n  }\n\n  // Validate Feature\n  if (type === \"Feature\") {\n    if (!(\"geometry\" in obj)) {\n      throw new Error(\"Feature must have a 'geometry' property\");\n    }\n\n    if (obj.geometry !== null) {\n      try {\n        validateGeometry(obj.geometry);\n      } catch (error) {\n        throw new Error(\n          `Feature.geometry is invalid: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    }\n\n    if (!(\"properties\" in obj)) {\n      throw new Error(\"Feature must have a 'properties' property\");\n    }\n\n    if (obj.properties !== null && typeof obj.properties !== \"object\") {\n      throw new Error(\"Feature.properties must be an object or null\");\n    }\n\n    return obj as unknown as GeoJsonObject;\n  }\n\n  // Validate Geometry types\n  try {\n    validateGeometry(obj);\n    return obj as unknown as GeoJsonObject;\n  } catch (error) {\n    throw new Error(\n      `Invalid GeoJSON type '${type}': ${error instanceof Error ? error.message : String(error)}`\n    );\n  }\n}\n\n/**\n * Validates a GeoJSON geometry object\n */\nfunction validateGeometry(value: unknown): void {\n  if (value === null || typeof value !== \"object\") {\n    throw new Error(\"Geometry must be an object\");\n  }\n\n  const geometry = value as Record<string, unknown>;\n\n  if (!(\"type\" in geometry) || typeof geometry.type !== \"string\") {\n    throw new Error(\"Geometry must have a 'type' property of type string\");\n  }\n\n  const type = geometry.type;\n\n  // Validate GeometryCollection\n  if (type === \"GeometryCollection\") {\n    if (!(\"geometries\" in geometry) || !Array.isArray(geometry.geometries)) {\n      throw new Error(\n        \"GeometryCollection must have a 'geometries' property of type array\"\n      );\n    }\n\n    for (let i = 0; i < geometry.geometries.length; i++) {\n      try {\n        validateGeometry(geometry.geometries[i]);\n      } catch (error) {\n        throw new Error(\n          `GeometryCollection.geometries[${i}] is invalid: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    }\n\n    return;\n  }\n\n  // Validate coordinates-based geometries\n  const coordinateGeometries = [\n    \"Point\",\n    \"LineString\",\n    \"Polygon\",\n    \"MultiPoint\",\n    \"MultiLineString\",\n    \"MultiPolygon\",\n  ];\n\n  if (coordinateGeometries.includes(type)) {\n    if (!(\"coordinates\" in geometry)) {\n      throw new Error(`${type} must have a 'coordinates' property`);\n    }\n\n    validateCoordinates(geometry.coordinates, type);\n    return;\n  }\n\n  throw new Error(`Unknown geometry type: ${type}`);\n}\n\n/**\n * Validates coordinates based on geometry type\n */\nfunction validateCoordinates(coordinates: unknown, type: string): void {\n  if (!Array.isArray(coordinates)) {\n    throw new Error(\"Coordinates must be an array\");\n  }\n\n  switch (type) {\n    case \"Point\":\n      validatePosition(coordinates);\n      break;\n    case \"LineString\":\n      validateLineString(coordinates);\n      break;\n    case \"Polygon\":\n      validatePolygon(coordinates);\n      break;\n    case \"MultiPoint\":\n      validateMultiPoint(coordinates);\n      break;\n    case \"MultiLineString\":\n      validateMultiLineString(coordinates);\n      break;\n    case \"MultiPolygon\":\n      validateMultiPolygon(coordinates);\n      break;\n  }\n}\n\n/**\n * Validates a Position (longitude, latitude, optional elevation)\n */\nfunction validatePosition(value: unknown): void {\n  if (!Array.isArray(value)) {\n    throw new Error(\"Position must be an array\");\n  }\n\n  if (value.length < 2) {\n    throw new Error(\n      \"Position must have at least 2 elements (longitude, latitude)\"\n    );\n  }\n\n  if (typeof value[0] !== \"number\" || typeof value[1] !== \"number\") {\n    throw new Error(\"Position must have numbers for longitude and latitude\");\n  }\n\n  // Validate optional elevation\n  if (value.length > 2 && typeof value[2] !== \"number\") {\n    throw new Error(\n      \"Position elevation (3rd element) must be a number if present\"\n    );\n  }\n\n  // Validate longitude range\n  if (value[0] < -180 || value[0] > 180) {\n    throw new Error(\"Longitude must be between -180 and 180\");\n  }\n\n  // Validate latitude range\n  if (value[1] < -90 || value[1] > 90) {\n    throw new Error(\"Latitude must be between -90 and 90\");\n  }\n}\n\n/**\n * Validates a LineString (array of Positions)\n */\nfunction validateLineString(value: unknown): void {\n  if (!Array.isArray(value)) {\n    throw new Error(\"LineString must be an array\");\n  }\n\n  if (value.length < 2) {\n    throw new Error(\"LineString must have at least 2 positions\");\n  }\n\n  for (let i = 0; i < value.length; i++) {\n    try {\n      validatePosition(value[i]);\n    } catch (error) {\n      throw new Error(\n        `LineString[${i}] is invalid: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n}\n\n/**\n * Validates a Polygon (array of LinearRings, where first is exterior and rest are holes)\n */\nfunction validatePolygon(value: unknown): void {\n  if (!Array.isArray(value)) {\n    throw new Error(\"Polygon must be an array\");\n  }\n\n  if (value.length === 0) {\n    throw new Error(\"Polygon must have at least one LinearRing\");\n  }\n\n  for (let i = 0; i < value.length; i++) {\n    try {\n      validateLinearRing(value[i]);\n    } catch (error) {\n      throw new Error(\n        `Polygon[${i}] is invalid: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n}\n\n/**\n * Validates a LinearRing (closed LineString with at least 4 positions)\n */\nfunction validateLinearRing(value: unknown): void {\n  if (!Array.isArray(value)) {\n    throw new Error(\"LinearRing must be an array\");\n  }\n\n  if (value.length < 4) {\n    throw new Error(\"LinearRing must have at least 4 positions\");\n  }\n\n  // Validate all positions\n  for (let i = 0; i < value.length; i++) {\n    try {\n      validatePosition(value[i]);\n    } catch (error) {\n      throw new Error(\n        `LinearRing[${i}] is invalid: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  // Check if ring is closed (first and last positions are the same)\n  const first = value[0] as number[];\n  const last = value[value.length - 1] as number[];\n  if (\n    first[0] !== last[0] ||\n    first[1] !== last[1] ||\n    (first.length > 2 && first[2] !== last[2])\n  ) {\n    throw new Error(\n      \"LinearRing must be closed (first and last positions must be equal)\"\n    );\n  }\n}\n\n/**\n * Validates a MultiPoint (array of Positions)\n */\nfunction validateMultiPoint(value: unknown): void {\n  if (!Array.isArray(value)) {\n    throw new Error(\"MultiPoint must be an array\");\n  }\n\n  for (let i = 0; i < value.length; i++) {\n    try {\n      validatePosition(value[i]);\n    } catch (error) {\n      throw new Error(\n        `MultiPoint[${i}] is invalid: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n}\n\n/**\n * Validates a MultiLineString (array of LineStrings)\n */\nfunction validateMultiLineString(value: unknown): void {\n  if (!Array.isArray(value)) {\n    throw new Error(\"MultiLineString must be an array\");\n  }\n\n  for (let i = 0; i < value.length; i++) {\n    try {\n      validateLineString(value[i]);\n    } catch (error) {\n      throw new Error(\n        `MultiLineString[${i}] is invalid: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n}\n\n/**\n * Validates a MultiPolygon (array of Polygons)\n */\nfunction validateMultiPolygon(value: unknown): void {\n  if (!Array.isArray(value)) {\n    throw new Error(\"MultiPolygon must be an array\");\n  }\n\n  for (let i = 0; i < value.length; i++) {\n    try {\n      validatePolygon(value[i]);\n    } catch (error) {\n      throw new Error(\n        `MultiPolygon[${i}] is invalid: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n}\n"]}