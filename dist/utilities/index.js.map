{"version":3,"sources":["../../src/utilities/getBlobUrl.ts","../../src/utilities/parseAtUri.ts","../../src/lib/geojson/validate.ts"],"sourcesContent":["import {\n  type LargeBlob,\n  type LargeImage,\n  type SmallBlob,\n  type SmallImage,\n  type Uri,\n} from \"@/../lex-api/types/app/gainforest/common/defs\";\nimport type { $Typed } from \"@/../lex-api/util\";\nimport type { BlobRefGenerator } from \"@/zod-schemas/blobref\";\nimport { BlobRef } from \"@atproto/api\";\nimport { SupportedPDSDomain } from \"..\";\n\nconst getBlobUrl = <T extends SupportedPDSDomain>(\n  did: string,\n  imageData:\n    | string\n    | BlobRef\n    | BlobRefGenerator\n    | $Typed<Uri | SmallImage | LargeImage | SmallBlob | LargeBlob>\n    | Uri\n    | SmallImage\n    | LargeImage\n    | SmallBlob\n    | LargeBlob,\n  pdsDomain: T\n) => {\n  if (typeof imageData === \"string\") {\n    const imageUrl = new URL(imageData);\n    return imageUrl.toString();\n  }\n\n  const isBlobRef =\n    imageData instanceof BlobRef ||\n    (\"ref\" in imageData && \"mimeType\" in imageData && \"size\" in imageData);\n  if (isBlobRef) {\n    const ref = imageData.ref as unknown as { $link?: string } | string;\n    const cid = typeof ref === \"string\" ? ref : (ref?.$link ?? String(ref));\n    const encodedCid = encodeURIComponent(cid);\n    return `https://${pdsDomain}/xrpc/com.atproto.sync.getBlob?did=${did}&cid=${encodedCid}`;\n  }\n\n  // Handle $Typed cases\n  if (imageData.$type === \"app.gainforest.common.defs#uri\") {\n    const uri = imageData.uri;\n    // TODO: handle other URI types\n    // if (uri.startsWith(\"at://\")) {\n    //   const { did: uriDid, rkey: uriRkey } = parseAtUri(uri);\n    //   return `${PDS_URL}/xrpc/com.atproto.repo.getRecord?did=${uriDid}&rkey=${uriRkey}`;\n    // }\n    return uri;\n  }\n\n  if (\n    imageData.$type === \"app.gainforest.common.defs#smallBlob\" ||\n    imageData.$type === \"app.gainforest.common.defs#largeBlob\"\n  ) {\n    const blob = imageData.blob;\n    return getBlobUrl(did, blob, pdsDomain);\n  }\n\n  if (\n    imageData.$type === \"app.gainforest.common.defs#smallImage\" ||\n    imageData.$type === \"app.gainforest.common.defs#largeImage\"\n  ) {\n    const image = imageData.image;\n    return getBlobUrl(did, image, pdsDomain);\n  }\n\n  if (\"blob\" in imageData) {\n    const blob = imageData.blob;\n    return getBlobUrl(did, blob, pdsDomain);\n  }\n\n  if (\"image\" in imageData) {\n    const image = imageData.image;\n    return getBlobUrl(did, image, pdsDomain);\n  }\n\n  if (\"uri\" in imageData) {\n    const uri = imageData.uri;\n    return uri;\n  }\n\n  // Line for compile time check that all cases are handled. THIS SHOULD NEVER BE REACHED.\n  const imageDataTypeCheck = imageData satisfies never;\n  return imageDataTypeCheck;\n};\n\nexport default getBlobUrl;\n","const parseAtUri = (atUri: string) => {\n  const cleanedAtUri = atUri.replace(\"at://\", \"\");\n  const [did, ...rest] = cleanedAtUri.split(\"/\");\n  let rkey = rest.at(-1) ?? \"\";\n  return { did, rkey };\n};\n\nexport default parseAtUri;\n","import type { GeoJsonObject } from \"geojson\";\n\n/**\n * Validates if an unknown object is a valid GeoJSON object.\n * @param value - The value to validate\n * @returns The validated GeoJSON object\n * @throws Error if the value is not a valid GeoJSON object\n */\nexport function validateGeojsonOrThrow(value: unknown): GeoJsonObject {\n  if (value === null || typeof value !== \"object\") {\n    throw new Error(\"GeoJSON must be an object\");\n  }\n\n  const obj = value as Record<string, unknown>;\n\n  if (!(\"type\" in obj) || typeof obj.type !== \"string\") {\n    throw new Error(\"GeoJSON must have a 'type' property of type string\");\n  }\n\n  const type = obj.type;\n\n  // Validate FeatureCollection\n  if (type === \"FeatureCollection\") {\n    if (!(\"features\" in obj) || !Array.isArray(obj.features)) {\n      throw new Error(\n        \"FeatureCollection must have a 'features' property of type array\"\n      );\n    }\n\n    // Validate each feature in the collection\n    for (let i = 0; i < obj.features.length; i++) {\n      try {\n        validateGeojsonOrThrow(obj.features[i]);\n      } catch (error) {\n        throw new Error(\n          `FeatureCollection.features[${i}] is invalid: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    }\n\n    return obj as unknown as GeoJsonObject;\n  }\n\n  // Validate Feature\n  if (type === \"Feature\") {\n    if (!(\"geometry\" in obj)) {\n      throw new Error(\"Feature must have a 'geometry' property\");\n    }\n\n    if (obj.geometry !== null) {\n      try {\n        validateGeometry(obj.geometry);\n      } catch (error) {\n        throw new Error(\n          `Feature.geometry is invalid: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    }\n\n    if (!(\"properties\" in obj)) {\n      throw new Error(\"Feature must have a 'properties' property\");\n    }\n\n    if (obj.properties !== null && typeof obj.properties !== \"object\") {\n      throw new Error(\"Feature.properties must be an object or null\");\n    }\n\n    return obj as unknown as GeoJsonObject;\n  }\n\n  // Validate Geometry types\n  try {\n    validateGeometry(obj);\n    return obj as unknown as GeoJsonObject;\n  } catch (error) {\n    throw new Error(\n      `Invalid GeoJSON type '${type}': ${error instanceof Error ? error.message : String(error)}`\n    );\n  }\n}\n\n/**\n * Validates a GeoJSON geometry object\n */\nfunction validateGeometry(value: unknown): void {\n  if (value === null || typeof value !== \"object\") {\n    throw new Error(\"Geometry must be an object\");\n  }\n\n  const geometry = value as Record<string, unknown>;\n\n  if (!(\"type\" in geometry) || typeof geometry.type !== \"string\") {\n    throw new Error(\"Geometry must have a 'type' property of type string\");\n  }\n\n  const type = geometry.type;\n\n  // Validate GeometryCollection\n  if (type === \"GeometryCollection\") {\n    if (!(\"geometries\" in geometry) || !Array.isArray(geometry.geometries)) {\n      throw new Error(\n        \"GeometryCollection must have a 'geometries' property of type array\"\n      );\n    }\n\n    for (let i = 0; i < geometry.geometries.length; i++) {\n      try {\n        validateGeometry(geometry.geometries[i]);\n      } catch (error) {\n        throw new Error(\n          `GeometryCollection.geometries[${i}] is invalid: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    }\n\n    return;\n  }\n\n  // Validate coordinates-based geometries\n  const coordinateGeometries = [\n    \"Point\",\n    \"LineString\",\n    \"Polygon\",\n    \"MultiPoint\",\n    \"MultiLineString\",\n    \"MultiPolygon\",\n  ];\n\n  if (coordinateGeometries.includes(type)) {\n    if (!(\"coordinates\" in geometry)) {\n      throw new Error(`${type} must have a 'coordinates' property`);\n    }\n\n    validateCoordinates(geometry.coordinates, type);\n    return;\n  }\n\n  throw new Error(`Unknown geometry type: ${type}`);\n}\n\n/**\n * Validates coordinates based on geometry type\n */\nfunction validateCoordinates(coordinates: unknown, type: string): void {\n  if (!Array.isArray(coordinates)) {\n    throw new Error(\"Coordinates must be an array\");\n  }\n\n  switch (type) {\n    case \"Point\":\n      validatePosition(coordinates);\n      break;\n    case \"LineString\":\n      validateLineString(coordinates);\n      break;\n    case \"Polygon\":\n      validatePolygon(coordinates);\n      break;\n    case \"MultiPoint\":\n      validateMultiPoint(coordinates);\n      break;\n    case \"MultiLineString\":\n      validateMultiLineString(coordinates);\n      break;\n    case \"MultiPolygon\":\n      validateMultiPolygon(coordinates);\n      break;\n  }\n}\n\n/**\n * Validates a Position (longitude, latitude, optional elevation)\n */\nfunction validatePosition(value: unknown): void {\n  if (!Array.isArray(value)) {\n    throw new Error(\"Position must be an array\");\n  }\n\n  if (value.length < 2) {\n    throw new Error(\n      \"Position must have at least 2 elements (longitude, latitude)\"\n    );\n  }\n\n  if (typeof value[0] !== \"number\" || typeof value[1] !== \"number\") {\n    throw new Error(\"Position must have numbers for longitude and latitude\");\n  }\n\n  // Validate optional elevation\n  if (value.length > 2 && typeof value[2] !== \"number\") {\n    throw new Error(\n      \"Position elevation (3rd element) must be a number if present\"\n    );\n  }\n\n  // Validate longitude range\n  if (value[0] < -180 || value[0] > 180) {\n    throw new Error(\"Longitude must be between -180 and 180\");\n  }\n\n  // Validate latitude range\n  if (value[1] < -90 || value[1] > 90) {\n    throw new Error(\"Latitude must be between -90 and 90\");\n  }\n}\n\n/**\n * Validates a LineString (array of Positions)\n */\nfunction validateLineString(value: unknown): void {\n  if (!Array.isArray(value)) {\n    throw new Error(\"LineString must be an array\");\n  }\n\n  if (value.length < 2) {\n    throw new Error(\"LineString must have at least 2 positions\");\n  }\n\n  for (let i = 0; i < value.length; i++) {\n    try {\n      validatePosition(value[i]);\n    } catch (error) {\n      throw new Error(\n        `LineString[${i}] is invalid: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n}\n\n/**\n * Validates a Polygon (array of LinearRings, where first is exterior and rest are holes)\n */\nfunction validatePolygon(value: unknown): void {\n  if (!Array.isArray(value)) {\n    throw new Error(\"Polygon must be an array\");\n  }\n\n  if (value.length === 0) {\n    throw new Error(\"Polygon must have at least one LinearRing\");\n  }\n\n  for (let i = 0; i < value.length; i++) {\n    try {\n      validateLinearRing(value[i]);\n    } catch (error) {\n      throw new Error(\n        `Polygon[${i}] is invalid: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n}\n\n/**\n * Validates a LinearRing (closed LineString with at least 4 positions)\n */\nfunction validateLinearRing(value: unknown): void {\n  if (!Array.isArray(value)) {\n    throw new Error(\"LinearRing must be an array\");\n  }\n\n  if (value.length < 4) {\n    throw new Error(\"LinearRing must have at least 4 positions\");\n  }\n\n  // Validate all positions\n  for (let i = 0; i < value.length; i++) {\n    try {\n      validatePosition(value[i]);\n    } catch (error) {\n      throw new Error(\n        `LinearRing[${i}] is invalid: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  // Check if ring is closed (first and last positions are the same)\n  const first = value[0] as number[];\n  const last = value[value.length - 1] as number[];\n  if (\n    first[0] !== last[0] ||\n    first[1] !== last[1] ||\n    (first.length > 2 && first[2] !== last[2])\n  ) {\n    throw new Error(\n      \"LinearRing must be closed (first and last positions must be equal)\"\n    );\n  }\n}\n\n/**\n * Validates a MultiPoint (array of Positions)\n */\nfunction validateMultiPoint(value: unknown): void {\n  if (!Array.isArray(value)) {\n    throw new Error(\"MultiPoint must be an array\");\n  }\n\n  for (let i = 0; i < value.length; i++) {\n    try {\n      validatePosition(value[i]);\n    } catch (error) {\n      throw new Error(\n        `MultiPoint[${i}] is invalid: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n}\n\n/**\n * Validates a MultiLineString (array of LineStrings)\n */\nfunction validateMultiLineString(value: unknown): void {\n  if (!Array.isArray(value)) {\n    throw new Error(\"MultiLineString must be an array\");\n  }\n\n  for (let i = 0; i < value.length; i++) {\n    try {\n      validateLineString(value[i]);\n    } catch (error) {\n      throw new Error(\n        `MultiLineString[${i}] is invalid: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n}\n\n/**\n * Validates a MultiPolygon (array of Polygons)\n */\nfunction validateMultiPolygon(value: unknown): void {\n  if (!Array.isArray(value)) {\n    throw new Error(\"MultiPolygon must be an array\");\n  }\n\n  for (let i = 0; i < value.length; i++) {\n    try {\n      validatePolygon(value[i]);\n    } catch (error) {\n      throw new Error(\n        `MultiPolygon[${i}] is invalid: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n}\n"],"mappings":"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","names":[]}