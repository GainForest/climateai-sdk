{"version":3,"sources":["../src/_internal/server/routers/atproto/auth/resume.ts","../src/_internal/server/session.ts"],"names":["CredentialSession","jwtVerify","cookies"],"mappings":";;;;;;;;;AAuBO,IAAM,uBAAA,GAA0B,CACrC,OAAA,EACA,WAAA,KACG;AACH,EAAA,MAAM,oBAAoB,IAAIA,qBAAA;AAAA,IAC5B,IAAI,GAAA,CAAI,CAAA,QAAA,EAAW,OAAO,CAAA,CAAE;AAAA,GAC9B;AAEA,EAAA,OAAO,kBAAkB,aAAA,CAAc;AAAA,IACrC,WAAW,WAAA,CAAY,SAAA;AAAA,IACvB,YAAY,WAAA,CAAY,UAAA;AAAA,IACxB,QAAQ,WAAA,CAAY,MAAA;AAAA,IACpB,KAAK,WAAA,CAAY,GAAA;AAAA,IACjB,MAAA,EAAQ;AAAA,GACT,CAAA;AACH;;;ACzBA,IAAM,UAAA,GAAa,IAAI,WAAA,EAAY,CAAE,MAAA;AAAA,EACnC,OAAA,CAAQ,IAAI,aAAA,IAAiB;AAC/B,CAAA;AAUA,eAAe,QAAQ,KAAA,EAA8C;AACnE,EAAA,IAAI;AACF,IAAA,MAAM,EAAE,OAAA,EAAQ,GAAI,MAAMC,cAAA,CAAU,OAAO,UAAU,CAAA;AACrD,IAAA,OAAO,OAAA;AAAA,EACT,CAAA,CAAA,MAAQ;AACN,IAAA,OAAO,IAAA;AAAA,EACT;AACF;AAEA,eAAsB,qBAAA,CACpB,UAA8B,eAAA,EACC;AAC/B,EAAA,MAAM,WAAA,GAAc,MAAMC,eAAA,EAAQ;AAClC,EAAA,MAAM,gBAAA,GAAmB,WAAA,CAAY,GAAA,CAAI,CAAA,EAAG,OAAO,CAAA,QAAA,CAAU,CAAA;AAE7D,EAAA,IAAI,CAAC,gBAAA,EAAkB;AACrB,IAAA,OAAO,IAAA;AAAA,EACT;AAEA,EAAA,OAAO,MAAM,OAAA,CAAQ,gBAAA,CAAiB,KAAK,CAAA;AAC7C","file":"session.cjs","sourcesContent":["import { type SupportedPDSDomain } from \"@/_internal/index\";\nimport { tryCatch } from \"@/_internal/lib/tryCatch\";\nimport {\n  getSessionFromRequest,\n  StoredSession,\n} from \"@/_internal/server/session\";\nimport { publicProcedure } from \"@/_internal/server/trpc\";\nimport { CredentialSession } from \"@atproto/api\";\nimport { TRPCError } from \"@trpc/server\";\nimport z from \"zod\";\n\n/**\n * Result of a successful session resume\n */\nexport type ResumeResult = {\n  did: string;\n  handle: string;\n  service: SupportedPDSDomain;\n};\n\n/**\n * Helper to create a credential session from stored session data.\n */\nexport const resumeCredentialSession = (\n  service: SupportedPDSDomain,\n  sessionData: StoredSession\n) => {\n  const credentialSession = new CredentialSession(\n    new URL(`https://${service}`)\n  );\n\n  return credentialSession.resumeSession({\n    accessJwt: sessionData.accessJwt,\n    refreshJwt: sessionData.refreshJwt,\n    handle: sessionData.handle,\n    did: sessionData.did,\n    active: true,\n  });\n};\n\n/**\n * Pure function to resume a session.\n * Can be reused outside of tRPC context.\n */\nexport const resumePure = async <T extends SupportedPDSDomain>(\n  service: T\n): Promise<ResumeResult> => {\n  const session = await getSessionFromRequest(service);\n\n  if (!session) {\n    throw new TRPCError({\n      code: \"UNAUTHORIZED\",\n      message: \"No active session found. Please log in.\",\n    });\n  }\n\n  const credentialSession = new CredentialSession(\n    new URL(`https://${service}`)\n  );\n\n  const [resumeSessionResult, resumeSessionError] = await tryCatch(\n    credentialSession.resumeSession({\n      accessJwt: session.accessJwt,\n      refreshJwt: session.refreshJwt,\n      handle: session.handle,\n      did: session.did,\n      active: true,\n    })\n  );\n\n  if (resumeSessionError !== null) {\n    throw new TRPCError({\n      code: \"UNAUTHORIZED\",\n      message: \"Failed to resume session. Please log in again.\",\n      cause: resumeSessionError,\n    });\n  }\n\n  if (resumeSessionResult === null || !resumeSessionResult.success) {\n    throw new TRPCError({\n      code: \"UNAUTHORIZED\",\n      message: \"Failed to resume session. Please log in again.\",\n    });\n  }\n\n  return {\n    did: resumeSessionResult.data.did,\n    handle: resumeSessionResult.data.handle,\n    service: service,\n  };\n};\n\n/**\n * Factory to create the tRPC procedure for resuming a session.\n */\nexport const resumeFactory = <T extends SupportedPDSDomain>(\n  allowedPDSDomainSchema: z.ZodEnum<Record<T, T>>\n) => {\n  return publicProcedure\n    .input(\n      z.object({\n        service: allowedPDSDomainSchema,\n      })\n    )\n    .query(async ({ input }) => {\n      return resumePure(input.service);\n    });\n};\n","import { cookies } from \"next/headers\";\nimport { SignJWT, jwtVerify } from \"jose\";\nimport type { JwtPayload } from \"@atproto/oauth-client-node\";\nimport type { SupportedPDSDomain } from \"@/_internal/index\";\nimport { resumeCredentialSession } from \"./routers/atproto/auth/resume\";\n\nexport interface StoredSession extends JwtPayload {\n  accessJwt: string;\n  refreshJwt: string;\n  did: string;\n  handle: string;\n}\n\nconst SECRET_KEY = new TextEncoder().encode(\n  process.env.COOKIE_SECRET || \"your-secret-key-min-32-chars-long\"\n);\n\nasync function encrypt(payload: StoredSession): Promise<string> {\n  return await new SignJWT(payload)\n    .setProtectedHeader({ alg: \"HS256\" })\n    .setIssuedAt()\n    .setExpirationTime(\"30d\")\n    .sign(SECRET_KEY);\n}\n\nasync function decrypt(token: string): Promise<StoredSession | null> {\n  try {\n    const { payload } = await jwtVerify(token, SECRET_KEY);\n    return payload as StoredSession;\n  } catch {\n    return null;\n  }\n}\n\nexport async function getSessionFromRequest(\n  service: SupportedPDSDomain = \"climateai.org\"\n): Promise<StoredSession | null> {\n  const cookieStore = await cookies();\n  const encryptedSession = cookieStore.get(`${service}_session`);\n\n  if (!encryptedSession) {\n    return null;\n  }\n\n  return await decrypt(encryptedSession.value);\n}\n\nexport { resumeCredentialSession } from \"./../server/routers/atproto/auth/resume\";\n\nexport async function saveSession(\n  session: StoredSession,\n  service: SupportedPDSDomain = \"climateai.org\"\n) {\n  const cookieStore = await cookies();\n  const encrypted = await encrypt(session);\n\n  cookieStore.set(`${service}_session`, encrypted, {\n    httpOnly: true,\n    secure: process.env.NODE_ENV === \"production\",\n    sameSite: \"lax\",\n    maxAge: 60 * 60 * 24 * 30,\n    path: \"/\",\n  });\n\n  return encrypted;\n}\n\nexport async function clearSession(\n  service: SupportedPDSDomain = \"climateai.org\"\n) {\n  const cookieStore = await cookies();\n  cookieStore.delete(`${service}_session`);\n}\n"]}