{"version":3,"sources":["../node_modules/@atproto/xrpc/src/types.ts","../node_modules/@atproto/xrpc/src/util.ts","../node_modules/@atproto/xrpc/src/fetch-handler.ts","../node_modules/@atproto/xrpc/src/xrpc-client.ts","../node_modules/@atproto/xrpc/src/client.ts","../node_modules/@atproto/xrpc/src/index.ts","../src/index.ts","../src/utilities/getBlobUrl.ts","../src/utilities/parseAtUri.ts","../src/lib/geojson/validate.ts","../src/server/trpc.ts","../src/server/session.ts","../src/utilities/transformer.ts","../src/zod-schemas/blobref.ts","../src/lib/isObject.ts","../src/server/routers/atproto/common/uploadFileAsBlob.ts","../src/server/utils/agent.ts","../src/zod-schemas/file.ts","../src/server/routers/atproto/auth/login.ts","../src/server/routers/atproto/auth/resume.ts","../src/server/routers/atproto/auth/logout.ts","../src/server/routers/atproto/gainforest/organizationInfo/get.ts","../src/lib/tryCatch.ts","../lex-api/index.ts","../lex-api/lexicons.ts","../lex-api/util.ts","../lex-api/types/app/certified/location.ts","../lex-api/types/org/hypercerts/claim/claim.ts","../lex-api/types/org/hypercerts/claim/contribution.ts","../lex-api/types/app/gainforest/organization/defaultSite.ts","../lex-api/types/app/gainforest/organization/info.ts","../lex-api/types/app/gainforest/organization/measuredTrees.ts","../lex-api/types/app/gainforest/organization/site.ts","../src/server/utils/classify-xrpc-error.ts","../src/server/utils/validate-record-or-throw.ts","../src/server/routers/atproto/gainforest/site/get.ts","../src/server/routers/atproto/gainforest/site/getDefault.ts","../src/server/routers/atproto/gainforest/measuredTrees/get.ts","../src/server/routers/atproto/hypercerts/claim/create.ts","../src/server/routers/atproto/gainforest/organizationInfo/createOrUpdate.ts","../src/server/routers/atproto/gainforest/site/getAll.ts","../src/server/routers/atproto/gainforest/site/create.ts","../src/server/routers/atproto/gainforest/site/utils.ts","../src/lib/geojson/computations.ts","../src/server/routers/atproto/gainforest/site/update.ts","../src/server/routers/atproto/gainforest/site/setDefault.ts","../src/server/routers/atproto/gainforest/site/delete.ts","../src/server/routers/atproto/hypercerts/claim/getAllAcrossOrgs.ts","../src/server/routers/atproto/hypercerts/claim/getAll.ts","../src/server/routers/atproto/hypercerts/claim/get.ts","../src/server/routers/atproto/hypercerts/location/get.ts","../src/server/routers/_app.ts"],"sourcesContent":["import { z } from 'zod'\nimport { ValidationError } from '@atproto/lexicon'\n\nexport type QueryParams = Record<string, any>\nexport type HeadersMap = Record<string, string | undefined>\n\nexport type {\n  /** @deprecated not to be confused with the WHATWG Headers constructor */\n  HeadersMap as Headers,\n}\n\nexport type Gettable<T> = T | (() => T)\n\nexport interface CallOptions {\n  encoding?: string\n  signal?: AbortSignal\n  headers?: HeadersMap\n}\n\nexport const errorResponseBody = z.object({\n  error: z.string().optional(),\n  message: z.string().optional(),\n})\nexport type ErrorResponseBody = z.infer<typeof errorResponseBody>\n\nexport enum ResponseType {\n  /**\n   * Network issue, unable to get response from the server.\n   */\n  Unknown = 1,\n  /**\n   * Response failed lexicon validation.\n   */\n  InvalidResponse = 2,\n  Success = 200,\n  InvalidRequest = 400,\n  AuthenticationRequired = 401,\n  Forbidden = 403,\n  XRPCNotSupported = 404,\n  NotAcceptable = 406,\n  PayloadTooLarge = 413,\n  UnsupportedMediaType = 415,\n  RateLimitExceeded = 429,\n  InternalServerError = 500,\n  MethodNotImplemented = 501,\n  UpstreamFailure = 502,\n  NotEnoughResources = 503,\n  UpstreamTimeout = 504,\n}\n\nexport function httpResponseCodeToEnum(status: number): ResponseType {\n  if (status in ResponseType) {\n    return status\n  } else if (status >= 100 && status < 200) {\n    return ResponseType.XRPCNotSupported\n  } else if (status >= 200 && status < 300) {\n    return ResponseType.Success\n  } else if (status >= 300 && status < 400) {\n    return ResponseType.XRPCNotSupported\n  } else if (status >= 400 && status < 500) {\n    return ResponseType.InvalidRequest\n  } else {\n    return ResponseType.InternalServerError\n  }\n}\n\nexport function httpResponseCodeToName(status: number): string {\n  return ResponseType[httpResponseCodeToEnum(status)]\n}\n\nexport const ResponseTypeStrings = {\n  [ResponseType.Unknown]: 'Unknown',\n  [ResponseType.InvalidResponse]: 'Invalid Response',\n  [ResponseType.Success]: 'Success',\n  [ResponseType.InvalidRequest]: 'Invalid Request',\n  [ResponseType.AuthenticationRequired]: 'Authentication Required',\n  [ResponseType.Forbidden]: 'Forbidden',\n  [ResponseType.XRPCNotSupported]: 'XRPC Not Supported',\n  [ResponseType.NotAcceptable]: 'Not Acceptable',\n  [ResponseType.PayloadTooLarge]: 'Payload Too Large',\n  [ResponseType.UnsupportedMediaType]: 'Unsupported Media Type',\n  [ResponseType.RateLimitExceeded]: 'Rate Limit Exceeded',\n  [ResponseType.InternalServerError]: 'Internal Server Error',\n  [ResponseType.MethodNotImplemented]: 'Method Not Implemented',\n  [ResponseType.UpstreamFailure]: 'Upstream Failure',\n  [ResponseType.NotEnoughResources]: 'Not Enough Resources',\n  [ResponseType.UpstreamTimeout]: 'Upstream Timeout',\n} as const satisfies Record<ResponseType, string>\n\nexport function httpResponseCodeToString(status: number): string {\n  return ResponseTypeStrings[httpResponseCodeToEnum(status)]\n}\n\nexport class XRPCResponse {\n  success = true\n\n  constructor(\n    public data: any,\n    public headers: HeadersMap,\n  ) {}\n}\n\nexport class XRPCError extends Error {\n  success = false\n\n  public status: ResponseType\n\n  constructor(\n    statusCode: number,\n    public error: string = httpResponseCodeToName(statusCode),\n    message?: string,\n    public headers?: HeadersMap,\n    options?: ErrorOptions,\n  ) {\n    super(message || error || httpResponseCodeToString(statusCode), options)\n\n    this.status = httpResponseCodeToEnum(statusCode)\n\n    // Pre 2022 runtimes won't handle the \"options\" constructor argument\n    const cause = options?.cause\n    if (this.cause === undefined && cause !== undefined) {\n      this.cause = cause\n    }\n  }\n\n  static from(cause: unknown, fallbackStatus?: ResponseType): XRPCError {\n    if (cause instanceof XRPCError) {\n      return cause\n    }\n\n    // Type cast the cause to an Error if it is one\n    const causeErr = cause instanceof Error ? cause : undefined\n\n    // Try and find a Response object in the cause\n    const causeResponse: Response | undefined =\n      cause instanceof Response\n        ? cause\n        : cause?.['response'] instanceof Response\n          ? cause['response']\n          : undefined\n\n    const statusCode: unknown =\n      // Extract status code from \"http-errors\" like errors\n      causeErr?.['statusCode'] ??\n      causeErr?.['status'] ??\n      // Use the status code from the response object as fallback\n      causeResponse?.status\n\n    // Convert the status code to a ResponseType\n    const status: ResponseType =\n      typeof statusCode === 'number'\n        ? httpResponseCodeToEnum(statusCode)\n        : fallbackStatus ?? ResponseType.Unknown\n\n    const message = causeErr?.message ?? String(cause)\n\n    const headers = causeResponse\n      ? Object.fromEntries(causeResponse.headers.entries())\n      : undefined\n\n    return new XRPCError(status, undefined, message, headers, { cause })\n  }\n}\n\nexport class XRPCInvalidResponseError extends XRPCError {\n  constructor(\n    public lexiconNsid: string,\n    public validationError: ValidationError,\n    public responseBody: unknown,\n  ) {\n    super(\n      ResponseType.InvalidResponse,\n      // @NOTE: This is probably wrong and should use ResponseTypeNames instead.\n      // But it would mean a breaking change.\n      ResponseTypeStrings[ResponseType.InvalidResponse],\n      `The server gave an invalid response and may be out of date.`,\n      undefined,\n      { cause: validationError },\n    )\n  }\n}\n","import {\n  LexXrpcProcedure,\n  LexXrpcQuery,\n  jsonStringToLex,\n  stringifyLex,\n} from '@atproto/lexicon'\nimport {\n  CallOptions,\n  ErrorResponseBody,\n  Gettable,\n  QueryParams,\n  ResponseType,\n  XRPCError,\n  errorResponseBody,\n} from './types'\n\nconst ReadableStream =\n  globalThis.ReadableStream ||\n  (class {\n    constructor() {\n      // This anonymous class will never pass any \"instanceof\" check and cannot\n      // be instantiated.\n      throw new Error('ReadableStream is not supported in this environment')\n    }\n  } as typeof globalThis.ReadableStream)\n\nexport function isErrorResponseBody(v: unknown): v is ErrorResponseBody {\n  return errorResponseBody.safeParse(v).success\n}\n\nexport function getMethodSchemaHTTPMethod(\n  schema: LexXrpcProcedure | LexXrpcQuery,\n) {\n  if (schema.type === 'procedure') {\n    return 'post'\n  }\n  return 'get'\n}\n\nexport function constructMethodCallUri(\n  nsid: string,\n  schema: LexXrpcProcedure | LexXrpcQuery,\n  serviceUri: URL,\n  params?: QueryParams,\n): string {\n  const uri = new URL(constructMethodCallUrl(nsid, schema, params), serviceUri)\n  return uri.toString()\n}\n\nexport function constructMethodCallUrl(\n  nsid: string,\n  schema: LexXrpcProcedure | LexXrpcQuery,\n  params?: QueryParams,\n): string {\n  const pathname = `/xrpc/${encodeURIComponent(nsid)}`\n  if (!params) return pathname\n\n  const searchParams: [string, string][] = []\n\n  for (const [key, value] of Object.entries(params)) {\n    const paramSchema = schema.parameters?.properties?.[key]\n    if (!paramSchema) {\n      throw new Error(`Invalid query parameter: ${key}`)\n    }\n    if (value !== undefined) {\n      if (paramSchema.type === 'array') {\n        const values = Array.isArray(value) ? value : [value]\n        for (const val of values) {\n          searchParams.push([\n            key,\n            encodeQueryParam(paramSchema.items.type, val),\n          ])\n        }\n      } else {\n        searchParams.push([key, encodeQueryParam(paramSchema.type, value)])\n      }\n    }\n  }\n\n  if (!searchParams.length) return pathname\n\n  return `${pathname}?${new URLSearchParams(searchParams).toString()}`\n}\n\nexport function encodeQueryParam(\n  type:\n    | 'string'\n    | 'float'\n    | 'integer'\n    | 'boolean'\n    | 'datetime'\n    | 'array'\n    | 'unknown',\n  value: any,\n): string {\n  if (type === 'string' || type === 'unknown') {\n    return String(value)\n  }\n  if (type === 'float') {\n    return String(Number(value))\n  } else if (type === 'integer') {\n    return String(Number(value) | 0)\n  } else if (type === 'boolean') {\n    return value ? 'true' : 'false'\n  } else if (type === 'datetime') {\n    if (value instanceof Date) {\n      return value.toISOString()\n    }\n    return String(value)\n  }\n  throw new Error(`Unsupported query param type: ${type}`)\n}\n\nexport function constructMethodCallHeaders(\n  schema: LexXrpcProcedure | LexXrpcQuery,\n  data?: unknown,\n  opts?: CallOptions,\n): Headers {\n  // Not using `new Headers(opts?.headers)` to avoid duplicating headers values\n  // due to inconsistent casing in headers name. In case of multiple headers\n  // with the same name (but using a different case), the last one will be used.\n\n  // new Headers({ 'content-type': 'foo', 'Content-Type': 'bar' }).get('content-type')\n  // => 'foo, bar'\n  const headers = new Headers()\n\n  if (opts?.headers) {\n    for (const name in opts.headers) {\n      if (headers.has(name)) {\n        throw new TypeError(`Duplicate header: ${name}`)\n      }\n\n      const value = opts.headers[name]\n      if (value != null) {\n        headers.set(name, value)\n      }\n    }\n  }\n\n  if (schema.type === 'procedure') {\n    if (opts?.encoding) {\n      headers.set('content-type', opts.encoding)\n    } else if (!headers.has('content-type') && typeof data !== 'undefined') {\n      // Special handling of BodyInit types before falling back to JSON encoding\n      if (\n        data instanceof ArrayBuffer ||\n        data instanceof ReadableStream ||\n        ArrayBuffer.isView(data)\n      ) {\n        headers.set('content-type', 'application/octet-stream')\n      } else if (data instanceof FormData) {\n        // Note: The multipart form data boundary is missing from the header\n        // we set here, making that header invalid. This special case will be\n        // handled in encodeMethodCallBody()\n        headers.set('content-type', 'multipart/form-data')\n      } else if (data instanceof URLSearchParams) {\n        headers.set(\n          'content-type',\n          'application/x-www-form-urlencoded;charset=UTF-8',\n        )\n      } else if (isBlobLike(data)) {\n        headers.set('content-type', data.type || 'application/octet-stream')\n      } else if (typeof data === 'string') {\n        headers.set('content-type', 'text/plain;charset=UTF-8')\n      }\n      // At this point, data is not a valid BodyInit type.\n      else if (isIterable(data)) {\n        headers.set('content-type', 'application/octet-stream')\n      } else if (\n        typeof data === 'boolean' ||\n        typeof data === 'number' ||\n        typeof data === 'string' ||\n        typeof data === 'object' // covers \"null\"\n      ) {\n        headers.set('content-type', 'application/json')\n      } else {\n        // symbol, function, bigint\n        throw new XRPCError(\n          ResponseType.InvalidRequest,\n          `Unsupported data type: ${typeof data}`,\n        )\n      }\n    }\n  }\n  return headers\n}\n\nexport function combineHeaders(\n  headersInit: undefined | HeadersInit,\n  defaultHeaders?: Iterable<[string, undefined | Gettable<null | string>]>,\n): undefined | HeadersInit {\n  if (!defaultHeaders) return headersInit\n\n  let headers: Headers | undefined = undefined\n\n  for (const [name, definition] of defaultHeaders) {\n    // Ignore undefined values (allowed for convenience when using\n    // Object.entries).\n    if (definition === undefined) continue\n\n    // Lazy initialization of the headers object\n    headers ??= new Headers(headersInit)\n\n    if (headers.has(name)) continue\n\n    const value = typeof definition === 'function' ? definition() : definition\n\n    if (typeof value === 'string') headers.set(name, value)\n    else if (value === null) headers.delete(name)\n    else throw new TypeError(`Invalid \"${name}\" header value: ${typeof value}`)\n  }\n\n  return headers ?? headersInit\n}\n\nfunction isBlobLike(value: unknown): value is Blob {\n  if (value == null) return false\n  if (typeof value !== 'object') return false\n  if (typeof Blob === 'function' && value instanceof Blob) return true\n\n  // Support for Blobs provided by libraries that don't use the native Blob\n  // (e.g. fetch-blob from node-fetch).\n  // https://github.com/node-fetch/fetch-blob/blob/a1a182e5978811407bef4ea1632b517567dda01f/index.js#L233-L244\n\n  const tag = value[Symbol.toStringTag]\n  if (tag === 'Blob' || tag === 'File') {\n    return 'stream' in value && typeof value.stream === 'function'\n  }\n\n  return false\n}\n\nexport function isBodyInit(value: unknown): value is BodyInit {\n  switch (typeof value) {\n    case 'string':\n      return true\n    case 'object':\n      return (\n        value instanceof ArrayBuffer ||\n        value instanceof FormData ||\n        value instanceof URLSearchParams ||\n        value instanceof ReadableStream ||\n        ArrayBuffer.isView(value) ||\n        isBlobLike(value)\n      )\n    default:\n      return false\n  }\n}\n\nexport function isIterable(\n  value: unknown,\n): value is Iterable<unknown> | AsyncIterable<unknown> {\n  return (\n    value != null &&\n    typeof value === 'object' &&\n    (Symbol.iterator in value || Symbol.asyncIterator in value)\n  )\n}\n\nexport function encodeMethodCallBody(\n  headers: Headers,\n  data?: unknown,\n): BodyInit | undefined {\n  // Silently ignore the body if there is no content-type header.\n  const contentType = headers.get('content-type')\n  if (!contentType) {\n    return undefined\n  }\n\n  if (typeof data === 'undefined') {\n    // This error would be returned by the server, but we can catch it earlier\n    // to avoid un-necessary requests. Note that a content-length of 0 does not\n    // necessary mean that the body is \"empty\" (e.g. an empty txt file).\n    throw new XRPCError(\n      ResponseType.InvalidRequest,\n      `A request body is expected but none was provided`,\n    )\n  }\n\n  if (isBodyInit(data)) {\n    if (data instanceof FormData && contentType === 'multipart/form-data') {\n      // fetch() will encode FormData payload itself, but it won't override the\n      // content-type header if already present. This would cause the boundary\n      // to be missing from the content-type header, resulting in a 400 error.\n      // Deleting the content-type header here to let fetch() re-create it.\n      headers.delete('content-type')\n    }\n\n    // Will be encoded by the fetch API.\n    return data\n  }\n\n  if (isIterable(data)) {\n    // Note that some environments support using Iterable & AsyncIterable as the\n    // body (e.g. Node's fetch), but not all of them do (browsers).\n    return iterableToReadableStream(data)\n  }\n\n  if (contentType.startsWith('text/')) {\n    return new TextEncoder().encode(String(data))\n  }\n  if (contentType.startsWith('application/json')) {\n    const json = stringifyLex(data)\n    // Server would return a 400 error if the JSON is invalid (e.g. trying to\n    // JSONify a function, or an object that implements toJSON() poorly).\n    if (json === undefined) {\n      throw new XRPCError(\n        ResponseType.InvalidRequest,\n        `Failed to encode request body as JSON`,\n      )\n    }\n    return new TextEncoder().encode(json)\n  }\n\n  // At this point, \"data\" is not a valid BodyInit value, and we don't know how\n  // to encode it into one. Passing it to fetch would result in an error. Let's\n  // throw our own error instead.\n\n  const type =\n    !data || typeof data !== 'object'\n      ? typeof data\n      : data.constructor !== Object &&\n          typeof data.constructor === 'function' &&\n          typeof data.constructor?.name === 'string'\n        ? data.constructor.name\n        : 'object'\n\n  throw new XRPCError(\n    ResponseType.InvalidRequest,\n    `Unable to encode ${type} as ${contentType} data`,\n  )\n}\n\n/**\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/from_static}\n */\nfunction iterableToReadableStream(\n  iterable: Iterable<unknown> | AsyncIterable<unknown>,\n): ReadableStream<Uint8Array> {\n  // Use the native ReadableStream.from() if available.\n  if ('from' in ReadableStream && typeof ReadableStream.from === 'function') {\n    return ReadableStream.from(iterable)\n  }\n\n  // If you see this error, consider using a polyfill for ReadableStream. For\n  // example, the \"web-streams-polyfill\" package:\n  // https://github.com/MattiasBuelens/web-streams-polyfill\n\n  throw new TypeError(\n    'ReadableStream.from() is not supported in this environment. ' +\n      'It is required to support using iterables as the request body. ' +\n      'Consider using a polyfill or re-write your code to use a different body type.',\n  )\n}\n\nexport function httpResponseBodyParse(\n  mimeType: string | null,\n  data: ArrayBuffer | undefined,\n): any {\n  try {\n    if (mimeType) {\n      if (mimeType.includes('application/json')) {\n        const str = new TextDecoder().decode(data)\n        return jsonStringToLex(str)\n      }\n      if (mimeType.startsWith('text/')) {\n        return new TextDecoder().decode(data)\n      }\n    }\n    if (data instanceof ArrayBuffer) {\n      return new Uint8Array(data)\n    }\n    return data\n  } catch (cause) {\n    throw new XRPCError(\n      ResponseType.InvalidResponse,\n      undefined,\n      `Failed to parse response body: ${String(cause)}`,\n      undefined,\n      { cause },\n    )\n  }\n}\n","import { Gettable } from './types'\nimport { combineHeaders } from './util'\n\nexport type FetchHandler = (\n  this: void,\n  /**\n   * The URL (pathname + query parameters) to make the request to, without the\n   * origin. The origin (protocol, hostname, and port) must be added by this\n   * {@link FetchHandler}, typically based on authentication or other factors.\n   */\n  url: string,\n  init: RequestInit,\n) => Promise<Response>\n\nexport type FetchHandlerOptions = BuildFetchHandlerOptions | string | URL\n\nexport type BuildFetchHandlerOptions = {\n  /**\n   * The service URL to make requests to. This can be a string, URL, or a\n   * function that returns a string or URL. This is useful for dynamic URLs,\n   * such as a service URL that changes based on authentication.\n   */\n  service: Gettable<string | URL>\n\n  /**\n   * Headers to be added to every request. If a function is provided, it will be\n   * called on each request to get the headers. This is useful for dynamic\n   * headers, such as authentication tokens that may expire.\n   */\n  headers?: {\n    [_ in string]?: Gettable<null | string>\n  }\n\n  /**\n   * Bring your own fetch implementation. Typically useful for testing, logging,\n   * mocking, or adding retries, session management, signatures, proof of\n   * possession (DPoP), SSRF protection, etc. Defaults to the global `fetch`\n   * function.\n   */\n  fetch?: typeof globalThis.fetch\n}\n\nexport interface FetchHandlerObject {\n  fetchHandler: (\n    this: FetchHandlerObject,\n    /**\n     * The URL (pathname + query parameters) to make the request to, without the\n     * origin. The origin (protocol, hostname, and port) must be added by this\n     * {@link FetchHandler}, typically based on authentication or other factors.\n     */\n    url: string,\n    init: RequestInit,\n  ) => Promise<Response>\n}\n\nexport function buildFetchHandler(\n  options: FetchHandler | FetchHandlerObject | FetchHandlerOptions,\n): FetchHandler {\n  // Already a fetch handler (allowed for convenience)\n  if (typeof options === 'function') return options\n  if (typeof options === 'object' && 'fetchHandler' in options) {\n    return options.fetchHandler.bind(options)\n  }\n\n  const {\n    service,\n    headers: defaultHeaders = undefined,\n    fetch = globalThis.fetch,\n  } = typeof options === 'string' || options instanceof URL\n    ? { service: options }\n    : options\n\n  if (typeof fetch !== 'function') {\n    throw new TypeError(\n      'XrpcDispatcher requires fetch() to be available in your environment.',\n    )\n  }\n\n  const defaultHeadersEntries =\n    defaultHeaders != null ? Object.entries(defaultHeaders) : undefined\n\n  return async function (url, init) {\n    const base = typeof service === 'function' ? service() : service\n    const fullUrl = new URL(url, base)\n\n    const headers = combineHeaders(init.headers, defaultHeadersEntries)\n\n    return fetch(fullUrl, { ...init, headers })\n  }\n}\n","import { LexiconDoc, Lexicons, ValidationError } from '@atproto/lexicon'\nimport {\n  FetchHandler,\n  FetchHandlerObject,\n  FetchHandlerOptions,\n  buildFetchHandler,\n} from './fetch-handler'\nimport {\n  CallOptions,\n  Gettable,\n  QueryParams,\n  ResponseType,\n  XRPCError,\n  XRPCInvalidResponseError,\n  XRPCResponse,\n  httpResponseCodeToEnum,\n} from './types'\nimport {\n  combineHeaders,\n  constructMethodCallHeaders,\n  constructMethodCallUrl,\n  encodeMethodCallBody,\n  getMethodSchemaHTTPMethod,\n  httpResponseBodyParse,\n  isErrorResponseBody,\n} from './util'\n\nexport class XrpcClient {\n  readonly fetchHandler: FetchHandler\n  readonly headers = new Map<string, Gettable<null | string>>()\n  readonly lex: Lexicons\n\n  constructor(\n    fetchHandlerOpts: FetchHandler | FetchHandlerObject | FetchHandlerOptions,\n    // \"Lexicons\" is redundant here (because that class implements\n    // \"Iterable<LexiconDoc>\") but we keep it for explicitness:\n    lex: Lexicons | Iterable<LexiconDoc>,\n  ) {\n    this.fetchHandler = buildFetchHandler(fetchHandlerOpts)\n\n    this.lex = lex instanceof Lexicons ? lex : new Lexicons(lex)\n  }\n\n  setHeader(key: string, value: Gettable<null | string>): void {\n    this.headers.set(key.toLowerCase(), value)\n  }\n\n  unsetHeader(key: string): void {\n    this.headers.delete(key.toLowerCase())\n  }\n\n  clearHeaders(): void {\n    this.headers.clear()\n  }\n\n  async call(\n    methodNsid: string,\n    params?: QueryParams,\n    data?: unknown,\n    opts?: CallOptions,\n  ): Promise<XRPCResponse> {\n    const def = this.lex.getDefOrThrow(methodNsid)\n    if (!def || (def.type !== 'query' && def.type !== 'procedure')) {\n      throw new TypeError(\n        `Invalid lexicon: ${methodNsid}. Must be a query or procedure.`,\n      )\n    }\n\n    // @TODO: should we validate the params and data here?\n    // this.lex.assertValidXrpcParams(methodNsid, params)\n    // if (data !== undefined) {\n    //   this.lex.assertValidXrpcInput(methodNsid, data)\n    // }\n\n    const reqUrl = constructMethodCallUrl(methodNsid, def, params)\n    const reqMethod = getMethodSchemaHTTPMethod(def)\n    const reqHeaders = constructMethodCallHeaders(def, data, opts)\n    const reqBody = encodeMethodCallBody(reqHeaders, data)\n\n    // The duplex field is required for streaming bodies, but not yet reflected\n    // anywhere in docs or types. See whatwg/fetch#1438, nodejs/node#46221.\n    const init: RequestInit & { duplex: 'half' } = {\n      method: reqMethod,\n      headers: combineHeaders(reqHeaders, this.headers),\n      body: reqBody,\n      duplex: 'half',\n      redirect: 'follow',\n      signal: opts?.signal,\n    }\n\n    try {\n      const response = await this.fetchHandler.call(undefined, reqUrl, init)\n\n      const resStatus = response.status\n      const resHeaders = Object.fromEntries(response.headers.entries())\n      const resBodyBytes = await response.arrayBuffer()\n      const resBody = httpResponseBodyParse(\n        response.headers.get('content-type'),\n        resBodyBytes,\n      )\n\n      const resCode = httpResponseCodeToEnum(resStatus)\n      if (resCode !== ResponseType.Success) {\n        const { error = undefined, message = undefined } =\n          resBody && isErrorResponseBody(resBody) ? resBody : {}\n        throw new XRPCError(resCode, error, message, resHeaders)\n      }\n\n      try {\n        this.lex.assertValidXrpcOutput(methodNsid, resBody)\n      } catch (e: unknown) {\n        if (e instanceof ValidationError) {\n          throw new XRPCInvalidResponseError(methodNsid, e, resBody)\n        }\n\n        throw e\n      }\n\n      return new XRPCResponse(resBody, resHeaders)\n    } catch (err) {\n      throw XRPCError.from(err)\n    }\n  }\n}\n","import { LexiconDoc, Lexicons } from '@atproto/lexicon'\nimport { CallOptions, QueryParams } from './types'\nimport { combineHeaders } from './util'\nimport { XrpcClient } from './xrpc-client'\n\n/** @deprecated Use {@link XrpcClient} instead */\nexport class Client {\n  /** @deprecated */\n  get fetch(): never {\n    throw new Error(\n      'Client.fetch is no longer supported. Use an XrpcClient instead.',\n    )\n  }\n\n  /** @deprecated */\n  set fetch(_: never) {\n    throw new Error(\n      'Client.fetch is no longer supported. Use an XrpcClient instead.',\n    )\n  }\n\n  lex = new Lexicons()\n\n  // method calls\n  //\n\n  async call(\n    serviceUri: string | URL,\n    methodNsid: string,\n    params?: QueryParams,\n    data?: BodyInit | null,\n    opts?: CallOptions,\n  ) {\n    return this.service(serviceUri).call(methodNsid, params, data, opts)\n  }\n\n  service(serviceUri: string | URL) {\n    return new ServiceClient(this, serviceUri)\n  }\n\n  // schemas\n  // =\n\n  addLexicon(doc: LexiconDoc) {\n    this.lex.add(doc)\n  }\n\n  addLexicons(docs: LexiconDoc[]) {\n    for (const doc of docs) {\n      this.addLexicon(doc)\n    }\n  }\n\n  removeLexicon(uri: string) {\n    this.lex.remove(uri)\n  }\n}\n\n/** @deprecated Use {@link XrpcClient} instead */\nexport class ServiceClient extends XrpcClient {\n  uri: URL\n\n  constructor(\n    public baseClient: Client,\n    serviceUri: string | URL,\n  ) {\n    super(async (input, init) => {\n      const headers = combineHeaders(init.headers, Object.entries(this.headers))\n      return fetch(new URL(input, this.uri), { ...init, headers })\n    }, baseClient.lex)\n    this.uri = typeof serviceUri === 'string' ? new URL(serviceUri) : serviceUri\n  }\n}\n","export * from './client'\nexport * from './fetch-handler'\nexport * from './types'\nexport * from './util'\nexport * from './xrpc-client'\n\n/* eslint-disable import/no-deprecated */\nimport { Client } from './client'\n/** @deprecated create a local {@link XrpcClient} instance instead */\nconst defaultInst = new Client()\nexport default defaultInst\n/* eslint-enable import/no-deprecated */\n","import { z } from \"zod\";\nimport { getBlobUrl, parseAtUri } from \"./utilities\";\nimport { AppRouterFactory, type AppRouter } from \"./server/routers/_app\";\n\nconst supportedDomains = [\"climateai.org\", \"hypercerts.org\"] as const;\nexport const supportedPDSDomainSchema = z.enum(supportedDomains);\nconst supportedPDSDomainsSchema = z.array(supportedPDSDomainSchema);\nexport type SupportedPDSDomain = (typeof supportedDomains)[number];\n\nexport class ClimateAiSDK<T extends SupportedPDSDomain> {\n  public allowedPDSDomains;\n  public appRouter;\n  public getServerCaller;\n  public utilities;\n\n  constructor(_allowedPDSDomains: T[]) {\n    if (!Array.isArray(_allowedPDSDomains)) {\n      throw new Error(\"Allowed domains must be an array\");\n    } else if (_allowedPDSDomains.length === 0) {\n      throw new Error(\"There should be at least one allowed domain\");\n    }\n    if (!supportedPDSDomainsSchema.safeParse(_allowedPDSDomains).success) {\n      throw new Error(\n        \"One of the domains is not supported. Supported domains are: \" +\n          supportedDomains.join(\", \") +\n          \". Received domains: \" +\n          JSON.stringify(_allowedPDSDomains, null, 2)\n      );\n    }\n    this.allowedPDSDomains = _allowedPDSDomains;\n    const appRouterFactory = new AppRouterFactory<T>(this.allowedPDSDomains);\n    this.appRouter = appRouterFactory.appRouter;\n    this.getServerCaller = appRouterFactory.getServerCaller;\n    this.utilities = {\n      getBlobUrl: getBlobUrl<T>,\n      parseAtUri,\n    };\n  }\n}\n\nexport type { AppRouter };\nexport { createContext } from \"./server/trpc\";\n","import {\n  type LargeBlob,\n  type LargeImage,\n  type SmallBlob,\n  type SmallImage,\n  type Uri,\n} from \"@/../lex-api/types/app/gainforest/common/defs\";\nimport type { $Typed } from \"@/../lex-api/util\";\nimport type { BlobRefGenerator } from \"@/zod-schemas/blobref\";\nimport { BlobRef } from \"@atproto/api\";\nimport { SupportedPDSDomain } from \"..\";\n\nconst getBlobUrl = <T extends SupportedPDSDomain>(\n  did: string,\n  imageData:\n    | string\n    | BlobRef\n    | BlobRefGenerator\n    | $Typed<Uri | SmallImage | LargeImage | SmallBlob | LargeBlob>\n    | Uri\n    | SmallImage\n    | LargeImage\n    | SmallBlob\n    | LargeBlob,\n  pdsDomain: T\n) => {\n  if (typeof imageData === \"string\") {\n    const imageUrl = new URL(imageData);\n    return imageUrl.toString();\n  }\n\n  const isBlobRef =\n    imageData instanceof BlobRef ||\n    (\"ref\" in imageData && \"mimeType\" in imageData && \"size\" in imageData);\n  if (isBlobRef) {\n    const ref = imageData.ref as unknown as { $link?: string } | string;\n    const cid = typeof ref === \"string\" ? ref : (ref?.$link ?? String(ref));\n    const encodedCid = encodeURIComponent(cid);\n    return `https://${pdsDomain}/xrpc/com.atproto.sync.getBlob?did=${did}&cid=${encodedCid}`;\n  }\n\n  // Handle $Typed cases\n  if (imageData.$type === \"app.gainforest.common.defs#uri\") {\n    const uri = imageData.uri;\n    // TODO: handle other URI types\n    // if (uri.startsWith(\"at://\")) {\n    //   const { did: uriDid, rkey: uriRkey } = parseAtUri(uri);\n    //   return `${PDS_URL}/xrpc/com.atproto.repo.getRecord?did=${uriDid}&rkey=${uriRkey}`;\n    // }\n    return uri;\n  }\n\n  if (\n    imageData.$type === \"app.gainforest.common.defs#smallBlob\" ||\n    imageData.$type === \"app.gainforest.common.defs#largeBlob\"\n  ) {\n    const blob = imageData.blob;\n    return getBlobUrl(did, blob, pdsDomain);\n  }\n\n  if (\n    imageData.$type === \"app.gainforest.common.defs#smallImage\" ||\n    imageData.$type === \"app.gainforest.common.defs#largeImage\"\n  ) {\n    const image = imageData.image;\n    return getBlobUrl(did, image, pdsDomain);\n  }\n\n  if (\"blob\" in imageData) {\n    const blob = imageData.blob;\n    return getBlobUrl(did, blob, pdsDomain);\n  }\n\n  if (\"image\" in imageData) {\n    const image = imageData.image;\n    return getBlobUrl(did, image, pdsDomain);\n  }\n\n  if (\"uri\" in imageData) {\n    const uri = imageData.uri;\n    return uri;\n  }\n\n  // Line for compile time check that all cases are handled. THIS SHOULD NEVER BE REACHED.\n  const imageDataTypeCheck = imageData satisfies never;\n  return imageDataTypeCheck;\n};\n\nexport default getBlobUrl;\n","const parseAtUri = (atUri: string) => {\n  let cleanedAtUri = atUri.replace(\"at://\", \"\");\n\n  const splitUri = cleanedAtUri.split(\"/\");\n\n  const did = splitUri.at(0) ?? \"\";\n  const collection = splitUri.at(1) ?? \"\";\n  const rkey = splitUri.at(2) ?? \"self\";\n\n  return { did, collection, rkey };\n};\n\nexport default parseAtUri;\n","import type { GeoJsonObject } from \"geojson\";\n\n/**\n * Validates if an unknown object is a valid GeoJSON object.\n * @param value - The value to validate\n * @returns The validated GeoJSON object\n * @throws Error if the value is not a valid GeoJSON object\n */\nexport function validateGeojsonOrThrow(value: unknown): GeoJsonObject {\n  if (value === null || typeof value !== \"object\") {\n    throw new Error(\"GeoJSON must be an object\");\n  }\n\n  const obj = value as Record<string, unknown>;\n\n  if (!(\"type\" in obj) || typeof obj.type !== \"string\") {\n    throw new Error(\"GeoJSON must have a 'type' property of type string\");\n  }\n\n  const type = obj.type;\n\n  // Validate FeatureCollection\n  if (type === \"FeatureCollection\") {\n    if (!(\"features\" in obj) || !Array.isArray(obj.features)) {\n      throw new Error(\n        \"FeatureCollection must have a 'features' property of type array\"\n      );\n    }\n\n    // Validate each feature in the collection\n    for (let i = 0; i < obj.features.length; i++) {\n      try {\n        validateGeojsonOrThrow(obj.features[i]);\n      } catch (error) {\n        throw new Error(\n          `FeatureCollection.features[${i}] is invalid: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    }\n\n    return obj as unknown as GeoJsonObject;\n  }\n\n  // Validate Feature\n  if (type === \"Feature\") {\n    if (!(\"geometry\" in obj)) {\n      throw new Error(\"Feature must have a 'geometry' property\");\n    }\n\n    if (obj.geometry !== null) {\n      try {\n        validateGeometry(obj.geometry);\n      } catch (error) {\n        throw new Error(\n          `Feature.geometry is invalid: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    }\n\n    if (!(\"properties\" in obj)) {\n      throw new Error(\"Feature must have a 'properties' property\");\n    }\n\n    if (obj.properties !== null && typeof obj.properties !== \"object\") {\n      throw new Error(\"Feature.properties must be an object or null\");\n    }\n\n    return obj as unknown as GeoJsonObject;\n  }\n\n  // Validate Geometry types\n  try {\n    validateGeometry(obj);\n    return obj as unknown as GeoJsonObject;\n  } catch (error) {\n    throw new Error(\n      `Invalid GeoJSON type '${type}': ${error instanceof Error ? error.message : String(error)}`\n    );\n  }\n}\n\n/**\n * Validates a GeoJSON geometry object\n */\nfunction validateGeometry(value: unknown): void {\n  if (value === null || typeof value !== \"object\") {\n    throw new Error(\"Geometry must be an object\");\n  }\n\n  const geometry = value as Record<string, unknown>;\n\n  if (!(\"type\" in geometry) || typeof geometry.type !== \"string\") {\n    throw new Error(\"Geometry must have a 'type' property of type string\");\n  }\n\n  const type = geometry.type;\n\n  // Validate GeometryCollection\n  if (type === \"GeometryCollection\") {\n    if (!(\"geometries\" in geometry) || !Array.isArray(geometry.geometries)) {\n      throw new Error(\n        \"GeometryCollection must have a 'geometries' property of type array\"\n      );\n    }\n\n    for (let i = 0; i < geometry.geometries.length; i++) {\n      try {\n        validateGeometry(geometry.geometries[i]);\n      } catch (error) {\n        throw new Error(\n          `GeometryCollection.geometries[${i}] is invalid: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    }\n\n    return;\n  }\n\n  // Validate coordinates-based geometries\n  const coordinateGeometries = [\n    \"Point\",\n    \"LineString\",\n    \"Polygon\",\n    \"MultiPoint\",\n    \"MultiLineString\",\n    \"MultiPolygon\",\n  ];\n\n  if (coordinateGeometries.includes(type)) {\n    if (!(\"coordinates\" in geometry)) {\n      throw new Error(`${type} must have a 'coordinates' property`);\n    }\n\n    validateCoordinates(geometry.coordinates, type);\n    return;\n  }\n\n  throw new Error(`Unknown geometry type: ${type}`);\n}\n\n/**\n * Validates coordinates based on geometry type\n */\nfunction validateCoordinates(coordinates: unknown, type: string): void {\n  if (!Array.isArray(coordinates)) {\n    throw new Error(\"Coordinates must be an array\");\n  }\n\n  switch (type) {\n    case \"Point\":\n      validatePosition(coordinates);\n      break;\n    case \"LineString\":\n      validateLineString(coordinates);\n      break;\n    case \"Polygon\":\n      validatePolygon(coordinates);\n      break;\n    case \"MultiPoint\":\n      validateMultiPoint(coordinates);\n      break;\n    case \"MultiLineString\":\n      validateMultiLineString(coordinates);\n      break;\n    case \"MultiPolygon\":\n      validateMultiPolygon(coordinates);\n      break;\n  }\n}\n\n/**\n * Validates a Position (longitude, latitude, optional elevation)\n */\nfunction validatePosition(value: unknown): void {\n  if (!Array.isArray(value)) {\n    throw new Error(\"Position must be an array\");\n  }\n\n  if (value.length < 2) {\n    throw new Error(\n      \"Position must have at least 2 elements (longitude, latitude)\"\n    );\n  }\n\n  if (typeof value[0] !== \"number\" || typeof value[1] !== \"number\") {\n    throw new Error(\"Position must have numbers for longitude and latitude\");\n  }\n\n  // Validate optional elevation\n  if (value.length > 2 && typeof value[2] !== \"number\") {\n    throw new Error(\n      \"Position elevation (3rd element) must be a number if present\"\n    );\n  }\n\n  // Validate longitude range\n  if (value[0] < -180 || value[0] > 180) {\n    throw new Error(\"Longitude must be between -180 and 180\");\n  }\n\n  // Validate latitude range\n  if (value[1] < -90 || value[1] > 90) {\n    throw new Error(\"Latitude must be between -90 and 90\");\n  }\n}\n\n/**\n * Validates a LineString (array of Positions)\n */\nfunction validateLineString(value: unknown): void {\n  if (!Array.isArray(value)) {\n    throw new Error(\"LineString must be an array\");\n  }\n\n  if (value.length < 2) {\n    throw new Error(\"LineString must have at least 2 positions\");\n  }\n\n  for (let i = 0; i < value.length; i++) {\n    try {\n      validatePosition(value[i]);\n    } catch (error) {\n      throw new Error(\n        `LineString[${i}] is invalid: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n}\n\n/**\n * Validates a Polygon (array of LinearRings, where first is exterior and rest are holes)\n */\nfunction validatePolygon(value: unknown): void {\n  if (!Array.isArray(value)) {\n    throw new Error(\"Polygon must be an array\");\n  }\n\n  if (value.length === 0) {\n    throw new Error(\"Polygon must have at least one LinearRing\");\n  }\n\n  for (let i = 0; i < value.length; i++) {\n    try {\n      validateLinearRing(value[i]);\n    } catch (error) {\n      throw new Error(\n        `Polygon[${i}] is invalid: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n}\n\n/**\n * Validates a LinearRing (closed LineString with at least 4 positions)\n */\nfunction validateLinearRing(value: unknown): void {\n  if (!Array.isArray(value)) {\n    throw new Error(\"LinearRing must be an array\");\n  }\n\n  if (value.length < 4) {\n    throw new Error(\"LinearRing must have at least 4 positions\");\n  }\n\n  // Validate all positions\n  for (let i = 0; i < value.length; i++) {\n    try {\n      validatePosition(value[i]);\n    } catch (error) {\n      throw new Error(\n        `LinearRing[${i}] is invalid: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n\n  // Check if ring is closed (first and last positions are the same)\n  const first = value[0] as number[];\n  const last = value[value.length - 1] as number[];\n  if (\n    first[0] !== last[0] ||\n    first[1] !== last[1] ||\n    (first.length > 2 && first[2] !== last[2])\n  ) {\n    throw new Error(\n      \"LinearRing must be closed (first and last positions must be equal)\"\n    );\n  }\n}\n\n/**\n * Validates a MultiPoint (array of Positions)\n */\nfunction validateMultiPoint(value: unknown): void {\n  if (!Array.isArray(value)) {\n    throw new Error(\"MultiPoint must be an array\");\n  }\n\n  for (let i = 0; i < value.length; i++) {\n    try {\n      validatePosition(value[i]);\n    } catch (error) {\n      throw new Error(\n        `MultiPoint[${i}] is invalid: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n}\n\n/**\n * Validates a MultiLineString (array of LineStrings)\n */\nfunction validateMultiLineString(value: unknown): void {\n  if (!Array.isArray(value)) {\n    throw new Error(\"MultiLineString must be an array\");\n  }\n\n  for (let i = 0; i < value.length; i++) {\n    try {\n      validateLineString(value[i]);\n    } catch (error) {\n      throw new Error(\n        `MultiLineString[${i}] is invalid: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n}\n\n/**\n * Validates a MultiPolygon (array of Polygons)\n */\nfunction validateMultiPolygon(value: unknown): void {\n  if (!Array.isArray(value)) {\n    throw new Error(\"MultiPolygon must be an array\");\n  }\n\n  for (let i = 0; i < value.length; i++) {\n    try {\n      validatePolygon(value[i]);\n    } catch (error) {\n      throw new Error(\n        `MultiPolygon[${i}] is invalid: ${error instanceof Error ? error.message : String(error)}`\n      );\n    }\n  }\n}\n","import { initTRPC, TRPCError } from \"@trpc/server\";\nimport { getSessionFromRequest } from \"./session\";\nimport { customTransformer } from \"../utilities/transformer\";\nimport type { SupportedPDSDomain } from \"@/index\";\n\nexport async function createContext<T extends SupportedPDSDomain>(opts?: {\n  req?: Request;\n  allowedPDSDomains: T[];\n}) {\n  // Extract session from cookies/headers\n  const session =\n    opts?.req ? await getSessionFromRequest(opts.allowedPDSDomains[0]) : null;\n\n  return {\n    session,\n  };\n}\n\nexport type TrpcContext = Awaited<ReturnType<typeof createContext>>;\n\nconst t = initTRPC.context<TrpcContext>().create({\n  transformer: customTransformer,\n});\n\nexport const createTRPCRouter = t.router;\nexport const publicProcedure = t.procedure;\n\nexport const protectedProcedure = t.procedure.use(({ ctx, next }) => {\n  if (!ctx.session) {\n    throw new TRPCError({\n      code: \"UNAUTHORIZED\",\n      message: \"You must be logged in\",\n    });\n  }\n  return next({ ctx });\n});\n","import { cookies } from \"next/headers\";\nimport { SignJWT, jwtVerify } from \"jose\";\nimport type { JwtPayload } from \"@atproto/oauth-client-node\";\nimport type { SupportedPDSDomain } from \"@/index\";\n\nexport interface StoredSession extends JwtPayload {\n  accessJwt: string;\n  refreshJwt: string;\n  did: string;\n  handle: string;\n}\n\nconst SECRET_KEY = new TextEncoder().encode(\n  process.env.COOKIE_SECRET || \"your-secret-key-min-32-chars-long\"\n);\n\nasync function encrypt(payload: StoredSession): Promise<string> {\n  return await new SignJWT(payload)\n    .setProtectedHeader({ alg: \"HS256\" })\n    .setIssuedAt()\n    .setExpirationTime(\"30d\")\n    .sign(SECRET_KEY);\n}\n\nasync function decrypt(token: string): Promise<StoredSession | null> {\n  try {\n    const { payload } = await jwtVerify(token, SECRET_KEY);\n    return payload as StoredSession;\n  } catch {\n    return null;\n  }\n}\n\nexport async function getSessionFromRequest(\n  service: SupportedPDSDomain = \"climateai.org\"\n): Promise<StoredSession | null> {\n  const cookieStore = await cookies();\n  const encryptedSession = cookieStore.get(`${service}_session`);\n\n  if (!encryptedSession) {\n    return null;\n  }\n\n  return await decrypt(encryptedSession.value);\n}\n\nexport async function saveSession(\n  session: StoredSession,\n  service: SupportedPDSDomain = \"climateai.org\"\n) {\n  const cookieStore = await cookies();\n  const encrypted = await encrypt(session);\n\n  cookieStore.set(`${service}_session`, encrypted, {\n    httpOnly: true,\n    secure: process.env.NODE_ENV === \"production\",\n    sameSite: \"lax\",\n    maxAge: 60 * 60 * 24 * 30,\n    path: \"/\",\n  });\n\n  return encrypted;\n}\n\nexport async function clearSession(\n  service: SupportedPDSDomain = \"climateai.org\"\n) {\n  const cookieStore = await cookies();\n  cookieStore.delete(`${service}_session`);\n}\n","// utils/transformer.ts\nimport type { DataTransformer } from \"@trpc/server\";\nimport superjson, { type SuperJSONResult } from \"superjson\";\nimport { type BlobRefGenerator, toBlobRef } from \"@/zod-schemas/blobref\";\nimport { BlobRef } from \"@atproto/api\";\nimport { isObject } from \"@/lib/isObject\";\n\ntype ReplaceType<T, U, V> =\n  // If T directly extends U, substitute to V\n  T extends U\n    ? V\n    : // If T is an array, recursively apply ReplaceType on the element type\n    T extends (infer Item)[]\n    ? ReplaceType<Item, U, V>[]\n    : // If T is an object, recursively apply ReplaceType on all properties\n    T extends object\n    ? { [K in keyof T]: ReplaceType<T[K], U, V> }\n    : // Otherwise, keep original type\n      T;\n\ntype Serialize<T> = ReplaceType<T, BlobRef, BlobRefGenerator>;\n\nconst _serialize = <T>(data: T): Serialize<T> => {\n  return JSON.parse(JSON.stringify(data)) as Serialize<T>;\n};\n\nconst _deserialize = <T>(data: Serialize<T>): T => {\n  const isObj = isObject(data);\n  if (!isObj) {\n    if (Array.isArray(data)) {\n      return data.map(_deserialize) as T;\n    }\n    return data as T;\n  }\n  if (\"$type\" in data && data.$type === \"blob\" && \"ref\" in data) {\n    try {\n      return toBlobRef(data as unknown as BlobRefGenerator) as T;\n    } catch {\n      return data as T;\n    }\n  }\n\n  const obj = data as Record<string, unknown>;\n  return Object.fromEntries(\n    Object.entries(obj).map(([key, value]) => [key, _deserialize(value)])\n  ) as T;\n};\n\nexport const customTransformer: DataTransformer = {\n  serialize: (object) => {\n    // typeof object = object\n    // This logic runs for transforming the query or mutation parameters before they are sent to the server.\n    // Conversion of object to string is automatically handled by TRPC.\n    const atprotoSerialized = _serialize(object);\n    const serializedObject = superjson.serialize(atprotoSerialized);\n    return serializedObject;\n  },\n  deserialize: <T>(object: SuperJSONResult): T => {\n    // typeof object = { json: object }\n    // This logic runs for transforming the query or mutation response before it is received by the client.\n    // The received response is automatically converted from stringified JSON to object by TRPC.\n    const superjsonDeserialized = superjson.deserialize(object) as Serialize<T>;\n    const deserializedObject = _deserialize(superjsonDeserialized);\n    // console.log(\"deserialized object\", deserializedObject);\n    return deserializedObject as T;\n  },\n};\n\nexport type SerializedSuperjson<T> = Omit<SuperJSONResult, \"json\"> & {\n  json: Serialize<T>;\n};\n\nexport const serialize = <T>(data: T) => {\n  const result = customTransformer.serialize(data);\n  return result as SerializedSuperjson<T>;\n};\n\nexport const deserialize = <T>(object: SerializedSuperjson<T>): T => {\n  return customTransformer.deserialize(object);\n};\n","import z from \"zod\";\nimport { CID } from \"multiformats/cid\";\nimport type { Version } from \"multiformats/cid\";\nimport { BlobRef } from \"@atproto/lexicon\";\n\nexport const BlobRefGeneratorSchema = z.object({\n  $type: z.literal(\"blob-ref-generator\"),\n  ref: z.object({\n    $link: z.string(),\n  }),\n  mimeType: z.string(),\n  size: z.number(),\n});\n\nexport type BlobRefGenerator = z.infer<typeof BlobRefGeneratorSchema>;\n\nexport const toBlobRef = (input: BlobRefGenerator) => {\n  const validCID: CID<unknown, number, number, Version> = CID.parse(\n    input.ref.$link\n  );\n  return BlobRef.fromJsonRef({\n    $type: \"blob\",\n    ref: validCID,\n    mimeType: input.mimeType,\n    size: input.size,\n  });\n};\n\nexport const toBlobRefGenerator = (blobRef: BlobRef): BlobRefGenerator => {\n  const json = blobRef.toJSON();\n  return {\n    $type: \"blob-ref-generator\",\n    ref: json.ref,\n    mimeType: json.mimeType,\n    size: json.size,\n  };\n};\n","export const isObject = (value: unknown): value is object => {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    !Array.isArray(value) &&\n    !(value instanceof RegExp) &&\n    !(value instanceof Date) &&\n    !(value instanceof Set) &&\n    !(value instanceof Map)\n  );\n};\n","import { protectedProcedure } from \"@/server/trpc\";\nimport z, { file } from \"zod\";\nimport { getWriteAgent } from \"@/server/utils/agent\";\nimport type { SupportedPDSDomain } from \"@/index\";\nimport {\n  FileGeneratorSchema,\n  toFile,\n  type FileGenerator,\n} from \"@/zod-schemas/file\";\nimport { BlobRef, type Agent } from \"@atproto/api\";\nimport { TRPCError } from \"@trpc/server\";\n\nexport const uploadFileAsBlobPure = async (\n  file: File | FileGenerator,\n  agent: Agent\n) => {\n  let fileToUpload: File;\n  if (file instanceof File) {\n    fileToUpload = file;\n  } else {\n    fileToUpload = await toFile(file);\n  }\n  const response = await agent.uploadBlob(fileToUpload);\n\n  if (response.success !== true) {\n    throw new TRPCError({\n      code: \"INTERNAL_SERVER_ERROR\",\n      message: \"Failed to upload file as blob.\",\n    });\n  }\n  return response.data;\n};\n\nexport const uploadFileAsBlobFactory = <T extends SupportedPDSDomain>(\n  allowedPDSDomainSchema: z.ZodEnum<Record<T, T>>\n) => {\n  return protectedProcedure\n    .input(\n      z.object({\n        file: FileGeneratorSchema,\n        pdsDomain: allowedPDSDomainSchema,\n      })\n    )\n    .mutation(async ({ input }) => {\n      const agent = await getWriteAgent(input.pdsDomain);\n      const response = await uploadFileAsBlobPure(input.file, agent);\n\n      return response;\n    });\n};\n","import { Agent, CredentialSession } from \"@atproto/api\";\nimport { getSessionFromRequest } from \"../session\";\nimport { TRPCError } from \"@trpc/server\";\nimport type { SupportedPDSDomain } from \"@/index\";\n\nexport const getReadAgent = <T extends SupportedPDSDomain>(pdsDomain: T) => {\n  return new Agent({\n    service: new URL(`https://${pdsDomain}`),\n  });\n};\n\nexport const getWriteAgent = async <T extends SupportedPDSDomain>(\n  pdsDomain: T\n) => {\n  const session = await getSessionFromRequest(pdsDomain);\n  if (!session)\n    throw new TRPCError({\n      code: \"UNAUTHORIZED\",\n      message: \"You are not authorized.\",\n    });\n  const credentialSession = new CredentialSession(\n    new URL(`https://${pdsDomain}`)\n  );\n  const result = await credentialSession.resumeSession({\n    accessJwt: session.accessJwt,\n    refreshJwt: session.refreshJwt,\n    handle: session.handle,\n    did: session.did,\n    active: true,\n  });\n  if (!result.success)\n    throw new TRPCError({\n      code: \"UNAUTHORIZED\",\n      message: \"Failed to resume session.\",\n    });\n  return new Agent(credentialSession);\n};\n","import z from \"zod\";\n\nexport const FileGeneratorSchema = z.object({\n  name: z.string(),\n  type: z.string(),\n  dataBase64: z.string(),\n});\n\nexport type FileGenerator = z.infer<typeof FileGeneratorSchema>;\n\nexport const toFile = async (fileGenerator: FileGenerator) => {\n  const file = new File(\n    [Buffer.from(fileGenerator.dataBase64, \"base64\")],\n    fileGenerator.name,\n    { type: fileGenerator.type }\n  );\n  return file;\n};\n\nexport const toFileGenerator = async (file: File) => {\n  return {\n    name: file.name,\n    type: file.type,\n    dataBase64: await file\n      .arrayBuffer()\n      .then((buffer) => Buffer.from(buffer).toString(\"base64\")),\n  };\n};\n","import { type SupportedPDSDomain } from \"@/index\";\nimport { saveSession, type StoredSession } from \"@/server/session\";\nimport { publicProcedure } from \"@/server/trpc\";\nimport { CredentialSession } from \"@atproto/api\";\nimport { TRPCError } from \"@trpc/server\";\nimport z from \"zod\";\n\nexport const loginFactory = <T extends SupportedPDSDomain>(\n  allowedPDSDomainSchema: z.ZodEnum<Record<T, T>>\n) => {\n  return publicProcedure\n    .input(\n      z.object({\n        handlePrefix: z.string().regex(/^^[a-zA-Z0-9-]+$/), // alphanumerics and hyphens only\n        service: allowedPDSDomainSchema,\n        password: z.string(),\n      })\n    )\n    .mutation(async ({ input }) => {\n      const session = new CredentialSession(\n        new URL(`https://${input.service}`)\n      );\n      const result = await session.login({\n        identifier: `${input.handlePrefix}.${input.service}`,\n        password: input.password,\n      });\n      if (!result.success) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Login failed\",\n        });\n      }\n      const context: StoredSession = {\n        accessJwt: result.data.accessJwt,\n        refreshJwt: result.data.refreshJwt,\n        did: result.data.did,\n        handle: result.data.handle,\n      };\n      await saveSession(context, input.service);\n      return {\n        context,\n        service: input.service,\n      };\n    });\n};\n","import { type SupportedPDSDomain } from \"@/index\";\nimport { getSessionFromRequest } from \"@/server/session\";\nimport { publicProcedure } from \"@/server/trpc\";\nimport { TRPCError } from \"@trpc/server\";\nimport z from \"zod\";\n\nexport const resumeFactory = <T extends SupportedPDSDomain>(\n  allowedPDSDomainSchema: z.ZodEnum<Record<T, T>>\n) => {\n  return publicProcedure\n    .input(\n      z.object({\n        service: allowedPDSDomainSchema,\n      })\n    )\n    .mutation(async ({ input }) => {\n      const session = await getSessionFromRequest(input.service);\n      if (!session) {\n        throw new TRPCError({\n          code: \"UNAUTHORIZED\",\n          message: \"No session found\",\n        });\n      }\n      return {\n        context: session,\n        service: input.service,\n      };\n    });\n};\n","import { type SupportedPDSDomain } from \"@/index\";\nimport { clearSession } from \"@/server/session\";\nimport { publicProcedure } from \"@/server/trpc\";\nimport z from \"zod\";\n\nexport const logoutFactory = <T extends SupportedPDSDomain>(\n  allowedPDSDomainSchema: z.ZodEnum<Record<T, T>>\n) => {\n  return publicProcedure\n    .input(\n      z.object({\n        service: allowedPDSDomainSchema,\n      })\n    )\n    .mutation(async ({ input }) => {\n      await clearSession(input.service);\n      return {\n        success: true,\n      };\n    });\n};\n","import { publicProcedure } from \"@/server/trpc\";\nimport { z } from \"zod\";\nimport { tryCatch } from \"@/lib/tryCatch\";\nimport { XRPCError } from \"@atproto/xrpc\";\nimport type { GetRecordResponse } from \"@/server/utils/response-types\";\nimport { AppGainforestOrganizationInfo } from \"@/../lex-api\";\nimport { getReadAgent } from \"@/server/utils/agent\";\nimport { xrpcErrorToTRPCError } from \"@/server/utils/classify-xrpc-error\";\nimport { TRPCError } from \"@trpc/server\";\nimport { validateRecordOrThrow } from \"@/server/utils/validate-record-or-throw\";\nimport type { SupportedPDSDomain } from \"@/index\";\n\nexport const getOrganizationInfoPure = async <T extends SupportedPDSDomain>(\n  did: string,\n  pdsDomain: T\n) => {\n  const agent = getReadAgent(pdsDomain);\n  const getRecordPromise = agent.com.atproto.repo.getRecord({\n    collection: \"app.gainforest.organization.info\",\n    repo: did,\n    rkey: \"self\",\n  });\n  const [response, error] = await tryCatch(getRecordPromise);\n\n  if (error) {\n    if (error instanceof XRPCError) {\n      const trpcError = xrpcErrorToTRPCError(error);\n      throw trpcError;\n    } else {\n      throw new TRPCError({\n        code: \"INTERNAL_SERVER_ERROR\",\n        message: \"An unknown error occurred.\",\n      });\n    }\n  }\n\n  if (response.success !== true) {\n    throw new TRPCError({\n      code: \"INTERNAL_SERVER_ERROR\",\n      message: \"Failed to get organization info.\",\n    });\n  }\n\n  validateRecordOrThrow(response.data.value, AppGainforestOrganizationInfo);\n\n  return response.data as GetRecordResponse<AppGainforestOrganizationInfo.Record>;\n};\n\nexport const getOrganizationInfoFactory = <T extends SupportedPDSDomain>(\n  allowedPDSDomainSchema: z.ZodEnum<Record<T, T>>\n) => {\n  return publicProcedure\n    .input(z.object({ did: z.string(), pdsDomain: allowedPDSDomainSchema }))\n    .query(async ({ input }) => {\n      return await getOrganizationInfoPure(input.did, input.pdsDomain);\n    });\n};\n","export const tryCatch = async <T>(\n  promise: Promise<T>\n): Promise<[T, null] | [null, Error]> => {\n  try {\n    const result = await promise;\n    return [result, null];\n  } catch (error) {\n    return [null, error as Error];\n  }\n};\n","/**\n * The following lines are added by lex-api-mod.ts to fix build errors.\n */\nimport {\n  ComAtprotoRepoListRecords,\n  ComAtprotoRepoGetRecord,\n  ComAtprotoRepoCreateRecord,\n  ComAtprotoRepoPutRecord,\n  ComAtprotoRepoDeleteRecord,\n} from \"@atproto/api\";\n/**\n * GENERATED CODE - DO NOT MODIFY\n */\n\n/**\n * GENERATED CODE - DO NOT MODIFY\n */\nimport {\n  XrpcClient,\n  type FetchHandler,\n  type FetchHandlerOptions,\n} from '@atproto/xrpc'\nimport { schemas } from './lexicons.js'\nimport { CID } from 'multiformats/cid'\nimport { type OmitKey, type Un$Typed } from './util.js'\nimport * as AppCertifiedLocation from './types/app/certified/location.js'\nimport * as OrgHypercertsClaimClaim from './types/org/hypercerts/claim/claim.js'\nimport * as OrgHypercertsClaimContribution from './types/org/hypercerts/claim/contribution.js'\nimport * as OrgHypercertsClaimEvaluation from './types/org/hypercerts/claim/evaluation.js'\nimport * as OrgHypercertsClaimEvidence from './types/org/hypercerts/claim/evidence.js'\nimport * as OrgHypercertsClaimMeasurement from './types/org/hypercerts/claim/measurement.js'\nimport * as OrgHypercertsClaimRights from './types/org/hypercerts/claim/rights.js'\nimport * as OrgHypercertsCollection from './types/org/hypercerts/collection.js'\nimport * as OrgHypercertsDefs from './types/org/hypercerts/defs.js'\nimport * as AppGainforestCommonDefs from './types/app/gainforest/common/defs.js'\nimport * as AppGainforestOrganizationDefaultSite from './types/app/gainforest/organization/defaultSite.js'\nimport * as AppGainforestOrganizationGetIndexedOrganizations from './types/app/gainforest/organization/getIndexedOrganizations.js'\nimport * as AppGainforestOrganizationInfo from './types/app/gainforest/organization/info.js'\nimport * as AppGainforestOrganizationMeasuredTrees from './types/app/gainforest/organization/measuredTrees.js'\nimport * as AppGainforestOrganizationSite from './types/app/gainforest/organization/site.js'\nimport * as ComAtprotoRepoStrongRef from './types/com/atproto/repo/strongRef.js'\n\nexport * as AppCertifiedLocation from './types/app/certified/location.js'\nexport * as OrgHypercertsClaimClaim from './types/org/hypercerts/claim/claim.js'\nexport * as OrgHypercertsClaimContribution from './types/org/hypercerts/claim/contribution.js'\nexport * as OrgHypercertsClaimEvaluation from './types/org/hypercerts/claim/evaluation.js'\nexport * as OrgHypercertsClaimEvidence from './types/org/hypercerts/claim/evidence.js'\nexport * as OrgHypercertsClaimMeasurement from './types/org/hypercerts/claim/measurement.js'\nexport * as OrgHypercertsClaimRights from './types/org/hypercerts/claim/rights.js'\nexport * as OrgHypercertsCollection from './types/org/hypercerts/collection.js'\nexport * as OrgHypercertsDefs from './types/org/hypercerts/defs.js'\nexport * as AppGainforestCommonDefs from './types/app/gainforest/common/defs.js'\nexport * as AppGainforestOrganizationDefaultSite from './types/app/gainforest/organization/defaultSite.js'\nexport * as AppGainforestOrganizationGetIndexedOrganizations from './types/app/gainforest/organization/getIndexedOrganizations.js'\nexport * as AppGainforestOrganizationInfo from './types/app/gainforest/organization/info.js'\nexport * as AppGainforestOrganizationMeasuredTrees from './types/app/gainforest/organization/measuredTrees.js'\nexport * as AppGainforestOrganizationSite from './types/app/gainforest/organization/site.js'\nexport * as ComAtprotoRepoStrongRef from './types/com/atproto/repo/strongRef.js'\n\nexport class AtpBaseClient extends XrpcClient {\n  app: AppNS\n  org: OrgNS\n  com: ComNS\n\n  constructor(options: FetchHandler | FetchHandlerOptions) {\n    super(options, schemas)\n    this.app = new AppNS(this)\n    this.org = new OrgNS(this)\n    this.com = new ComNS(this)\n  }\n\n  /** @deprecated use `this` instead */\n  get xrpc(): XrpcClient {\n    return this\n  }\n}\n\nexport class AppNS {\n  _client: XrpcClient\n  certified: AppCertifiedNS\n  gainforest: AppGainforestNS\n\n  constructor(client: XrpcClient) {\n    this._client = client\n    this.certified = new AppCertifiedNS(client)\n    this.gainforest = new AppGainforestNS(client)\n  }\n}\n\nexport class AppCertifiedNS {\n  _client: XrpcClient\n  location: AppCertifiedLocationRecord\n\n  constructor(client: XrpcClient) {\n    this._client = client\n    this.location = new AppCertifiedLocationRecord(client)\n  }\n}\n\nexport class AppCertifiedLocationRecord {\n  _client: XrpcClient\n\n  constructor(client: XrpcClient) {\n    this._client = client\n  }\n\n  async list(\n    params: OmitKey<ComAtprotoRepoListRecords.QueryParams, 'collection'>,\n  ): Promise<{\n    cursor?: string\n    records: { uri: string; value: AppCertifiedLocation.Record }[]\n  }> {\n    const res = await this._client.call('com.atproto.repo.listRecords', {\n      collection: 'app.certified.location',\n      ...params,\n    })\n    return res.data\n  }\n\n  async get(\n    params: OmitKey<ComAtprotoRepoGetRecord.QueryParams, 'collection'>,\n  ): Promise<{ uri: string; cid: string; value: AppCertifiedLocation.Record }> {\n    const res = await this._client.call('com.atproto.repo.getRecord', {\n      collection: 'app.certified.location',\n      ...params,\n    })\n    return res.data\n  }\n\n  async create(\n    params: OmitKey<\n      ComAtprotoRepoCreateRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<AppCertifiedLocation.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'app.certified.location'\n    const res = await this._client.call(\n      'com.atproto.repo.createRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async put(\n    params: OmitKey<\n      ComAtprotoRepoPutRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<AppCertifiedLocation.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'app.certified.location'\n    const res = await this._client.call(\n      'com.atproto.repo.putRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async delete(\n    params: OmitKey<ComAtprotoRepoDeleteRecord.InputSchema, 'collection'>,\n    headers?: Record<string, string>,\n  ): Promise<void> {\n    await this._client.call(\n      'com.atproto.repo.deleteRecord',\n      undefined,\n      { collection: 'app.certified.location', ...params },\n      { headers },\n    )\n  }\n}\n\nexport class AppGainforestNS {\n  _client: XrpcClient\n  organization: AppGainforestOrganizationNS\n\n  constructor(client: XrpcClient) {\n    this._client = client\n    this.organization = new AppGainforestOrganizationNS(client)\n  }\n}\n\nexport class AppGainforestOrganizationNS {\n  _client: XrpcClient\n  defaultSite: AppGainforestOrganizationDefaultSiteRecord\n  info: AppGainforestOrganizationInfoRecord\n  measuredTrees: AppGainforestOrganizationMeasuredTreesRecord\n  site: AppGainforestOrganizationSiteRecord\n\n  constructor(client: XrpcClient) {\n    this._client = client\n    this.defaultSite = new AppGainforestOrganizationDefaultSiteRecord(client)\n    this.info = new AppGainforestOrganizationInfoRecord(client)\n    this.measuredTrees = new AppGainforestOrganizationMeasuredTreesRecord(\n      client,\n    )\n    this.site = new AppGainforestOrganizationSiteRecord(client)\n  }\n\n  getIndexedOrganizations(\n    params?: AppGainforestOrganizationGetIndexedOrganizations.QueryParams,\n    opts?: AppGainforestOrganizationGetIndexedOrganizations.CallOptions,\n  ): Promise<AppGainforestOrganizationGetIndexedOrganizations.Response> {\n    return this._client.call(\n      'app.gainforest.organization.getIndexedOrganizations',\n      params,\n      undefined,\n      opts,\n    )\n  }\n}\n\nexport class AppGainforestOrganizationDefaultSiteRecord {\n  _client: XrpcClient\n\n  constructor(client: XrpcClient) {\n    this._client = client\n  }\n\n  async list(\n    params: OmitKey<ComAtprotoRepoListRecords.QueryParams, 'collection'>,\n  ): Promise<{\n    cursor?: string\n    records: {\n      uri: string\n      value: AppGainforestOrganizationDefaultSite.Record\n    }[]\n  }> {\n    const res = await this._client.call('com.atproto.repo.listRecords', {\n      collection: 'app.gainforest.organization.defaultSite',\n      ...params,\n    })\n    return res.data\n  }\n\n  async get(\n    params: OmitKey<ComAtprotoRepoGetRecord.QueryParams, 'collection'>,\n  ): Promise<{\n    uri: string\n    cid: string\n    value: AppGainforestOrganizationDefaultSite.Record\n  }> {\n    const res = await this._client.call('com.atproto.repo.getRecord', {\n      collection: 'app.gainforest.organization.defaultSite',\n      ...params,\n    })\n    return res.data\n  }\n\n  async create(\n    params: OmitKey<\n      ComAtprotoRepoCreateRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<AppGainforestOrganizationDefaultSite.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'app.gainforest.organization.defaultSite'\n    const res = await this._client.call(\n      'com.atproto.repo.createRecord',\n      undefined,\n      {\n        collection,\n        rkey: 'self',\n        ...params,\n        record: { ...record, $type: collection },\n      },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async put(\n    params: OmitKey<\n      ComAtprotoRepoPutRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<AppGainforestOrganizationDefaultSite.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'app.gainforest.organization.defaultSite'\n    const res = await this._client.call(\n      'com.atproto.repo.putRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async delete(\n    params: OmitKey<ComAtprotoRepoDeleteRecord.InputSchema, 'collection'>,\n    headers?: Record<string, string>,\n  ): Promise<void> {\n    await this._client.call(\n      'com.atproto.repo.deleteRecord',\n      undefined,\n      { collection: 'app.gainforest.organization.defaultSite', ...params },\n      { headers },\n    )\n  }\n}\n\nexport class AppGainforestOrganizationInfoRecord {\n  _client: XrpcClient\n\n  constructor(client: XrpcClient) {\n    this._client = client\n  }\n\n  async list(\n    params: OmitKey<ComAtprotoRepoListRecords.QueryParams, 'collection'>,\n  ): Promise<{\n    cursor?: string\n    records: { uri: string; value: AppGainforestOrganizationInfo.Record }[]\n  }> {\n    const res = await this._client.call('com.atproto.repo.listRecords', {\n      collection: 'app.gainforest.organization.info',\n      ...params,\n    })\n    return res.data\n  }\n\n  async get(\n    params: OmitKey<ComAtprotoRepoGetRecord.QueryParams, 'collection'>,\n  ): Promise<{\n    uri: string\n    cid: string\n    value: AppGainforestOrganizationInfo.Record\n  }> {\n    const res = await this._client.call('com.atproto.repo.getRecord', {\n      collection: 'app.gainforest.organization.info',\n      ...params,\n    })\n    return res.data\n  }\n\n  async create(\n    params: OmitKey<\n      ComAtprotoRepoCreateRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<AppGainforestOrganizationInfo.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'app.gainforest.organization.info'\n    const res = await this._client.call(\n      'com.atproto.repo.createRecord',\n      undefined,\n      {\n        collection,\n        rkey: 'self',\n        ...params,\n        record: { ...record, $type: collection },\n      },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async put(\n    params: OmitKey<\n      ComAtprotoRepoPutRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<AppGainforestOrganizationInfo.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'app.gainforest.organization.info'\n    const res = await this._client.call(\n      'com.atproto.repo.putRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async delete(\n    params: OmitKey<ComAtprotoRepoDeleteRecord.InputSchema, 'collection'>,\n    headers?: Record<string, string>,\n  ): Promise<void> {\n    await this._client.call(\n      'com.atproto.repo.deleteRecord',\n      undefined,\n      { collection: 'app.gainforest.organization.info', ...params },\n      { headers },\n    )\n  }\n}\n\nexport class AppGainforestOrganizationMeasuredTreesRecord {\n  _client: XrpcClient\n\n  constructor(client: XrpcClient) {\n    this._client = client\n  }\n\n  async list(\n    params: OmitKey<ComAtprotoRepoListRecords.QueryParams, 'collection'>,\n  ): Promise<{\n    cursor?: string\n    records: {\n      uri: string\n      value: AppGainforestOrganizationMeasuredTrees.Record\n    }[]\n  }> {\n    const res = await this._client.call('com.atproto.repo.listRecords', {\n      collection: 'app.gainforest.organization.measuredTrees',\n      ...params,\n    })\n    return res.data\n  }\n\n  async get(\n    params: OmitKey<ComAtprotoRepoGetRecord.QueryParams, 'collection'>,\n  ): Promise<{\n    uri: string\n    cid: string\n    value: AppGainforestOrganizationMeasuredTrees.Record\n  }> {\n    const res = await this._client.call('com.atproto.repo.getRecord', {\n      collection: 'app.gainforest.organization.measuredTrees',\n      ...params,\n    })\n    return res.data\n  }\n\n  async create(\n    params: OmitKey<\n      ComAtprotoRepoCreateRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<AppGainforestOrganizationMeasuredTrees.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'app.gainforest.organization.measuredTrees'\n    const res = await this._client.call(\n      'com.atproto.repo.createRecord',\n      undefined,\n      {\n        collection,\n        rkey: 'self',\n        ...params,\n        record: { ...record, $type: collection },\n      },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async put(\n    params: OmitKey<\n      ComAtprotoRepoPutRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<AppGainforestOrganizationMeasuredTrees.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'app.gainforest.organization.measuredTrees'\n    const res = await this._client.call(\n      'com.atproto.repo.putRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async delete(\n    params: OmitKey<ComAtprotoRepoDeleteRecord.InputSchema, 'collection'>,\n    headers?: Record<string, string>,\n  ): Promise<void> {\n    await this._client.call(\n      'com.atproto.repo.deleteRecord',\n      undefined,\n      { collection: 'app.gainforest.organization.measuredTrees', ...params },\n      { headers },\n    )\n  }\n}\n\nexport class AppGainforestOrganizationSiteRecord {\n  _client: XrpcClient\n\n  constructor(client: XrpcClient) {\n    this._client = client\n  }\n\n  async list(\n    params: OmitKey<ComAtprotoRepoListRecords.QueryParams, 'collection'>,\n  ): Promise<{\n    cursor?: string\n    records: { uri: string; value: AppGainforestOrganizationSite.Record }[]\n  }> {\n    const res = await this._client.call('com.atproto.repo.listRecords', {\n      collection: 'app.gainforest.organization.site',\n      ...params,\n    })\n    return res.data\n  }\n\n  async get(\n    params: OmitKey<ComAtprotoRepoGetRecord.QueryParams, 'collection'>,\n  ): Promise<{\n    uri: string\n    cid: string\n    value: AppGainforestOrganizationSite.Record\n  }> {\n    const res = await this._client.call('com.atproto.repo.getRecord', {\n      collection: 'app.gainforest.organization.site',\n      ...params,\n    })\n    return res.data\n  }\n\n  async create(\n    params: OmitKey<\n      ComAtprotoRepoCreateRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<AppGainforestOrganizationSite.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'app.gainforest.organization.site'\n    const res = await this._client.call(\n      'com.atproto.repo.createRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async put(\n    params: OmitKey<\n      ComAtprotoRepoPutRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<AppGainforestOrganizationSite.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'app.gainforest.organization.site'\n    const res = await this._client.call(\n      'com.atproto.repo.putRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async delete(\n    params: OmitKey<ComAtprotoRepoDeleteRecord.InputSchema, 'collection'>,\n    headers?: Record<string, string>,\n  ): Promise<void> {\n    await this._client.call(\n      'com.atproto.repo.deleteRecord',\n      undefined,\n      { collection: 'app.gainforest.organization.site', ...params },\n      { headers },\n    )\n  }\n}\n\nexport class OrgNS {\n  _client: XrpcClient\n  hypercerts: OrgHypercertsNS\n\n  constructor(client: XrpcClient) {\n    this._client = client\n    this.hypercerts = new OrgHypercertsNS(client)\n  }\n}\n\nexport class OrgHypercertsNS {\n  _client: XrpcClient\n  collection: OrgHypercertsCollectionRecord\n  claim: OrgHypercertsClaimNS\n\n  constructor(client: XrpcClient) {\n    this._client = client\n    this.claim = new OrgHypercertsClaimNS(client)\n    this.collection = new OrgHypercertsCollectionRecord(client)\n  }\n}\n\nexport class OrgHypercertsClaimNS {\n  _client: XrpcClient\n  claim: OrgHypercertsClaimClaimRecord\n  contribution: OrgHypercertsClaimContributionRecord\n  evaluation: OrgHypercertsClaimEvaluationRecord\n  evidence: OrgHypercertsClaimEvidenceRecord\n  measurement: OrgHypercertsClaimMeasurementRecord\n  rights: OrgHypercertsClaimRightsRecord\n\n  constructor(client: XrpcClient) {\n    this._client = client\n    this.claim = new OrgHypercertsClaimClaimRecord(client)\n    this.contribution = new OrgHypercertsClaimContributionRecord(client)\n    this.evaluation = new OrgHypercertsClaimEvaluationRecord(client)\n    this.evidence = new OrgHypercertsClaimEvidenceRecord(client)\n    this.measurement = new OrgHypercertsClaimMeasurementRecord(client)\n    this.rights = new OrgHypercertsClaimRightsRecord(client)\n  }\n}\n\nexport class OrgHypercertsClaimClaimRecord {\n  _client: XrpcClient\n\n  constructor(client: XrpcClient) {\n    this._client = client\n  }\n\n  async list(\n    params: OmitKey<ComAtprotoRepoListRecords.QueryParams, 'collection'>,\n  ): Promise<{\n    cursor?: string\n    records: { uri: string; value: OrgHypercertsClaimClaim.Record }[]\n  }> {\n    const res = await this._client.call('com.atproto.repo.listRecords', {\n      collection: 'org.hypercerts.claim.claim',\n      ...params,\n    })\n    return res.data\n  }\n\n  async get(\n    params: OmitKey<ComAtprotoRepoGetRecord.QueryParams, 'collection'>,\n  ): Promise<{\n    uri: string\n    cid: string\n    value: OrgHypercertsClaimClaim.Record\n  }> {\n    const res = await this._client.call('com.atproto.repo.getRecord', {\n      collection: 'org.hypercerts.claim.claim',\n      ...params,\n    })\n    return res.data\n  }\n\n  async create(\n    params: OmitKey<\n      ComAtprotoRepoCreateRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<OrgHypercertsClaimClaim.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'org.hypercerts.claim.claim'\n    const res = await this._client.call(\n      'com.atproto.repo.createRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async put(\n    params: OmitKey<\n      ComAtprotoRepoPutRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<OrgHypercertsClaimClaim.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'org.hypercerts.claim.claim'\n    const res = await this._client.call(\n      'com.atproto.repo.putRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async delete(\n    params: OmitKey<ComAtprotoRepoDeleteRecord.InputSchema, 'collection'>,\n    headers?: Record<string, string>,\n  ): Promise<void> {\n    await this._client.call(\n      'com.atproto.repo.deleteRecord',\n      undefined,\n      { collection: 'org.hypercerts.claim.claim', ...params },\n      { headers },\n    )\n  }\n}\n\nexport class OrgHypercertsClaimContributionRecord {\n  _client: XrpcClient\n\n  constructor(client: XrpcClient) {\n    this._client = client\n  }\n\n  async list(\n    params: OmitKey<ComAtprotoRepoListRecords.QueryParams, 'collection'>,\n  ): Promise<{\n    cursor?: string\n    records: { uri: string; value: OrgHypercertsClaimContribution.Record }[]\n  }> {\n    const res = await this._client.call('com.atproto.repo.listRecords', {\n      collection: 'org.hypercerts.claim.contribution',\n      ...params,\n    })\n    return res.data\n  }\n\n  async get(\n    params: OmitKey<ComAtprotoRepoGetRecord.QueryParams, 'collection'>,\n  ): Promise<{\n    uri: string\n    cid: string\n    value: OrgHypercertsClaimContribution.Record\n  }> {\n    const res = await this._client.call('com.atproto.repo.getRecord', {\n      collection: 'org.hypercerts.claim.contribution',\n      ...params,\n    })\n    return res.data\n  }\n\n  async create(\n    params: OmitKey<\n      ComAtprotoRepoCreateRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<OrgHypercertsClaimContribution.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'org.hypercerts.claim.contribution'\n    const res = await this._client.call(\n      'com.atproto.repo.createRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async put(\n    params: OmitKey<\n      ComAtprotoRepoPutRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<OrgHypercertsClaimContribution.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'org.hypercerts.claim.contribution'\n    const res = await this._client.call(\n      'com.atproto.repo.putRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async delete(\n    params: OmitKey<ComAtprotoRepoDeleteRecord.InputSchema, 'collection'>,\n    headers?: Record<string, string>,\n  ): Promise<void> {\n    await this._client.call(\n      'com.atproto.repo.deleteRecord',\n      undefined,\n      { collection: 'org.hypercerts.claim.contribution', ...params },\n      { headers },\n    )\n  }\n}\n\nexport class OrgHypercertsClaimEvaluationRecord {\n  _client: XrpcClient\n\n  constructor(client: XrpcClient) {\n    this._client = client\n  }\n\n  async list(\n    params: OmitKey<ComAtprotoRepoListRecords.QueryParams, 'collection'>,\n  ): Promise<{\n    cursor?: string\n    records: { uri: string; value: OrgHypercertsClaimEvaluation.Record }[]\n  }> {\n    const res = await this._client.call('com.atproto.repo.listRecords', {\n      collection: 'org.hypercerts.claim.evaluation',\n      ...params,\n    })\n    return res.data\n  }\n\n  async get(\n    params: OmitKey<ComAtprotoRepoGetRecord.QueryParams, 'collection'>,\n  ): Promise<{\n    uri: string\n    cid: string\n    value: OrgHypercertsClaimEvaluation.Record\n  }> {\n    const res = await this._client.call('com.atproto.repo.getRecord', {\n      collection: 'org.hypercerts.claim.evaluation',\n      ...params,\n    })\n    return res.data\n  }\n\n  async create(\n    params: OmitKey<\n      ComAtprotoRepoCreateRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<OrgHypercertsClaimEvaluation.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'org.hypercerts.claim.evaluation'\n    const res = await this._client.call(\n      'com.atproto.repo.createRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async put(\n    params: OmitKey<\n      ComAtprotoRepoPutRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<OrgHypercertsClaimEvaluation.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'org.hypercerts.claim.evaluation'\n    const res = await this._client.call(\n      'com.atproto.repo.putRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async delete(\n    params: OmitKey<ComAtprotoRepoDeleteRecord.InputSchema, 'collection'>,\n    headers?: Record<string, string>,\n  ): Promise<void> {\n    await this._client.call(\n      'com.atproto.repo.deleteRecord',\n      undefined,\n      { collection: 'org.hypercerts.claim.evaluation', ...params },\n      { headers },\n    )\n  }\n}\n\nexport class OrgHypercertsClaimEvidenceRecord {\n  _client: XrpcClient\n\n  constructor(client: XrpcClient) {\n    this._client = client\n  }\n\n  async list(\n    params: OmitKey<ComAtprotoRepoListRecords.QueryParams, 'collection'>,\n  ): Promise<{\n    cursor?: string\n    records: { uri: string; value: OrgHypercertsClaimEvidence.Record }[]\n  }> {\n    const res = await this._client.call('com.atproto.repo.listRecords', {\n      collection: 'org.hypercerts.claim.evidence',\n      ...params,\n    })\n    return res.data\n  }\n\n  async get(\n    params: OmitKey<ComAtprotoRepoGetRecord.QueryParams, 'collection'>,\n  ): Promise<{\n    uri: string\n    cid: string\n    value: OrgHypercertsClaimEvidence.Record\n  }> {\n    const res = await this._client.call('com.atproto.repo.getRecord', {\n      collection: 'org.hypercerts.claim.evidence',\n      ...params,\n    })\n    return res.data\n  }\n\n  async create(\n    params: OmitKey<\n      ComAtprotoRepoCreateRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<OrgHypercertsClaimEvidence.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'org.hypercerts.claim.evidence'\n    const res = await this._client.call(\n      'com.atproto.repo.createRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async put(\n    params: OmitKey<\n      ComAtprotoRepoPutRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<OrgHypercertsClaimEvidence.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'org.hypercerts.claim.evidence'\n    const res = await this._client.call(\n      'com.atproto.repo.putRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async delete(\n    params: OmitKey<ComAtprotoRepoDeleteRecord.InputSchema, 'collection'>,\n    headers?: Record<string, string>,\n  ): Promise<void> {\n    await this._client.call(\n      'com.atproto.repo.deleteRecord',\n      undefined,\n      { collection: 'org.hypercerts.claim.evidence', ...params },\n      { headers },\n    )\n  }\n}\n\nexport class OrgHypercertsClaimMeasurementRecord {\n  _client: XrpcClient\n\n  constructor(client: XrpcClient) {\n    this._client = client\n  }\n\n  async list(\n    params: OmitKey<ComAtprotoRepoListRecords.QueryParams, 'collection'>,\n  ): Promise<{\n    cursor?: string\n    records: { uri: string; value: OrgHypercertsClaimMeasurement.Record }[]\n  }> {\n    const res = await this._client.call('com.atproto.repo.listRecords', {\n      collection: 'org.hypercerts.claim.measurement',\n      ...params,\n    })\n    return res.data\n  }\n\n  async get(\n    params: OmitKey<ComAtprotoRepoGetRecord.QueryParams, 'collection'>,\n  ): Promise<{\n    uri: string\n    cid: string\n    value: OrgHypercertsClaimMeasurement.Record\n  }> {\n    const res = await this._client.call('com.atproto.repo.getRecord', {\n      collection: 'org.hypercerts.claim.measurement',\n      ...params,\n    })\n    return res.data\n  }\n\n  async create(\n    params: OmitKey<\n      ComAtprotoRepoCreateRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<OrgHypercertsClaimMeasurement.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'org.hypercerts.claim.measurement'\n    const res = await this._client.call(\n      'com.atproto.repo.createRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async put(\n    params: OmitKey<\n      ComAtprotoRepoPutRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<OrgHypercertsClaimMeasurement.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'org.hypercerts.claim.measurement'\n    const res = await this._client.call(\n      'com.atproto.repo.putRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async delete(\n    params: OmitKey<ComAtprotoRepoDeleteRecord.InputSchema, 'collection'>,\n    headers?: Record<string, string>,\n  ): Promise<void> {\n    await this._client.call(\n      'com.atproto.repo.deleteRecord',\n      undefined,\n      { collection: 'org.hypercerts.claim.measurement', ...params },\n      { headers },\n    )\n  }\n}\n\nexport class OrgHypercertsClaimRightsRecord {\n  _client: XrpcClient\n\n  constructor(client: XrpcClient) {\n    this._client = client\n  }\n\n  async list(\n    params: OmitKey<ComAtprotoRepoListRecords.QueryParams, 'collection'>,\n  ): Promise<{\n    cursor?: string\n    records: { uri: string; value: OrgHypercertsClaimRights.Record }[]\n  }> {\n    const res = await this._client.call('com.atproto.repo.listRecords', {\n      collection: 'org.hypercerts.claim.rights',\n      ...params,\n    })\n    return res.data\n  }\n\n  async get(\n    params: OmitKey<ComAtprotoRepoGetRecord.QueryParams, 'collection'>,\n  ): Promise<{\n    uri: string\n    cid: string\n    value: OrgHypercertsClaimRights.Record\n  }> {\n    const res = await this._client.call('com.atproto.repo.getRecord', {\n      collection: 'org.hypercerts.claim.rights',\n      ...params,\n    })\n    return res.data\n  }\n\n  async create(\n    params: OmitKey<\n      ComAtprotoRepoCreateRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<OrgHypercertsClaimRights.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'org.hypercerts.claim.rights'\n    const res = await this._client.call(\n      'com.atproto.repo.createRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async put(\n    params: OmitKey<\n      ComAtprotoRepoPutRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<OrgHypercertsClaimRights.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'org.hypercerts.claim.rights'\n    const res = await this._client.call(\n      'com.atproto.repo.putRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async delete(\n    params: OmitKey<ComAtprotoRepoDeleteRecord.InputSchema, 'collection'>,\n    headers?: Record<string, string>,\n  ): Promise<void> {\n    await this._client.call(\n      'com.atproto.repo.deleteRecord',\n      undefined,\n      { collection: 'org.hypercerts.claim.rights', ...params },\n      { headers },\n    )\n  }\n}\n\nexport class OrgHypercertsCollectionRecord {\n  _client: XrpcClient\n\n  constructor(client: XrpcClient) {\n    this._client = client\n  }\n\n  async list(\n    params: OmitKey<ComAtprotoRepoListRecords.QueryParams, 'collection'>,\n  ): Promise<{\n    cursor?: string\n    records: { uri: string; value: OrgHypercertsCollection.Record }[]\n  }> {\n    const res = await this._client.call('com.atproto.repo.listRecords', {\n      collection: 'org.hypercerts.collection',\n      ...params,\n    })\n    return res.data\n  }\n\n  async get(\n    params: OmitKey<ComAtprotoRepoGetRecord.QueryParams, 'collection'>,\n  ): Promise<{\n    uri: string\n    cid: string\n    value: OrgHypercertsCollection.Record\n  }> {\n    const res = await this._client.call('com.atproto.repo.getRecord', {\n      collection: 'org.hypercerts.collection',\n      ...params,\n    })\n    return res.data\n  }\n\n  async create(\n    params: OmitKey<\n      ComAtprotoRepoCreateRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<OrgHypercertsCollection.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'org.hypercerts.collection'\n    const res = await this._client.call(\n      'com.atproto.repo.createRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async put(\n    params: OmitKey<\n      ComAtprotoRepoPutRecord.InputSchema,\n      'collection' | 'record'\n    >,\n    record: Un$Typed<OrgHypercertsCollection.Record>,\n    headers?: Record<string, string>,\n  ): Promise<{ uri: string; cid: string }> {\n    const collection = 'org.hypercerts.collection'\n    const res = await this._client.call(\n      'com.atproto.repo.putRecord',\n      undefined,\n      { collection, ...params, record: { ...record, $type: collection } },\n      { encoding: 'application/json', headers },\n    )\n    return res.data\n  }\n\n  async delete(\n    params: OmitKey<ComAtprotoRepoDeleteRecord.InputSchema, 'collection'>,\n    headers?: Record<string, string>,\n  ): Promise<void> {\n    await this._client.call(\n      'com.atproto.repo.deleteRecord',\n      undefined,\n      { collection: 'org.hypercerts.collection', ...params },\n      { headers },\n    )\n  }\n}\n\nexport class ComNS {\n  _client: XrpcClient\n  atproto: ComAtprotoNS\n\n  constructor(client: XrpcClient) {\n    this._client = client\n    this.atproto = new ComAtprotoNS(client)\n  }\n}\n\nexport class ComAtprotoNS {\n  _client: XrpcClient\n  repo: ComAtprotoRepoNS\n\n  constructor(client: XrpcClient) {\n    this._client = client\n    this.repo = new ComAtprotoRepoNS(client)\n  }\n}\n\nexport class ComAtprotoRepoNS {\n  _client: XrpcClient\n\n  constructor(client: XrpcClient) {\n    this._client = client\n  }\n}\n","/**\n * GENERATED CODE - DO NOT MODIFY\n */\nimport {\n  type LexiconDoc,\n  Lexicons,\n  ValidationError,\n  type ValidationResult,\n} from '@atproto/lexicon'\nimport { type $Typed, is$typed, maybe$typed } from './util.js'\n\nexport const schemaDict = {\n  AppCertifiedLocation: {\n    lexicon: 1,\n    id: 'app.certified.location',\n    defs: {\n      main: {\n        type: 'record',\n        description: 'A location reference',\n        key: 'any',\n        record: {\n          type: 'object',\n          required: [\n            'lpVersion',\n            'srs',\n            'locationType',\n            'location',\n            'createdAt',\n          ],\n          properties: {\n            lpVersion: {\n              type: 'string',\n              description: 'The version of the Location Protocol',\n              maxLength: 10,\n            },\n            srs: {\n              type: 'string',\n              format: 'uri',\n              description:\n                'The Spatial Reference System URI (e.g., http://www.opengis.net/def/crs/OGC/1.3/CRS84) that defines the coordinate system.',\n              maxLength: 100,\n            },\n            locationType: {\n              type: 'string',\n              description:\n                'An identifier for the format of the location data (e.g., coordinate-decimal, geojson-point)',\n              knownValues: ['coordinate-decimal', 'geojson-point'],\n              maxLength: 20,\n            },\n            location: {\n              type: 'union',\n              refs: [\n                'lex:org.hypercerts.defs#uri',\n                'lex:org.hypercerts.defs#smallBlob',\n              ],\n              description:\n                'The location of where the work was performed as a URI or blob.',\n            },\n            name: {\n              type: 'string',\n              description: 'Optional name for this location',\n              maxLength: 1000,\n              maxGraphemes: 100,\n            },\n            description: {\n              type: 'string',\n              description: 'Optional description for this location',\n              maxLength: 2000,\n              maxGraphemes: 500,\n            },\n            createdAt: {\n              type: 'string',\n              format: 'datetime',\n              description:\n                'Client-declared timestamp when this record was originally created',\n            },\n          },\n        },\n      },\n    },\n  },\n  OrgHypercertsClaimClaim: {\n    lexicon: 1,\n    id: 'org.hypercerts.claim.claim',\n    defs: {\n      main: {\n        type: 'record',\n        description: 'A hypercert record tracking impact work.',\n        key: 'any',\n        record: {\n          type: 'object',\n          required: [\n            'title',\n            'shortDescription',\n            'createdAt',\n            'workScope',\n            'workTimeFrameFrom',\n            'workTimeFrameTo',\n          ],\n          properties: {\n            title: {\n              type: 'string',\n              description: 'Title of the hypercert',\n              maxLength: 256,\n            },\n            shortDescription: {\n              type: 'string',\n              description: 'Short blurb of the impact work done.',\n              maxLength: 3000,\n              maxGraphemes: 300,\n            },\n            description: {\n              type: 'string',\n              description:\n                'Optional longer description of the impact work done.',\n              maxLength: 30000,\n              maxGraphemes: 3000,\n            },\n            image: {\n              type: 'union',\n              refs: [\n                'lex:org.hypercerts.defs#uri',\n                'lex:org.hypercerts.defs#smallImage',\n              ],\n              description:\n                'The hypercert visual representation as a URI or image blob',\n            },\n            workScope: {\n              type: 'string',\n              description: 'Scope of the work performed',\n              maxLength: 5000,\n              maxGraphemes: 1000,\n            },\n            workTimeFrameFrom: {\n              type: 'string',\n              format: 'datetime',\n              description: 'When the work began',\n            },\n            workTimeFrameTo: {\n              type: 'string',\n              format: 'datetime',\n              description: 'When the work ended',\n            },\n            evidence: {\n              type: 'array',\n              description:\n                'Supporting evidence, documentation, or external data URIs',\n              items: {\n                type: 'ref',\n                ref: 'lex:com.atproto.repo.strongRef',\n                description:\n                  'A strong reference to the evidence that supports this impact claim. The record referenced must conform with the org.hypercerts.claim.evidence lexicon',\n              },\n              maxLength: 100,\n            },\n            contributions: {\n              type: 'array',\n              description:\n                'A strong reference to the contributions done to create the impact in the hypercerts. The record referenced must conform with the lexicon org.hypercerts.claim.contributions',\n              items: {\n                type: 'ref',\n                ref: 'lex:com.atproto.repo.strongRef',\n              },\n            },\n            rights: {\n              type: 'ref',\n              ref: 'lex:com.atproto.repo.strongRef',\n              description:\n                'A strong reference to the rights that this hypercert has. The record referenced must conform with the lexicon org.hypercerts.claim.rights',\n            },\n            location: {\n              type: 'ref',\n              ref: 'lex:com.atproto.repo.strongRef',\n              description:\n                'A strong reference to the location where the work for done hypercert was located. The record referenced must conform with the lexicon org.hypercerts.claim.location',\n            },\n            createdAt: {\n              type: 'string',\n              format: 'datetime',\n              description:\n                'Client-declared timestamp when this record was originally created',\n            },\n          },\n        },\n      },\n    },\n  },\n  OrgHypercertsClaimContribution: {\n    lexicon: 1,\n    id: 'org.hypercerts.claim.contribution',\n    defs: {\n      main: {\n        type: 'record',\n        description: \"A contribution made toward a hypercert's impact.\",\n        key: 'any',\n        record: {\n          type: 'object',\n          required: ['hypercert', 'contributors', 'createdAt'],\n          properties: {\n            hypercert: {\n              type: 'ref',\n              ref: 'lex:com.atproto.repo.strongRef',\n              description:\n                'A strong reference to the hypercert this contribution is for. The record referenced must conform with the lexicon org.hypercerts.claim.',\n            },\n            role: {\n              type: 'string',\n              description: 'Role or title of the contributor(s).',\n              maxLength: 100,\n            },\n            contributors: {\n              type: 'array',\n              description:\n                'List of the contributors (names, pseudonyms, or DIDs). If multiple contributors are stored in the same hypercertContribution, then they would have the exact same role.',\n              items: {\n                type: 'string',\n              },\n            },\n            description: {\n              type: 'string',\n              description: 'What the contribution concretely achieved',\n              maxLength: 2000,\n              maxGraphemes: 500,\n            },\n            workTimeframeFrom: {\n              type: 'string',\n              format: 'datetime',\n              description:\n                'When this contribution started. This should be a subset of the hypercert timeframe.',\n            },\n            workTimeframeTo: {\n              type: 'string',\n              format: 'datetime',\n              description:\n                'When this contribution finished.  This should be a subset of the hypercert timeframe.',\n            },\n            createdAt: {\n              type: 'string',\n              format: 'datetime',\n              description:\n                'Client-declared timestamp when this record was originally created',\n            },\n          },\n        },\n      },\n    },\n  },\n  OrgHypercertsClaimEvaluation: {\n    lexicon: 1,\n    id: 'org.hypercerts.claim.evaluation',\n    defs: {\n      main: {\n        type: 'record',\n        description: 'An evaluation of a hypercert or other claim',\n        key: 'tid',\n        record: {\n          type: 'object',\n          required: ['subject', 'evaluators', 'summary', 'createdAt'],\n          properties: {\n            subject: {\n              type: 'ref',\n              ref: 'lex:com.atproto.repo.strongRef',\n              description:\n                'A strong reference to the evaluated claim. (e.g measurement, hypercert, contribution, etc)',\n            },\n            evaluators: {\n              type: 'array',\n              description: 'DIDs of the evaluators',\n              items: {\n                type: 'string',\n                format: 'did',\n              },\n              maxLength: 100,\n            },\n            evaluations: {\n              type: 'array',\n              description:\n                'Evaluation data (URIs or blobs) containing detailed reports or methodology',\n              items: {\n                type: 'union',\n                refs: [\n                  'lex:org.hypercerts.defs#uri',\n                  'lex:org.hypercerts.defs#smallBlob',\n                ],\n              },\n              maxLength: 100,\n            },\n            summary: {\n              type: 'string',\n              description: 'Brief evaluation summary',\n              maxLength: 5000,\n              maxGraphemes: 1000,\n            },\n            createdAt: {\n              type: 'string',\n              format: 'datetime',\n              description:\n                'Client-declared timestamp when this record was originally created',\n            },\n          },\n        },\n      },\n    },\n  },\n  OrgHypercertsClaimEvidence: {\n    lexicon: 1,\n    id: 'org.hypercerts.claim.evidence',\n    defs: {\n      main: {\n        type: 'record',\n        description: 'A piece of evidence supporting a hypercert claim',\n        key: 'any',\n        record: {\n          type: 'object',\n          required: ['content', 'shortDescription', 'createdAt'],\n          properties: {\n            content: {\n              type: 'union',\n              refs: [\n                'lex:org.hypercerts.defs#uri',\n                'lex:org.hypercerts.defs#smallBlob',\n              ],\n              description:\n                'A piece of evidence (URI or blobs) supporting a hypercert claim',\n            },\n            title: {\n              type: 'string',\n              maxLength: 256,\n              description:\n                'Optional title to describe the nature of the evidence',\n            },\n            shortDescription: {\n              type: 'string',\n              maxLength: 3000,\n              maxGraphemes: 300,\n              description:\n                'Short description explaining what this evidence demonstrates or proves',\n            },\n            description: {\n              type: 'string',\n              description:\n                'Optional longer description describing the impact claim evidence.',\n              maxLength: 30000,\n              maxGraphemes: 3000,\n            },\n            createdAt: {\n              type: 'string',\n              format: 'datetime',\n              description:\n                'Client-declared timestamp when this hypercert claim was originally created',\n            },\n          },\n        },\n      },\n    },\n  },\n  OrgHypercertsClaimMeasurement: {\n    lexicon: 1,\n    id: 'org.hypercerts.claim.measurement',\n    defs: {\n      main: {\n        type: 'record',\n        description: 'External measurement data supporting a hypercert claim',\n        key: 'tid',\n        record: {\n          type: 'object',\n          required: ['hypercert', 'measurers', 'metric', 'value', 'createdAt'],\n          properties: {\n            hypercert: {\n              type: 'ref',\n              ref: 'lex:com.atproto.repo.strongRef',\n              description:\n                'A strong reference to the hypercert that this measurement is for. The record referenced must conform with the lexicon org.hypercerts.claim.',\n            },\n            measurers: {\n              type: 'array',\n              description:\n                'DIDs of the entity (or entities) that measured this data',\n              items: {\n                type: 'string',\n                format: 'did',\n              },\n              maxLength: 100,\n            },\n            metric: {\n              type: 'string',\n              description: 'The metric being measured',\n              maxLength: 500,\n            },\n            value: {\n              type: 'string',\n              description: 'The measured value',\n              maxLength: 500,\n            },\n            measurementMethodURI: {\n              type: 'string',\n              format: 'uri',\n              description:\n                'URI to methodology documentation, standard protocol, or measurement procedure',\n            },\n            evidenceURI: {\n              type: 'array',\n              description: 'URIs to supporting evidence or data',\n              items: {\n                type: 'string',\n                format: 'uri',\n              },\n              maxLength: 50,\n            },\n            createdAt: {\n              type: 'string',\n              format: 'datetime',\n              description:\n                'Client-declared timestamp when this record was originally created',\n            },\n          },\n        },\n      },\n    },\n  },\n  OrgHypercertsClaimRights: {\n    lexicon: 1,\n    id: 'org.hypercerts.claim.rights',\n    defs: {\n      main: {\n        type: 'record',\n        description:\n          'Describes the rights that a user has with a hypercert, such as whether it can be sold, transferred, and under what conditions.',\n        key: 'any',\n        record: {\n          type: 'object',\n          required: [\n            'rightsName',\n            'rightsType',\n            'rightsDescription',\n            'createdAt',\n          ],\n          properties: {\n            rightsName: {\n              type: 'string',\n              description: 'Full name of the rights',\n              maxLength: 100,\n            },\n            rightsType: {\n              type: 'string',\n              description: 'Short rights identifier for easier search',\n              maxLength: 10,\n            },\n            rightsDescription: {\n              type: 'string',\n              description: 'Description of the rights of this hypercert',\n            },\n            createdAt: {\n              type: 'string',\n              format: 'datetime',\n              description:\n                'Client-declared timestamp when this record was originally created',\n            },\n          },\n        },\n      },\n    },\n  },\n  OrgHypercertsCollection: {\n    lexicon: 1,\n    id: 'org.hypercerts.collection',\n    defs: {\n      main: {\n        type: 'record',\n        description:\n          'A collection/group of hypercerts that have a specific property.',\n        key: 'tid',\n        record: {\n          type: 'object',\n          required: ['title', 'claims', 'createdAt'],\n          properties: {\n            title: {\n              type: 'string',\n              description: 'The title of this collection',\n              maxLength: 800,\n              maxGraphemes: 80,\n            },\n            shortDescription: {\n              type: 'string',\n              maxLength: 3000,\n              maxGraphemes: 300,\n              description: 'A short description of this collection',\n            },\n            coverPhoto: {\n              type: 'union',\n              refs: [\n                'lex:org.hypercerts.defs#uri',\n                'lex:org.hypercerts.defs#smallBlob',\n              ],\n              description:\n                'The cover photo of this collection (either in URI format or in a blob).',\n            },\n            claims: {\n              type: 'array',\n              description:\n                'Array of claims with their associated weights in this collection',\n              items: {\n                type: 'ref',\n                ref: 'lex:org.hypercerts.collection#claimItem',\n              },\n            },\n            createdAt: {\n              type: 'string',\n              format: 'datetime',\n              description:\n                'Client-declared timestamp when this record was originally created',\n            },\n          },\n        },\n      },\n      claimItem: {\n        type: 'object',\n        required: ['claim', 'weight'],\n        properties: {\n          claim: {\n            type: 'ref',\n            ref: 'lex:com.atproto.repo.strongRef',\n            description:\n              'A strong reference to a hypercert claim record. This claim must conform to the lexicon org.hypercerts.claim.record',\n          },\n          weight: {\n            type: 'string',\n            description:\n              'The weight/importance of this hypercert claim in the collection (a percentage from 0-100, stored as a string to avoid float precision issues). The total claim weights should add up to 100.',\n          },\n        },\n      },\n    },\n  },\n  OrgHypercertsDefs: {\n    lexicon: 1,\n    id: 'org.hypercerts.defs',\n    defs: {\n      uri: {\n        type: 'object',\n        required: ['uri'],\n        description: 'Object containing a URI to external data',\n        properties: {\n          uri: {\n            type: 'string',\n            format: 'uri',\n            maxGraphemes: 1024,\n            description: 'URI to external data',\n          },\n        },\n      },\n      smallBlob: {\n        type: 'object',\n        required: ['blob'],\n        description: 'Object containing a blob to external data',\n        properties: {\n          blob: {\n            type: 'blob',\n            accept: ['*/*'],\n            maxSize: 10485760,\n            description: 'Blob to external data (up to 10MB)',\n          },\n        },\n      },\n      largeBlob: {\n        type: 'object',\n        required: ['blob'],\n        description: 'Object containing a blob to external data',\n        properties: {\n          blob: {\n            type: 'blob',\n            accept: ['*/*'],\n            maxSize: 104857600,\n            description: 'Blob to external data (up to 100MB)',\n          },\n        },\n      },\n      smallImage: {\n        type: 'object',\n        required: ['image'],\n        description: 'Object containing a small image',\n        properties: {\n          image: {\n            type: 'blob',\n            accept: ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'],\n            maxSize: 5242880,\n            description: 'Image (up to 5MB)',\n          },\n        },\n      },\n      largeImage: {\n        type: 'object',\n        required: ['image'],\n        description: 'Object containing a large image',\n        properties: {\n          image: {\n            type: 'blob',\n            accept: ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'],\n            maxSize: 10485760,\n            description: 'Image (up to 10MB)',\n          },\n        },\n      },\n    },\n  },\n  AppGainforestCommonDefs: {\n    lexicon: 1,\n    id: 'app.gainforest.common.defs',\n    defs: {\n      uri: {\n        type: 'object',\n        required: ['uri'],\n        description: 'Object containing a URI to external data',\n        properties: {\n          uri: {\n            type: 'string',\n            format: 'uri',\n            maxGraphemes: 1024,\n            description: 'URI to external data',\n          },\n        },\n      },\n      smallBlob: {\n        type: 'object',\n        required: ['blob'],\n        description: 'Object containing a blob to external data',\n        properties: {\n          blob: {\n            type: 'blob',\n            accept: ['*/*'],\n            maxSize: 10485760,\n            description: 'Blob to external data (up to 10MB)',\n          },\n        },\n      },\n      largeBlob: {\n        type: 'object',\n        required: ['blob'],\n        description: 'Object containing a blob to external data',\n        properties: {\n          blob: {\n            type: 'blob',\n            accept: ['*/*'],\n            maxSize: 104857600,\n            description: 'Blob to external data (up to 100MB)',\n          },\n        },\n      },\n      smallImage: {\n        type: 'object',\n        required: ['image'],\n        description: 'Object containing a small image',\n        properties: {\n          image: {\n            type: 'blob',\n            accept: ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'],\n            maxSize: 5242880,\n            description: 'Image (up to 5MB)',\n          },\n        },\n      },\n      largeImage: {\n        type: 'object',\n        required: ['image'],\n        description: 'Object containing a large image',\n        properties: {\n          image: {\n            type: 'blob',\n            accept: ['image/jpeg', 'image/jpg', 'image/png', 'image/webp'],\n            maxSize: 10485760,\n            description: 'Image (up to 10MB)',\n          },\n        },\n      },\n      indexedOrganization: {\n        type: 'object',\n        required: ['id', 'name'],\n        properties: {\n          id: {\n            type: 'string',\n            format: 'uri',\n            description: 'The URI of the organization',\n          },\n          name: {\n            type: 'string',\n            description: 'The name of the organization',\n          },\n        },\n      },\n    },\n  },\n  AppGainforestOrganizationDefaultSite: {\n    lexicon: 1,\n    id: 'app.gainforest.organization.defaultSite',\n    defs: {\n      main: {\n        type: 'record',\n        description: 'A declaration of the default site for an organization',\n        key: 'literal:self',\n        record: {\n          type: 'object',\n          required: ['site'],\n          properties: {\n            site: {\n              type: 'string',\n              format: 'at-uri',\n              description:\n                'The reference to the default site record in the PDS',\n            },\n          },\n        },\n      },\n    },\n  },\n  AppGainforestOrganizationGetIndexedOrganizations: {\n    lexicon: 1,\n    id: 'app.gainforest.organization.getIndexedOrganizations',\n    defs: {\n      main: {\n        type: 'query',\n        description: 'Get all organizations to view initially on map',\n        parameters: {\n          type: 'params',\n          properties: {},\n        },\n        output: {\n          encoding: 'application/json',\n          schema: {\n            type: 'object',\n            required: ['organizations'],\n            properties: {\n              organizations: {\n                type: 'array',\n                items: {\n                  type: 'ref',\n                  ref: 'lex:app.gainforest.common.defs#indexedOrganization',\n                },\n              },\n            },\n          },\n        },\n      },\n    },\n  },\n  AppGainforestOrganizationInfo: {\n    lexicon: 1,\n    id: 'app.gainforest.organization.info',\n    defs: {\n      main: {\n        type: 'record',\n        description: 'A declaration of an organization or project',\n        key: 'literal:self',\n        record: {\n          type: 'object',\n          required: [\n            'displayName',\n            'shortDescription',\n            'longDescription',\n            'objectives',\n            'country',\n            'visibility',\n          ],\n          properties: {\n            displayName: {\n              type: 'string',\n              description: 'The name of the organization or project',\n              minLength: 8,\n              maxLength: 255,\n            },\n            shortDescription: {\n              type: 'string',\n              description: 'The description of the organization or project',\n              minLength: 50,\n              maxLength: 2000,\n            },\n            longDescription: {\n              type: 'string',\n              description:\n                'The long description of the organization or project in markdown',\n              minLength: 50,\n              maxLength: 5000,\n            },\n            coverImage: {\n              type: 'ref',\n              ref: 'lex:app.gainforest.common.defs#smallImage',\n              description: 'Cover image for the organization',\n            },\n            logo: {\n              type: 'ref',\n              ref: 'lex:app.gainforest.common.defs#smallImage',\n              description: 'Logo for the organization',\n            },\n            objectives: {\n              type: 'array',\n              description: 'The objectives of the organization or project',\n              items: {\n                type: 'string',\n                enum: [\n                  'Conservation',\n                  'Research',\n                  'Education',\n                  'Community',\n                  'Other',\n                ],\n              },\n            },\n            startDate: {\n              type: 'string',\n              description: 'The start date of the organization or project',\n              format: 'datetime',\n            },\n            website: {\n              type: 'string',\n              description: 'The website of the organization or project',\n              format: 'uri',\n            },\n            country: {\n              type: 'string',\n              description:\n                'The country of the organization or project in two letter code (ISO 3166-1 alpha-2)',\n            },\n            visibility: {\n              type: 'string',\n              description:\n                'The visibility of the organization or project in the Green Globe',\n              enum: ['Public', 'Hidden'],\n            },\n          },\n        },\n      },\n    },\n  },\n  AppGainforestOrganizationMeasuredTrees: {\n    lexicon: 1,\n    id: 'app.gainforest.organization.measuredTrees',\n    defs: {\n      main: {\n        type: 'record',\n        description: 'A declaration of measured trees for an organization',\n        key: 'literal:self',\n        record: {\n          type: 'object',\n          required: ['shapefile'],\n          properties: {\n            shapefile: {\n              type: 'string',\n              format: 'uri',\n              description:\n                'The uri pointing to the shapefile of the measured trees',\n            },\n          },\n        },\n      },\n    },\n  },\n  AppGainforestOrganizationSite: {\n    lexicon: 1,\n    id: 'app.gainforest.organization.site',\n    defs: {\n      main: {\n        type: 'record',\n        description: 'A declaration of a site for an organization',\n        key: 'tid',\n        record: {\n          type: 'object',\n          required: ['name', 'lat', 'lon', 'area', 'shapefile'],\n          properties: {\n            name: {\n              type: 'string',\n              description: 'The name of the site',\n            },\n            lat: {\n              type: 'string',\n              description: 'The latitude of the centerpoint of the site',\n            },\n            lon: {\n              type: 'string',\n              description: 'The longitude of the centerpoint of the site',\n            },\n            area: {\n              type: 'string',\n              description: 'The area of the site in hectares',\n            },\n            shapefile: {\n              type: 'union',\n              refs: [\n                'lex:app.gainforest.common.defs#uri',\n                'lex:app.gainforest.common.defs#smallBlob',\n              ],\n              description:\n                'URI or blob pointing to a geoJSON file containing the site boundaries',\n            },\n            trees: {\n              type: 'union',\n              refs: [\n                'lex:app.gainforest.common.defs#uri',\n                'lex:app.gainforest.common.defs#smallBlob',\n              ],\n              description:\n                'URI or blob pointing to GeoJSON data containing tree planting data for this site',\n            },\n          },\n        },\n      },\n    },\n  },\n  ComAtprotoRepoStrongRef: {\n    lexicon: 1,\n    id: 'com.atproto.repo.strongRef',\n    description: 'A URI with a content-hash fingerprint.',\n    defs: {\n      main: {\n        type: 'object',\n        required: ['uri', 'cid'],\n        properties: {\n          uri: {\n            type: 'string',\n            format: 'at-uri',\n          },\n          cid: {\n            type: 'string',\n            format: 'cid',\n          },\n        },\n      },\n    },\n  },\n} as const satisfies Record<string, LexiconDoc>\nexport const schemas = Object.values(schemaDict) satisfies LexiconDoc[]\nexport const lexicons: Lexicons = new Lexicons(schemas)\n\nexport function validate<T extends { $type: string }>(\n  v: unknown,\n  id: string,\n  hash: string,\n  requiredType: true,\n): ValidationResult<T>\nexport function validate<T extends { $type?: string }>(\n  v: unknown,\n  id: string,\n  hash: string,\n  requiredType?: false,\n): ValidationResult<T>\nexport function validate(\n  v: unknown,\n  id: string,\n  hash: string,\n  requiredType?: boolean,\n): ValidationResult {\n  return (requiredType ? is$typed : maybe$typed)(v, id, hash)\n    ? lexicons.validate(`${id}#${hash}`, v)\n    : {\n        success: false,\n        error: new ValidationError(\n          `Must be an object with \"${hash === 'main' ? id : `${id}#${hash}`}\" $type property`,\n        ),\n      }\n}\n\nexport const ids = {\n  AppCertifiedLocation: 'app.certified.location',\n  OrgHypercertsClaimClaim: 'org.hypercerts.claim.claim',\n  OrgHypercertsClaimContribution: 'org.hypercerts.claim.contribution',\n  OrgHypercertsClaimEvaluation: 'org.hypercerts.claim.evaluation',\n  OrgHypercertsClaimEvidence: 'org.hypercerts.claim.evidence',\n  OrgHypercertsClaimMeasurement: 'org.hypercerts.claim.measurement',\n  OrgHypercertsClaimRights: 'org.hypercerts.claim.rights',\n  OrgHypercertsCollection: 'org.hypercerts.collection',\n  OrgHypercertsDefs: 'org.hypercerts.defs',\n  AppGainforestCommonDefs: 'app.gainforest.common.defs',\n  AppGainforestOrganizationDefaultSite:\n    'app.gainforest.organization.defaultSite',\n  AppGainforestOrganizationGetIndexedOrganizations:\n    'app.gainforest.organization.getIndexedOrganizations',\n  AppGainforestOrganizationInfo: 'app.gainforest.organization.info',\n  AppGainforestOrganizationMeasuredTrees:\n    'app.gainforest.organization.measuredTrees',\n  AppGainforestOrganizationSite: 'app.gainforest.organization.site',\n  ComAtprotoRepoStrongRef: 'com.atproto.repo.strongRef',\n} as const\n","/**\n * GENERATED CODE - DO NOT MODIFY\n */\n\nimport { type ValidationResult } from '@atproto/lexicon'\n\nexport type OmitKey<T, K extends keyof T> = {\n  [K2 in keyof T as K2 extends K ? never : K2]: T[K2]\n}\n\nexport type $Typed<V, T extends string = string> = V & { $type: T }\nexport type Un$Typed<V extends { $type?: string }> = OmitKey<V, '$type'>\n\nexport type $Type<Id extends string, Hash extends string> = Hash extends 'main'\n  ? Id\n  : `${Id}#${Hash}`\n\nfunction isObject<V>(v: V): v is V & object {\n  return v != null && typeof v === 'object'\n}\n\nfunction is$type<Id extends string, Hash extends string>(\n  $type: unknown,\n  id: Id,\n  hash: Hash,\n): $type is $Type<Id, Hash> {\n  return hash === 'main'\n    ? $type === id\n    : // $type === `${id}#${hash}`\n      typeof $type === 'string' &&\n        $type.length === id.length + 1 + hash.length &&\n        $type.charCodeAt(id.length) === 35 /* '#' */ &&\n        $type.startsWith(id) &&\n        $type.endsWith(hash)\n}\n\nexport type $TypedObject<\n  V,\n  Id extends string,\n  Hash extends string,\n> = V extends {\n  $type: $Type<Id, Hash>\n}\n  ? V\n  : V extends { $type?: string }\n    ? V extends { $type?: infer T extends $Type<Id, Hash> }\n      ? V & { $type: T }\n      : never\n    : V & { $type: $Type<Id, Hash> }\n\nexport function is$typed<V, Id extends string, Hash extends string>(\n  v: V,\n  id: Id,\n  hash: Hash,\n): v is $TypedObject<V, Id, Hash> {\n  return isObject(v) && '$type' in v && is$type(v.$type, id, hash)\n}\n\nexport function maybe$typed<V, Id extends string, Hash extends string>(\n  v: V,\n  id: Id,\n  hash: Hash,\n): v is V & object & { $type?: $Type<Id, Hash> } {\n  return (\n    isObject(v) &&\n    ('$type' in v ? v.$type === undefined || is$type(v.$type, id, hash) : true)\n  )\n}\n\nexport type Validator<R = unknown> = (v: unknown) => ValidationResult<R>\nexport type ValidatorParam<V extends Validator> =\n  V extends Validator<infer R> ? R : never\n\n/**\n * Utility function that allows to convert a \"validate*\" utility function into a\n * type predicate.\n */\nexport function asPredicate<V extends Validator>(validate: V) {\n  return function <T>(v: T): v is T & ValidatorParam<V> {\n    return validate(v).success\n  }\n}\n","/**\n * GENERATED CODE - DO NOT MODIFY\n */\nimport { type ValidationResult, BlobRef } from '@atproto/lexicon'\nimport { CID } from 'multiformats/cid'\nimport { validate as _validate } from '../../../lexicons'\nimport { type $Typed, is$typed as _is$typed, type OmitKey } from '../../../util'\nimport type * as OrgHypercertsDefs from '../../org/hypercerts/defs.js'\n\nconst is$typed = _is$typed,\n  validate = _validate\nconst id = 'app.certified.location'\n\nexport interface Main {\n  $type: 'app.certified.location'\n  /** The version of the Location Protocol */\n  lpVersion: string\n  /** The Spatial Reference System URI (e.g., http://www.opengis.net/def/crs/OGC/1.3/CRS84) that defines the coordinate system. */\n  srs: string\n  /** An identifier for the format of the location data (e.g., coordinate-decimal, geojson-point) */\n  locationType: 'coordinate-decimal' | 'geojson-point' | (string & {})\n  location:\n    | $Typed<OrgHypercertsDefs.Uri>\n    | $Typed<OrgHypercertsDefs.SmallBlob>\n    | { $type: string }\n  /** Optional name for this location */\n  name?: string\n  /** Optional description for this location */\n  description?: string\n  /** Client-declared timestamp when this record was originally created */\n  createdAt: string\n  [k: string]: unknown\n}\n\nconst hashMain = 'main'\n\nexport function isMain<V>(v: V) {\n  return is$typed(v, id, hashMain)\n}\n\nexport function validateMain<V>(v: V) {\n  return validate<Main & V>(v, id, hashMain, true)\n}\n\nexport {\n  type Main as Record,\n  isMain as isRecord,\n  validateMain as validateRecord,\n}\n","/**\n * GENERATED CODE - DO NOT MODIFY\n */\nimport { type ValidationResult, BlobRef } from '@atproto/lexicon'\nimport { CID } from 'multiformats/cid'\nimport { validate as _validate } from '../../../../lexicons'\nimport {\n  type $Typed,\n  is$typed as _is$typed,\n  type OmitKey,\n} from '../../../../util'\nimport type * as OrgHypercertsDefs from '../defs.js'\nimport type * as ComAtprotoRepoStrongRef from '../../../com/atproto/repo/strongRef.js'\n\nconst is$typed = _is$typed,\n  validate = _validate\nconst id = 'org.hypercerts.claim.claim'\n\nexport interface Main {\n  $type: 'org.hypercerts.claim.claim'\n  /** Title of the hypercert */\n  title: string\n  /** Short blurb of the impact work done. */\n  shortDescription: string\n  /** Optional longer description of the impact work done. */\n  description?: string\n  image?:\n    | $Typed<OrgHypercertsDefs.Uri>\n    | $Typed<OrgHypercertsDefs.SmallImage>\n    | { $type: string }\n  /** Scope of the work performed */\n  workScope: string\n  /** When the work began */\n  workTimeFrameFrom: string\n  /** When the work ended */\n  workTimeFrameTo: string\n  /** Supporting evidence, documentation, or external data URIs */\n  evidence?: ComAtprotoRepoStrongRef.Main[]\n  /** A strong reference to the contributions done to create the impact in the hypercerts. The record referenced must conform with the lexicon org.hypercerts.claim.contributions */\n  contributions?: ComAtprotoRepoStrongRef.Main[]\n  rights?: ComAtprotoRepoStrongRef.Main\n  location?: ComAtprotoRepoStrongRef.Main\n  /** Client-declared timestamp when this record was originally created */\n  createdAt: string\n  [k: string]: unknown\n}\n\nconst hashMain = 'main'\n\nexport function isMain<V>(v: V) {\n  return is$typed(v, id, hashMain)\n}\n\nexport function validateMain<V>(v: V) {\n  return validate<Main & V>(v, id, hashMain, true)\n}\n\nexport {\n  type Main as Record,\n  isMain as isRecord,\n  validateMain as validateRecord,\n}\n","/**\n * GENERATED CODE - DO NOT MODIFY\n */\nimport { type ValidationResult, BlobRef } from '@atproto/lexicon'\nimport { CID } from 'multiformats/cid'\nimport { validate as _validate } from '../../../../lexicons'\nimport {\n  type $Typed,\n  is$typed as _is$typed,\n  type OmitKey,\n} from '../../../../util'\nimport type * as ComAtprotoRepoStrongRef from '../../../com/atproto/repo/strongRef.js'\n\nconst is$typed = _is$typed,\n  validate = _validate\nconst id = 'org.hypercerts.claim.contribution'\n\nexport interface Main {\n  $type: 'org.hypercerts.claim.contribution'\n  hypercert: ComAtprotoRepoStrongRef.Main\n  /** Role or title of the contributor(s). */\n  role?: string\n  /** List of the contributors (names, pseudonyms, or DIDs). If multiple contributors are stored in the same hypercertContribution, then they would have the exact same role. */\n  contributors: string[]\n  /** What the contribution concretely achieved */\n  description?: string\n  /** When this contribution started. This should be a subset of the hypercert timeframe. */\n  workTimeframeFrom?: string\n  /** When this contribution finished.  This should be a subset of the hypercert timeframe. */\n  workTimeframeTo?: string\n  /** Client-declared timestamp when this record was originally created */\n  createdAt: string\n  [k: string]: unknown\n}\n\nconst hashMain = 'main'\n\nexport function isMain<V>(v: V) {\n  return is$typed(v, id, hashMain)\n}\n\nexport function validateMain<V>(v: V) {\n  return validate<Main & V>(v, id, hashMain, true)\n}\n\nexport {\n  type Main as Record,\n  isMain as isRecord,\n  validateMain as validateRecord,\n}\n","/**\n * GENERATED CODE - DO NOT MODIFY\n */\nimport { type ValidationResult, BlobRef } from '@atproto/lexicon'\nimport { CID } from 'multiformats/cid'\nimport { validate as _validate } from '../../../../lexicons'\nimport {\n  type $Typed,\n  is$typed as _is$typed,\n  type OmitKey,\n} from '../../../../util'\n\nconst is$typed = _is$typed,\n  validate = _validate\nconst id = 'app.gainforest.organization.defaultSite'\n\nexport interface Main {\n  $type: 'app.gainforest.organization.defaultSite'\n  /** The reference to the default site record in the PDS */\n  site: string\n  [k: string]: unknown\n}\n\nconst hashMain = 'main'\n\nexport function isMain<V>(v: V) {\n  return is$typed(v, id, hashMain)\n}\n\nexport function validateMain<V>(v: V) {\n  return validate<Main & V>(v, id, hashMain, true)\n}\n\nexport {\n  type Main as Record,\n  isMain as isRecord,\n  validateMain as validateRecord,\n}\n","/**\n * GENERATED CODE - DO NOT MODIFY\n */\nimport { type ValidationResult, BlobRef } from '@atproto/lexicon'\nimport { CID } from 'multiformats/cid'\nimport { validate as _validate } from '../../../../lexicons'\nimport {\n  type $Typed,\n  is$typed as _is$typed,\n  type OmitKey,\n} from '../../../../util'\nimport type * as AppGainforestCommonDefs from '../common/defs.js'\n\nconst is$typed = _is$typed,\n  validate = _validate\nconst id = 'app.gainforest.organization.info'\n\nexport interface Main {\n  $type: 'app.gainforest.organization.info'\n  /** The name of the organization or project */\n  displayName: string\n  /** The description of the organization or project */\n  shortDescription: string\n  /** The long description of the organization or project in markdown */\n  longDescription: string\n  coverImage?: AppGainforestCommonDefs.SmallImage\n  logo?: AppGainforestCommonDefs.SmallImage\n  /** The objectives of the organization or project */\n  objectives: (\n    | 'Conservation'\n    | 'Research'\n    | 'Education'\n    | 'Community'\n    | 'Other'\n  )[]\n  /** The start date of the organization or project */\n  startDate?: string\n  /** The website of the organization or project */\n  website?: string\n  /** The country of the organization or project in two letter code (ISO 3166-1 alpha-2) */\n  country: string\n  /** The visibility of the organization or project in the Green Globe */\n  visibility: 'Public' | 'Hidden'\n  [k: string]: unknown\n}\n\nconst hashMain = 'main'\n\nexport function isMain<V>(v: V) {\n  return is$typed(v, id, hashMain)\n}\n\nexport function validateMain<V>(v: V) {\n  return validate<Main & V>(v, id, hashMain, true)\n}\n\nexport {\n  type Main as Record,\n  isMain as isRecord,\n  validateMain as validateRecord,\n}\n","/**\n * GENERATED CODE - DO NOT MODIFY\n */\nimport { type ValidationResult, BlobRef } from '@atproto/lexicon'\nimport { CID } from 'multiformats/cid'\nimport { validate as _validate } from '../../../../lexicons'\nimport {\n  type $Typed,\n  is$typed as _is$typed,\n  type OmitKey,\n} from '../../../../util'\n\nconst is$typed = _is$typed,\n  validate = _validate\nconst id = 'app.gainforest.organization.measuredTrees'\n\nexport interface Main {\n  $type: 'app.gainforest.organization.measuredTrees'\n  /** The uri pointing to the shapefile of the measured trees */\n  shapefile: string\n  [k: string]: unknown\n}\n\nconst hashMain = 'main'\n\nexport function isMain<V>(v: V) {\n  return is$typed(v, id, hashMain)\n}\n\nexport function validateMain<V>(v: V) {\n  return validate<Main & V>(v, id, hashMain, true)\n}\n\nexport {\n  type Main as Record,\n  isMain as isRecord,\n  validateMain as validateRecord,\n}\n","/**\n * GENERATED CODE - DO NOT MODIFY\n */\nimport { type ValidationResult, BlobRef } from '@atproto/lexicon'\nimport { CID } from 'multiformats/cid'\nimport { validate as _validate } from '../../../../lexicons'\nimport {\n  type $Typed,\n  is$typed as _is$typed,\n  type OmitKey,\n} from '../../../../util'\nimport type * as AppGainforestCommonDefs from '../common/defs.js'\n\nconst is$typed = _is$typed,\n  validate = _validate\nconst id = 'app.gainforest.organization.site'\n\nexport interface Main {\n  $type: 'app.gainforest.organization.site'\n  /** The name of the site */\n  name: string\n  /** The latitude of the centerpoint of the site */\n  lat: string\n  /** The longitude of the centerpoint of the site */\n  lon: string\n  /** The area of the site in hectares */\n  area: string\n  shapefile:\n    | $Typed<AppGainforestCommonDefs.Uri>\n    | $Typed<AppGainforestCommonDefs.SmallBlob>\n    | { $type: string }\n  trees?:\n    | $Typed<AppGainforestCommonDefs.Uri>\n    | $Typed<AppGainforestCommonDefs.SmallBlob>\n    | { $type: string }\n  [k: string]: unknown\n}\n\nconst hashMain = 'main'\n\nexport function isMain<V>(v: V) {\n  return is$typed(v, id, hashMain)\n}\n\nexport function validateMain<V>(v: V) {\n  return validate<Main & V>(v, id, hashMain, true)\n}\n\nexport {\n  type Main as Record,\n  isMain as isRecord,\n  validateMain as validateRecord,\n}\n","import { XRPCError } from \"@atproto/xrpc\";\nimport { TRPCError } from \"@trpc/server\";\n\nexport const xrpcErrorToTRPCError = (error: XRPCError): TRPCError => {\n  if (error.error === \"InvalidRequest\") {\n    return new TRPCError({\n      code: \"BAD_REQUEST\",\n      message: \"This resource does not exist.\",\n    });\n  } else if (error.error === \"RecordNotFound\") {\n    return new TRPCError({\n      code: \"NOT_FOUND\",\n      message: \"The resource you are looking for does not exist.\",\n    });\n  } else {\n    return new TRPCError({\n      code: \"INTERNAL_SERVER_ERROR\",\n      message: \"An unknown error occurred.\",\n    });\n  }\n};\n","import type { ValidationResult } from \"@atproto/lexicon\";\nimport { TRPCError } from \"@trpc/server\";\n\nexport const validateRecordOrThrow = <T>(\n  record: T,\n  { validateRecord }: { validateRecord: (record: T) => ValidationResult<T> }\n) => {\n  const validation = validateRecord(record);\n  if (!validation.success) {\n    throw new TRPCError({\n      code: \"UNPROCESSABLE_CONTENT\",\n      message: validation.error.message,\n      cause: validation.error,\n    });\n  }\n  return record;\n};\n","import { publicProcedure } from \"@/server/trpc\";\nimport { z } from \"zod\";\nimport { getReadAgent } from \"@/server/utils/agent\";\nimport { AppGainforestOrganizationSite } from \"@/../lex-api\";\nimport { validateRecordOrThrow } from \"@/server/utils/validate-record-or-throw\";\nimport type { SupportedPDSDomain } from \"@/index\";\nimport type { GetRecordResponse } from \"@/server/utils/response-types\";\n\nexport const getSiteFactory = <T extends SupportedPDSDomain>(\n  allowedPDSDomainSchema: z.ZodEnum<Record<T, T>>\n) => {\n  return publicProcedure\n    .input(\n      z.object({\n        did: z.string(),\n        rkey: z.string(),\n        pdsDomain: allowedPDSDomainSchema,\n      })\n    )\n    .query(async ({ input }) => {\n      const agent = getReadAgent(input.pdsDomain);\n      const response = await agent.com.atproto.repo.getRecord({\n        collection: \"app.gainforest.organization.site\",\n        repo: input.did,\n        rkey: input.rkey,\n      });\n      if (response.success !== true) {\n        throw new Error(\"Failed to get the site.\");\n      }\n      validateRecordOrThrow(response.data.value, AppGainforestOrganizationSite);\n      return response.data as GetRecordResponse<AppGainforestOrganizationSite.Record>;\n    });\n};\n","import { publicProcedure } from \"@/server/trpc\";\nimport z from \"zod\";\nimport type { GetRecordResponse } from \"@/server/utils/response-types\";\nimport { AppGainforestOrganizationDefaultSite } from \"@/../lex-api\";\nimport { getReadAgent } from \"@/server/utils/agent\";\nimport type { SupportedPDSDomain } from \"@/index\";\nimport { validateRecordOrThrow } from \"@/server/utils/validate-record-or-throw\";\n\nexport const getDefaultProjectSiteFactory = <T extends SupportedPDSDomain>(\n  allowedPDSDomainSchema: z.ZodEnum<Record<T, T>>\n) => {\n  return publicProcedure\n    .input(\n      z.object({\n        did: z.string(),\n        pdsDomain: allowedPDSDomainSchema,\n      })\n    )\n    .query(async ({ input }) => {\n      const agent = getReadAgent(input.pdsDomain);\n      const response = await agent.com.atproto.repo.getRecord({\n        collection: \"app.gainforest.organization.defaultSite\",\n        repo: input.did,\n        rkey: \"self\",\n      });\n      if (response.success !== true) {\n        throw new Error(\"Failed to get default project site\");\n      }\n      validateRecordOrThrow(\n        response.data.value,\n        AppGainforestOrganizationDefaultSite\n      );\n      return response.data as GetRecordResponse<AppGainforestOrganizationDefaultSite.Record>;\n    });\n};\n","import { publicProcedure } from \"@/server/trpc\";\nimport z from \"zod\";\nimport type { GetRecordResponse } from \"@/server/utils/response-types\";\nimport { AppGainforestOrganizationMeasuredTrees } from \"@/../lex-api\";\nimport { getReadAgent } from \"@/server/utils/agent\";\nimport type { SupportedPDSDomain } from \"@/index\";\nimport { validateRecordOrThrow } from \"@/server/utils/validate-record-or-throw\";\n\nexport const getMeasuredTreesFactory = <T extends SupportedPDSDomain>(\n  allowedPDSDomainSchema: z.ZodEnum<Record<T, T>>\n) => {\n  return publicProcedure\n    .input(\n      z.object({\n        did: z.string(),\n        pdsDomain: allowedPDSDomainSchema,\n      })\n    )\n    .query(async ({ input }) => {\n      const agent = getReadAgent(input.pdsDomain);\n      const response = await agent.com.atproto.repo.getRecord({\n        collection: \"app.gainforest.organization.measuredTrees\",\n        repo: input.did,\n        rkey: \"self\",\n      });\n      if (response.success !== true) {\n        throw new Error(\"Failed to get measured trees\");\n      }\n      validateRecordOrThrow(\n        response.data.value,\n        AppGainforestOrganizationMeasuredTrees\n      );\n      return response.data as GetRecordResponse<AppGainforestOrganizationMeasuredTrees.Record>;\n    });\n};\n","import { protectedProcedure } from \"@/server/trpc\";\nimport z from \"zod\";\nimport { TRPCError } from \"@trpc/server\";\nimport { Agent } from \"@atproto/api\";\nimport {\n  AppCertifiedLocation,\n  OrgHypercertsClaimClaim,\n  OrgHypercertsClaimContribution,\n} from \"@/../lex-api\";\nimport { toBlobRef, toBlobRefGenerator } from \"@/zod-schemas/blobref\";\nimport { type FileGenerator, FileGeneratorSchema } from \"@/zod-schemas/file\";\nimport { getWriteAgent } from \"@/server/utils/agent\";\nimport { validateRecordOrThrow } from \"@/server/utils/validate-record-or-throw\";\nimport type { SupportedPDSDomain } from \"@/index\";\n\nconst uploadFile = async (fileGenerator: FileGenerator, agent: Agent) => {\n  const file = new File(\n    [Buffer.from(fileGenerator.dataBase64, \"base64\")],\n    fileGenerator.name,\n    { type: fileGenerator.type }\n  );\n  const response = await agent.uploadBlob(file);\n  return toBlobRefGenerator(response.data.blob);\n};\n\nexport const createHypercertClaimFactory = <T extends SupportedPDSDomain>(\n  allowedPDSDomainSchema: z.ZodEnum<Record<T, T>>\n) => {\n  return protectedProcedure\n    .input(\n      z.object({\n        claim: z.object({\n          title: z.string(),\n          shortDescription: z.string(),\n          description: z.string().optional(),\n          workScope: z.array(z.string()),\n          workTimeFrameFrom: z.string(),\n          workTimeFrameTo: z.string(),\n        }),\n        uploads: z.object({\n          image: FileGeneratorSchema,\n          contributors: z.array(z.string()).refine((v) => v.length > 0, {\n            message: \"At least one contribution is required\",\n          }),\n          siteAtUri: z.string(),\n        }),\n        pdsDomain: allowedPDSDomainSchema,\n      })\n    )\n    .mutation(async ({ input }) => {\n      const agent = await getWriteAgent(input.pdsDomain);\n      const did = agent.did;\n      if (!did) {\n        throw new TRPCError({\n          code: \"UNAUTHORIZED\",\n          message: \"You are not authorized to perform this action.\",\n        });\n      }\n\n      // Generate record data for validation before writing to the PDS:\n      // Location record\n      const locationNSID = \"app.certified.location\";\n      const location: AppCertifiedLocation.Record = {\n        $type: locationNSID,\n        lpVersion: \"1.0.0\",\n        srs: \"https://epsg.io/3857\",\n        locationType: \"geojson\",\n        location: {\n          $type: \"org.hypercerts.defs#uri\",\n          uri: input.uploads.siteAtUri,\n        },\n        createdAt: new Date().toISOString(),\n      };\n      const validatedLocation = validateRecordOrThrow(\n        location,\n        AppCertifiedLocation\n      );\n\n      // Claim record\n      const claimNSID = \"org.hypercerts.claim.claim\";\n      const claim: OrgHypercertsClaimClaim.Record = {\n        $type: claimNSID,\n        title: input.claim.title,\n        shortDescription: input.claim.shortDescription,\n        description: input.claim.description,\n        // These will be set after the records are created:\n        image: undefined,\n        location: undefined,\n        contributions: undefined,\n        // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n        workScope: input.claim.workScope.join(\", \"),\n        workTimeFrameFrom: input.claim.workTimeFrameFrom,\n        workTimeFrameTo: input.claim.workTimeFrameTo,\n        createdAt: new Date().toISOString(),\n      };\n      const validatedClaim = validateRecordOrThrow(\n        claim,\n        OrgHypercertsClaimClaim\n      );\n\n      // Contribution record\n      const contributionNSID = \"org.hypercerts.claim.contribution\";\n      const contribution: OrgHypercertsClaimContribution.Record = {\n        $type: \"org.hypercerts.claim.contribution\",\n        // Use dummy hypercert reference for now because the claim record is not yet created:\n        hypercert: {\n          $type: \"com.atproto.repo.strongRef\",\n          uri: `at://${did}/org.hypercerts.claim/0`,\n          cid: \"bafkreifj2t4px2uizj25ml53axem47yfhpgsx72ekjrm2qyymcn5ifz744\",\n        },\n        // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n        role: \"Contributor\",\n        contributors: input.uploads.contributors,\n        createdAt: new Date().toISOString(),\n      };\n      const validatedContribution = validateRecordOrThrow(\n        contribution,\n        OrgHypercertsClaimContribution\n      );\n\n      // Write records to the PDS\n      // 1. Write location to the PDS\n      const locationWriteResponse = await agent.com.atproto.repo.createRecord({\n        repo: did,\n        collection: locationNSID,\n        record: validatedLocation,\n      });\n      if (locationWriteResponse.success !== true) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to write location record\",\n        });\n      }\n      // 2. Upload image to the PDS\n      const imageBlobRef = await uploadFile(input.uploads.image, agent);\n      // 3. Write claim to the PDS\n      const claimResponse = await agent.com.atproto.repo.createRecord({\n        repo: did,\n        collection: claimNSID,\n        record: {\n          ...validatedClaim,\n          image: {\n            $type: \"org.hypercerts.defs#smallImage\",\n            image: toBlobRef(imageBlobRef),\n          },\n          location: {\n            $type: \"com.atproto.repo.strongRef\",\n            uri: locationWriteResponse.data.uri,\n            cid: locationWriteResponse.data.cid,\n          },\n        } satisfies OrgHypercertsClaimClaim.Record,\n      });\n      if (claimResponse.success !== true) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to write claim record\",\n        });\n      }\n      // 4. Write contribution to the PDS\n      const contributionWriteResponse =\n        await agent.com.atproto.repo.createRecord({\n          repo: did,\n          collection: contributionNSID,\n          record: {\n            ...validatedContribution,\n            hypercert: {\n              $type: \"com.atproto.repo.strongRef\",\n              uri: claimResponse.data.uri,\n              cid: claimResponse.data.cid,\n            },\n          } satisfies OrgHypercertsClaimContribution.Record,\n        });\n      if (contributionWriteResponse.success !== true) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to write contribution record\",\n        });\n      }\n\n      return claimResponse;\n    });\n};\n","import { protectedProcedure } from \"@/server/trpc\";\nimport z from \"zod\";\nimport { AppGainforestOrganizationInfo } from \"@/../lex-api\";\nimport type { PutRecordResponse } from \"@/server/utils/response-types\";\nimport { TRPCError } from \"@trpc/server\";\nimport { getWriteAgent } from \"@/server/utils/agent\";\nimport { FileGeneratorSchema } from \"@/zod-schemas/file\";\nimport { BlobRefGeneratorSchema, toBlobRef } from \"@/zod-schemas/blobref\";\nimport { uploadFileAsBlobPure } from \"../../common/uploadFileAsBlob\";\nimport { validateRecordOrThrow } from \"@/server/utils/validate-record-or-throw\";\nimport type { SupportedPDSDomain } from \"@/index\";\n\nexport const createOrUpdateOrganizationInfoFactory = <\n  T extends SupportedPDSDomain,\n>(\n  allowedPDSDomainSchema: z.ZodEnum<Record<T, T>>\n) => {\n  return protectedProcedure\n    .input(z.object({ did: z.string(), pdsDomain: allowedPDSDomainSchema }))\n    .mutation(async ({ input }) => {\n      return await protectedProcedure\n        .input(\n          z.object({\n            did: z.string(),\n            info: z.object({\n              displayName: z.string(),\n              shortDescription: z.string(),\n              longDescription: z.string(),\n              website: z.string().optional(),\n              logo: BlobRefGeneratorSchema.optional(),\n              coverImage: BlobRefGeneratorSchema.optional(),\n              objectives: z.array(\n                z.enum([\n                  \"Conservation\",\n                  \"Research\",\n                  \"Education\",\n                  \"Community\",\n                  \"Other\",\n                ])\n              ),\n              startDate: z.string().optional(),\n              country: z.string(),\n              visibility: z.enum([\"Public\", \"Hidden\"]),\n            }),\n            uploads: z\n              .object({\n                logo: FileGeneratorSchema.optional(),\n                coverImage: FileGeneratorSchema.optional(),\n              })\n              .optional(),\n            pdsDomain: allowedPDSDomainSchema,\n          })\n        )\n        .mutation(async ({ input }) => {\n          const agent = await getWriteAgent(input.pdsDomain);\n          const logoBlob =\n            input.uploads?.logo ?\n              (await uploadFileAsBlobPure(input.uploads.logo, agent)).blob\n            : input.info.logo ? toBlobRef(input.info.logo)\n            : undefined;\n          const coverImageBlob =\n            input.uploads?.coverImage ?\n              (await uploadFileAsBlobPure(input.uploads.coverImage, agent)).blob\n            : input.info.coverImage ? toBlobRef(input.info.coverImage)\n            : undefined;\n\n          const info: AppGainforestOrganizationInfo.Record = {\n            $type: \"app.gainforest.organization.info\",\n            displayName: input.info.displayName,\n            shortDescription: input.info.shortDescription,\n            longDescription: input.info.longDescription,\n            website: input.info.website ? input.info.website : undefined,\n            logo:\n              logoBlob ?\n                {\n                  $type: \"app.gainforest.common.defs#smallImage\",\n                  image: logoBlob,\n                }\n              : undefined,\n            coverImage:\n              coverImageBlob ?\n                {\n                  $type: \"app.gainforest.common.defs#smallImage\",\n                  image: coverImageBlob,\n                }\n              : undefined,\n            objectives: input.info.objectives,\n            startDate: input.info.startDate ? input.info.startDate : undefined,\n            country: input.info.country,\n            visibility: input.info.visibility,\n          };\n\n          validateRecordOrThrow(info, AppGainforestOrganizationInfo);\n\n          const response = await agent.com.atproto.repo.putRecord({\n            repo: input.did,\n            collection: \"app.gainforest.organization.info\",\n            record: info,\n            rkey: \"self\",\n          });\n\n          if (response.success !== true) {\n            throw new TRPCError({\n              code: \"INTERNAL_SERVER_ERROR\",\n              message: \"Failed to update organization info\",\n            });\n          }\n\n          return {\n            ...response.data,\n            value: info,\n          } as PutRecordResponse<AppGainforestOrganizationInfo.Record>;\n        });\n    });\n};\n","import { publicProcedure } from \"@/server/trpc\";\nimport { z } from \"zod\";\nimport { TRPCError } from \"@trpc/server\";\nimport {\n  AppGainforestOrganizationDefaultSite,\n  AppGainforestOrganizationSite,\n} from \"@/../lex-api\";\nimport { tryCatch } from \"@/lib/tryCatch\";\nimport { XRPCError } from \"@atproto/xrpc\";\nimport { getReadAgent } from \"@/server/utils/agent\";\nimport { xrpcErrorToTRPCError } from \"@/server/utils/classify-xrpc-error\";\nimport { validateRecordOrThrow } from \"@/server/utils/validate-record-or-throw\";\nimport type { SupportedPDSDomain } from \"@/index\";\nimport type { GetRecordResponse } from \"@/server/utils/response-types\";\n\nexport const getAllSitesFactory = <T extends SupportedPDSDomain>(\n  allowedPDSDomainSchema: z.ZodEnum<Record<T, T>>\n) => {\n  return publicProcedure\n    .input(z.object({ did: z.string(), pdsDomain: allowedPDSDomainSchema }))\n    .query(async ({ input }) => {\n      const agent = getReadAgent(input.pdsDomain);\n      const listSitesTryCatchPromise = tryCatch(\n        agent.com.atproto.repo.listRecords({\n          collection: \"app.gainforest.organization.site\",\n          repo: input.did,\n        })\n      );\n      const getDefaultSiteTryCatchPromise = tryCatch(\n        agent.com.atproto.repo.getRecord({\n          collection: \"app.gainforest.organization.defaultSite\",\n          repo: input.did,\n          rkey: \"self\",\n        })\n      );\n\n      const [\n        [listSitesResponse, errorListSites],\n        [getDefaultSiteResponse, errorGetDefaultSite],\n      ] = await Promise.all([\n        listSitesTryCatchPromise,\n        getDefaultSiteTryCatchPromise,\n      ]);\n\n      if (errorListSites) {\n        if (errorListSites instanceof XRPCError) {\n          const trpcError = xrpcErrorToTRPCError(errorListSites);\n          throw trpcError;\n        }\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"An unknown error occurred.\",\n        });\n      } else if (listSitesResponse.success !== true) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"An unknown error occurred.\",\n        });\n      }\n\n      const validRecords = listSitesResponse.data.records\n        .map((record) => {\n          const result = AppGainforestOrganizationSite.validateRecord(\n            record.value\n          );\n          if (result.success) return record;\n          return null;\n        })\n        .filter(\n          (record) => record !== null\n        ) as GetRecordResponse<AppGainforestOrganizationSite.Record>[];\n\n      let defaultSite = null;\n      if (getDefaultSiteResponse) {\n        defaultSite =\n          getDefaultSiteResponse.data as GetRecordResponse<AppGainforestOrganizationDefaultSite.Record>;\n        try {\n          validateRecordOrThrow(\n            defaultSite.value,\n            AppGainforestOrganizationDefaultSite\n          );\n        } catch {\n          defaultSite = null;\n        }\n      }\n\n      return {\n        sites: validRecords,\n        defaultSite,\n      };\n    });\n};\n","import { protectedProcedure } from \"@/server/trpc\";\nimport { z } from \"zod\";\nimport { getWriteAgent } from \"@/server/utils/agent\";\nimport { AppGainforestOrganizationSite } from \"@/../lex-api\";\nimport { FileGeneratorSchema, toFile } from \"@/zod-schemas/file\";\nimport { TRPCError } from \"@trpc/server\";\nimport { computeGeojsonFile, fetchGeojsonFromUrl } from \"./utils\";\nimport type { SupportedPDSDomain } from \"@/index\";\n\nexport const createSiteFactory = <T extends SupportedPDSDomain>(\n  allowedPDSDomainSchema: z.ZodEnum<Record<T, T>>\n) => {\n  return protectedProcedure\n    .input(\n      z.object({\n        rkey: z.string().optional(),\n        site: z.object({\n          name: z.string().min(1),\n        }),\n        uploads: z.object({\n          shapefile: z.union([z.url(), FileGeneratorSchema]),\n        }),\n        pdsDomain: allowedPDSDomainSchema,\n      })\n    )\n    .mutation(async ({ input }) => {\n      const agent = await getWriteAgent(input.pdsDomain);\n      if (!agent.did) {\n        throw new TRPCError({\n          code: \"UNAUTHORIZED\",\n          message: \"You are not authenticated\",\n        });\n      }\n\n      // If the site is a string, it is a URI, so fetch the file from the URI\n      const file =\n        typeof input.uploads.shapefile === \"string\" ?\n          await fetchGeojsonFromUrl(input.uploads.shapefile)\n        : await toFile(input.uploads.shapefile);\n\n      const { lat, lon, area } = await computeGeojsonFile(file);\n\n      const geojsonUploadResponse = await agent.uploadBlob(file);\n      const geojsonBlobRef = geojsonUploadResponse.data.blob;\n\n      const nsid: AppGainforestOrganizationSite.Record[\"$type\"] =\n        \"app.gainforest.organization.site\";\n      const site: AppGainforestOrganizationSite.Record = {\n        $type: nsid,\n        name: input.site.name,\n        lat: lat,\n        lon: lon,\n        area: area,\n        shapefile: {\n          $type: \"app.gainforest.common.defs#smallBlob\",\n          blob: geojsonBlobRef,\n        },\n      };\n\n      const validationResult =\n        AppGainforestOrganizationSite.validateRecord(site);\n      if (!validationResult.success) {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: validationResult.error.message,\n        });\n      }\n\n      const creationResponse = await agent.com.atproto.repo.createRecord({\n        collection: nsid,\n        repo: agent.did,\n        record: site,\n        rkey: input.rkey,\n      });\n\n      if (creationResponse.success !== true) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to add new site\",\n        });\n      }\n\n      return creationResponse.data;\n    });\n};\n","import type { GeoJsonObject } from \"geojson\";\nimport { TRPCError } from \"@trpc/server\";\nimport { validateGeojsonOrThrow } from \"@/lib/geojson/validate\";\nimport { tryCatch } from \"@/lib/tryCatch\";\nimport { computePolygonMetrics } from \"@/lib/geojson/computations\";\n\nexport async function fetchGeojsonFromUrl(url: string) {\n  const response = await fetch(url);\n  if (!response.ok) {\n    throw new TRPCError({\n      code: \"INTERNAL_SERVER_ERROR\",\n      message: \"Failed to fetch site\",\n    });\n  }\n  const blob = await response.blob();\n  if (blob.type !== \"application/geo+json\") {\n    throw new TRPCError({\n      code: \"BAD_REQUEST\",\n      message: \"Site must be a GeoJSON file\",\n    });\n  }\n  const file = new File([blob], \"site.geojson\", {\n    type: blob.type,\n  });\n  return file;\n}\n\nexport async function computeGeojsonFile(file: File) {\n  if (file.type !== \"application/geo+json\") {\n    throw new TRPCError({\n      code: \"BAD_REQUEST\",\n      message: \"Site must be a GeoJSON file\",\n    });\n  }\n\n  const geojsonText = await file.text();\n  const geojson = JSON.parse(geojsonText);\n  const [validatedGeojsonObject, geojsonValidationError] = await tryCatch(\n    new Promise<GeoJsonObject>((r) => r(validateGeojsonOrThrow(geojson)))\n  );\n\n  if (geojsonValidationError) {\n    throw new TRPCError({\n      code: \"BAD_REQUEST\",\n      message: \"Invalid GeoJSON file: \" + geojsonValidationError.message,\n    });\n  }\n\n  const polygonMetrics = computePolygonMetrics(validatedGeojsonObject);\n  const lat = polygonMetrics.centroid?.lat;\n  const lon = polygonMetrics.centroid?.lon;\n  const area = polygonMetrics.areaHectares;\n  if (!lat || !lon || !area) {\n    throw new TRPCError({\n      code: \"INTERNAL_SERVER_ERROR\",\n      message: \"Failed to process the geojson data.\",\n    });\n  }\n\n  return {\n    lat: lat.toFixed(6),\n    lon: lon.toFixed(6),\n    area: area.toFixed(2),\n  };\n}\n","import type {\n  Feature,\n  FeatureCollection,\n  GeoJsonObject,\n  Geometry,\n  GeometryCollection,\n  MultiPolygon,\n  Polygon,\n  Position,\n} from \"geojson\";\nimport {\n  area as turfArea,\n  bbox as turfBbox,\n  centerOfMass,\n  centroid as turfCentroid,\n  featureCollection,\n} from \"@turf/turf\";\n\nexport type Coordinates = {\n  lat: number;\n  lon: number;\n};\n\nexport type PolygonMetrics = {\n  areaSqMeters: number | null;\n  areaHectares: number | null;\n  centroid: Coordinates | null;\n  bbox: [number, number, number, number] | null;\n};\n\nexport const HECTARES_PER_SQUARE_METER = 0.0001;\n\nconst isFeatureCollection = (\n  value: GeoJsonObject\n): value is FeatureCollection => value.type === \"FeatureCollection\";\n\nconst isFeature = (value: GeoJsonObject): value is Feature =>\n  value.type === \"Feature\";\n\nconst isGeometryCollection = (value: Geometry): value is GeometryCollection =>\n  value.type === \"GeometryCollection\";\n\nconst isPolygon = (value: Geometry): value is Polygon =>\n  value.type === \"Polygon\";\n\nconst isMultiPolygon = (value: Geometry): value is MultiPolygon =>\n  value.type === \"MultiPolygon\";\n\nconst toFeature = (geometry: Geometry): Feature<Geometry> => ({\n  type: \"Feature\",\n  geometry,\n  properties: {},\n});\n\nconst extractPolygonFeatures = (\n  input: GeoJsonObject\n): Feature<Polygon | MultiPolygon>[] => {\n  if (isFeatureCollection(input)) {\n    return input.features.flatMap((feature) => extractPolygonFeatures(feature));\n  }\n\n  if (isFeature(input)) {\n    const geometry = input.geometry;\n    if (!geometry) return [];\n\n    if (isGeometryCollection(geometry)) {\n      return geometry.geometries.flatMap((subGeometry) =>\n        extractPolygonFeatures(toFeature(subGeometry))\n      );\n    }\n\n    if (isPolygon(geometry) || isMultiPolygon(geometry)) {\n      return [input as Feature<Polygon | MultiPolygon>];\n    }\n\n    return [];\n  }\n\n  const geometry = input as Geometry;\n\n  if (isGeometryCollection(geometry)) {\n    return geometry.geometries.flatMap((subGeometry) =>\n      extractPolygonFeatures(toFeature(subGeometry))\n    );\n  }\n\n  if (isPolygon(geometry) || isMultiPolygon(geometry)) {\n    return [toFeature(geometry) as Feature<Polygon | MultiPolygon>];\n  }\n\n  return [];\n};\n\nconst computeCentroid = (\n  features: Feature<Polygon | MultiPolygon>[]\n): Position | null => {\n  if (features.length === 0) return null;\n\n  const collection = featureCollection(features);\n\n  try {\n    const { geometry } = centerOfMass(collection);\n    return geometry.coordinates;\n  } catch {\n    try {\n      const { geometry } = turfCentroid(collection);\n      return geometry.coordinates;\n    } catch {\n      return null;\n    }\n  }\n};\n\nexport const computePolygonMetrics = (\n  geoJson: GeoJsonObject\n): PolygonMetrics => {\n  const polygonFeatures = extractPolygonFeatures(geoJson);\n\n  if (polygonFeatures.length === 0) {\n    return {\n      areaSqMeters: null,\n      areaHectares: null,\n      centroid: null,\n      bbox: null,\n    };\n  }\n\n  const areaSqMeters = polygonFeatures.reduce(\n    (acc, feature) => acc + turfArea(feature),\n    0\n  );\n\n  const centroidPosition = computeCentroid(polygonFeatures);\n  const bbox = turfBbox(featureCollection(polygonFeatures)) as [\n    number,\n    number,\n    number,\n    number,\n  ];\n\n  let centroid: Coordinates | null = null;\n\n  if (\n    centroidPosition &&\n    centroidPosition[0] !== undefined &&\n    centroidPosition[1] !== undefined\n  ) {\n    const [lon, lat] = centroidPosition;\n    centroid = { lat, lon };\n  }\n\n  return {\n    areaSqMeters,\n    areaHectares: areaSqMeters * HECTARES_PER_SQUARE_METER,\n    centroid,\n    bbox,\n  };\n};\n\nexport const toFeatureCollection = (\n  geoJson: GeoJsonObject\n): FeatureCollection => {\n  if (isFeatureCollection(geoJson)) return geoJson;\n\n  if (isFeature(geoJson)) {\n    return featureCollection([geoJson]);\n  }\n\n  return featureCollection([toFeature(geoJson as Geometry)]);\n};\n","import { protectedProcedure } from \"@/server/trpc\";\nimport { z } from \"zod\";\nimport { getWriteAgent } from \"@/server/utils/agent\";\nimport { AppGainforestOrganizationSite } from \"@/../lex-api\";\nimport { BlobRefGeneratorSchema, toBlobRef } from \"@/zod-schemas/blobref\";\nimport { FileGeneratorSchema, toFile } from \"@/zod-schemas/file\";\nimport { TRPCError } from \"@trpc/server\";\nimport { computeGeojsonFile, fetchGeojsonFromUrl } from \"./utils\";\nimport type { SupportedPDSDomain } from \"@/index\";\nimport {\n  type SmallBlob,\n  type Uri,\n} from \"@/../lex-api/types/app/gainforest/common/defs\";\nimport type { $Typed } from \"@/../lex-api/util\";\n\nexport const updateSiteFactory = <T extends SupportedPDSDomain>(\n  allowedPDSDomainSchema: z.ZodEnum<Record<T, T>>\n) => {\n  return protectedProcedure\n    .input(\n      z.object({\n        rkey: z.string(),\n        site: z.object({\n          name: z.string().min(1),\n          shapefile: z\n            .union([\n              z.object({\n                $type: z.literal(\"app.gainforest.common.defs#smallBlob\"),\n                blob: BlobRefGeneratorSchema,\n              }),\n              z.object({\n                $type: z.literal(\"app.gainforest.common.defs#uri\"),\n                uri: z.string(),\n              }),\n            ])\n            .optional(),\n          lat: z.string(),\n          lon: z.string(),\n          area: z.string(),\n        }),\n        uploads: z\n          .object({\n            shapefile: z.union([z.url(), FileGeneratorSchema]).optional(),\n          })\n          .optional(),\n        pdsDomain: allowedPDSDomainSchema,\n      })\n    )\n    .mutation(async ({ input }) => {\n      const agent = await getWriteAgent(input.pdsDomain);\n      if (!agent.did) {\n        throw new TRPCError({\n          code: \"UNAUTHORIZED\",\n          message: \"You are not authenticated\",\n        });\n      }\n\n      let file: File | null = null;\n      // Upload the shapefile if provided\n      if (input.uploads) {\n        if (input.uploads.shapefile === undefined) {\n          file = null;\n        } else if (typeof input.uploads.shapefile === \"string\") {\n          file = await fetchGeojsonFromUrl(input.uploads.shapefile);\n        } else {\n          file = await toFile(input.uploads.shapefile);\n        }\n      }\n\n      // Compute the lat, lon, and area from the shapefile\n      let lat: string;\n      let lon: string;\n      let area: string;\n      let shapefile: $Typed<Uri> | $Typed<SmallBlob> | undefined;\n      if (file !== null) {\n        const computed = await computeGeojsonFile(file);\n        const geojsonUploadResponse = await agent.uploadBlob(file);\n        shapefile = {\n          $type: \"app.gainforest.common.defs#smallBlob\",\n          blob: geojsonUploadResponse.data.blob,\n        };\n        lat = computed.lat;\n        lon = computed.lon;\n        area = computed.area;\n      } else if (input.site.shapefile) {\n        shapefile =\n          (\n            input.site.shapefile.$type ===\n            \"app.gainforest.common.defs#smallBlob\"\n          ) ?\n            {\n              $type: \"app.gainforest.common.defs#smallBlob\",\n              blob: toBlobRef(input.site.shapefile.blob),\n            }\n          : input.site.shapefile;\n        lat = input.site.lat;\n        lon = input.site.lon;\n        area = input.site.area;\n      } else {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"No shapefile provided\",\n        });\n      }\n\n      const nsid: AppGainforestOrganizationSite.Record[\"$type\"] =\n        \"app.gainforest.organization.site\";\n      const site: AppGainforestOrganizationSite.Record = {\n        $type: nsid,\n        name: input.site.name,\n        lat: lat,\n        lon: lon,\n        area: area,\n        shapefile,\n      };\n\n      const validationResult =\n        AppGainforestOrganizationSite.validateRecord(site);\n      if (!validationResult.success) {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: validationResult.error.message,\n        });\n      }\n\n      const updateResponse = await agent.com.atproto.repo.putRecord({\n        collection: nsid,\n        repo: agent.did,\n        record: site,\n        rkey: input.rkey,\n      });\n\n      if (updateResponse.success !== true) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to update site\",\n        });\n      }\n\n      return updateResponse.data;\n    });\n};\n","import { protectedProcedure } from \"@/server/trpc\";\nimport z from \"zod\";\nimport {\n  AppGainforestOrganizationDefaultSite,\n  AppGainforestOrganizationSite,\n} from \"@/../lex-api\";\nimport { getWriteAgent } from \"@/server/utils/agent\";\nimport { TRPCError } from \"@trpc/server\";\nimport parseAtUri from \"@/utilities/parseAtUri\";\nimport { validateRecordOrThrow } from \"@/server/utils/validate-record-or-throw\";\nimport type { SupportedPDSDomain } from \"@/index\";\n\nexport const setDefaultSiteFactory = <T extends SupportedPDSDomain>(\n  allowedPDSDomainSchema: z.ZodEnum<Record<T, T>>\n) => {\n  return protectedProcedure\n    .input(\n      z.object({\n        siteAtUri: z.string(),\n        pdsDomain: allowedPDSDomainSchema,\n      })\n    )\n    .mutation(async ({ input }) => {\n      const agent = await getWriteAgent(input.pdsDomain);\n      if (!agent.did) {\n        throw new TRPCError({\n          code: \"UNAUTHORIZED\",\n          message: \"You are not authenticated\",\n        });\n      }\n\n      const siteUri = input.siteAtUri;\n      const siteNSID: AppGainforestOrganizationSite.Record[\"$type\"] =\n        \"app.gainforest.organization.site\";\n      if (!(siteUri.startsWith(`at://`) && siteUri.includes(siteNSID))) {\n        throw new TRPCError({\n          code: \"BAD_REQUEST\",\n          message: \"Invalid site URI\",\n        });\n      }\n\n      const site = await agent.com.atproto.repo.getRecord({\n        collection: siteNSID,\n        repo: agent.did,\n        rkey: parseAtUri(siteUri).rkey,\n      });\n      if (site.success !== true) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to get site\",\n        });\n      }\n\n      const defaultSiteNSID: AppGainforestOrganizationDefaultSite.Record[\"$type\"] =\n        \"app.gainforest.organization.defaultSite\";\n      const defaultSite: AppGainforestOrganizationDefaultSite.Record = {\n        $type: defaultSiteNSID,\n        site: siteUri,\n      };\n      validateRecordOrThrow(defaultSite, AppGainforestOrganizationDefaultSite);\n      const updateDefaultSiteResponse = await agent.com.atproto.repo.putRecord({\n        collection: defaultSiteNSID,\n        repo: agent.did,\n        rkey: \"self\",\n        record: defaultSite,\n      });\n\n      if (updateDefaultSiteResponse.success !== true) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to update default site\",\n        });\n      }\n\n      return updateDefaultSiteResponse.data;\n    });\n};\n","import { AppGainforestOrganizationDefaultSite } from \"@/../lex-api\";\nimport { protectedProcedure } from \"@/server/trpc\";\nimport { getWriteAgent } from \"@/server/utils/agent\";\nimport { TRPCError } from \"@trpc/server\";\nimport z from \"zod\";\nimport { validateRecordOrThrow } from \"@/server/utils/validate-record-or-throw\";\nimport type { SupportedPDSDomain } from \"@/index\";\nimport { parseAtUri } from \"@/utilities\";\n\nexport const deleteSiteFactory = <T extends SupportedPDSDomain>(\n  allowedPDSDomainSchema: z.ZodEnum<Record<T, T>>\n) => {\n  return protectedProcedure\n    .input(\n      z.object({ siteAtUri: z.string(), pdsDomain: allowedPDSDomainSchema })\n    )\n    .mutation(async ({ input }) => {\n      const agent = await getWriteAgent(input.pdsDomain);\n      if (!agent.did) {\n        throw new TRPCError({\n          code: \"UNAUTHORIZED\",\n          message: \"You are not authenticated\",\n        });\n      }\n\n      try {\n        // Check if the site is the default site\n        const defaultSiteNSID: AppGainforestOrganizationDefaultSite.Record[\"$type\"] =\n          \"app.gainforest.organization.defaultSite\";\n        const defaultSiteResponse = await agent.com.atproto.repo.getRecord({\n          collection: defaultSiteNSID,\n          repo: agent.did,\n          rkey: \"self\",\n        });\n        if (defaultSiteResponse.success !== true)\n          throw Error(\"Failed to get default site\");\n        validateRecordOrThrow(\n          defaultSiteResponse.data.value,\n          AppGainforestOrganizationDefaultSite\n        );\n        const defaultSite = defaultSiteResponse.data\n          .value as AppGainforestOrganizationDefaultSite.Record;\n        if (defaultSite.site === input.siteAtUri) throw new Error(\"Equal\");\n      } catch (error) {\n        // Only take action if the default site is determined and equals the site to be deleted\n        if (error instanceof Error && error.message === \"Equal\") {\n          throw new TRPCError({\n            code: \"BAD_REQUEST\",\n            message: \"Cannot delete default site\",\n          });\n        }\n      }\n\n      const deletionResponse = await agent.com.atproto.repo.deleteRecord({\n        collection: \"app.gainforest.organization.site\",\n        repo: agent.did,\n        rkey: parseAtUri(input.siteAtUri).rkey,\n      });\n      if (deletionResponse.success !== true)\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to delete site\",\n        });\n\n      return deletionResponse.data;\n    });\n};\n","import { tryCatch } from \"@/lib/tryCatch\";\nimport { publicProcedure } from \"@/server/trpc\";\nimport { getReadAgent } from \"@/server/utils/agent\";\nimport { z } from \"zod\";\nimport { TRPCError } from \"@trpc/server\";\nimport { getOrganizationInfoPure } from \"../../gainforest/organizationInfo/get\";\nimport { getAllClaimsPure } from \"./getAll\";\nimport { type Repo } from \"@atproto/api/dist/client/types/com/atproto/sync/listRepos\";\nimport {\n  AppGainforestOrganizationInfo,\n  OrgHypercertsClaimClaim,\n} from \"@/../lex-api\";\nimport type { GetRecordResponse } from \"@/server/utils/response-types\";\nimport type { SupportedPDSDomain } from \"@/index\";\n\nexport type OrganizationWithClaims = {\n  repo: Repo;\n  organizationInfo: AppGainforestOrganizationInfo.Record;\n  claims: GetRecordResponse<OrgHypercertsClaimClaim.Record>[];\n};\n\nexport const getAllClaimsAcrossOrganizationsFactory = <\n  T extends SupportedPDSDomain,\n>(\n  allowedPDSDomainSchema: z.ZodEnum<Record<T, T>>\n) => {\n  return publicProcedure\n    .input(z.object({ pdsDomain: allowedPDSDomainSchema }))\n    .query(async ({ input }) => {\n      const agent = getReadAgent(input.pdsDomain);\n\n      // Get all the repositories\n      const [repositoriesListResponse, repositoriesListFetchError] =\n        await tryCatch(\n          agent.com.atproto.sync.listRepos({\n            limit: 100,\n          })\n        );\n      if (\n        repositoriesListFetchError ||\n        repositoriesListResponse.success !== true\n      ) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to fetch repositories list\",\n        });\n      }\n      const repositoriesList = repositoriesListResponse.data.repos;\n\n      // Filter the repositories that are organizations\n      const [organizationRepositories, organizationsFetchError] =\n        await tryCatch(\n          Promise.all(\n            repositoriesList.map(async (repo) => {\n              const [organizationInfoResponse, organizationInfoFetchError] =\n                await tryCatch(\n                  getOrganizationInfoPure(repo.did, input.pdsDomain)\n                );\n              if (organizationInfoFetchError) {\n                return null;\n              }\n              return {\n                repo: repo,\n                organizationInfo: organizationInfoResponse.value,\n              };\n            })\n          )\n        );\n      if (organizationsFetchError) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to fetch organizations list\",\n        });\n      }\n      const validOrganizationRepositories = organizationRepositories.filter(\n        (org): org is NonNullable<typeof org> => org !== null\n      );\n\n      // Get all the claims for the organizations\n      const [claims, claimsFetchError] = await tryCatch(\n        Promise.all(\n          validOrganizationRepositories.map(async (organization) => {\n            const [claimsResponse, claimsFetchError] = await tryCatch(\n              getAllClaimsPure(organization.repo.did, input.pdsDomain)\n            );\n            if (claimsFetchError) {\n              return null;\n            }\n            return {\n              repo: organization.repo,\n              claims: claimsResponse.claims,\n              organizationInfo: organization.organizationInfo,\n            };\n          })\n        )\n      );\n      if (claimsFetchError) {\n        throw new TRPCError({\n          code: \"INTERNAL_SERVER_ERROR\",\n          message: \"Failed to fetch claims list\",\n        });\n      }\n\n      const validClaims = claims.filter(\n        (claim): claim is NonNullable<typeof claim> => claim !== null\n      );\n      return validClaims satisfies OrganizationWithClaims[];\n    });\n};\n","import { publicProcedure } from \"@/server/trpc\";\nimport { z } from \"zod\";\nimport type { GetRecordResponse } from \"@/server/utils/response-types\";\nimport { TRPCError } from \"@trpc/server\";\nimport { OrgHypercertsClaimClaim } from \"@/../lex-api\";\nimport { tryCatch } from \"@/lib/tryCatch\";\nimport { XRPCError } from \"@atproto/xrpc\";\nimport { getReadAgent } from \"@/server/utils/agent\";\nimport { xrpcErrorToTRPCError } from \"@/server/utils/classify-xrpc-error\";\nimport { validateRecordOrThrow } from \"@/server/utils/validate-record-or-throw\";\nimport type { SupportedPDSDomain } from \"@/index\";\n\nexport const getAllClaimsPure = async <T extends SupportedPDSDomain>(\n  did: string,\n  pdsDomain: T\n) => {\n  const claimNSID: OrgHypercertsClaimClaim.Record[\"$type\"] =\n    \"org.hypercerts.claim.claim\";\n  const agent = getReadAgent(pdsDomain);\n  const [listClaimsResponse, errorListClaims] = await tryCatch(\n    agent.com.atproto.repo.listRecords({\n      collection: claimNSID,\n      repo: did,\n    })\n  );\n\n  if (errorListClaims) {\n    if (errorListClaims instanceof XRPCError) {\n      const trpcError = xrpcErrorToTRPCError(errorListClaims);\n      throw trpcError;\n    }\n    throw new TRPCError({\n      code: \"INTERNAL_SERVER_ERROR\",\n      message: \"An unknown error occurred.\",\n    });\n  } else if (listClaimsResponse.success !== true) {\n    throw new TRPCError({\n      code: \"INTERNAL_SERVER_ERROR\",\n      message: \"An unknown error occurred.\",\n    });\n  }\n\n  const validRecords = listClaimsResponse.data.records\n    .map((record) => {\n      try {\n        validateRecordOrThrow(record.value, OrgHypercertsClaimClaim);\n        return record;\n      } catch {\n        return null;\n      }\n    })\n    .filter(\n      (record) => record !== null\n    ) as GetRecordResponse<OrgHypercertsClaimClaim.Record>[];\n\n  return {\n    claims: validRecords,\n  };\n};\n\nexport const getAllClaimsFactory = <T extends SupportedPDSDomain>(\n  allowedPDSDomainSchema: z.ZodEnum<Record<T, T>>\n) => {\n  return publicProcedure\n    .input(\n      z.object({\n        did: z.string(),\n        pdsDomain: allowedPDSDomainSchema,\n      })\n    )\n    .query(async ({ input }) => {\n      return await getAllClaimsPure(input.did, input.pdsDomain);\n    });\n};\n","import { publicProcedure } from \"@/server/trpc\";\nimport { z } from \"zod\";\nimport { tryCatch } from \"@/lib/tryCatch\";\nimport { XRPCError } from \"@atproto/xrpc\";\nimport type { GetRecordResponse } from \"@/server/utils/response-types\";\nimport { OrgHypercertsClaimClaim } from \"@/../lex-api\";\nimport { getReadAgent } from \"@/server/utils/agent\";\nimport { xrpcErrorToTRPCError } from \"@/server/utils/classify-xrpc-error\";\nimport { TRPCError } from \"@trpc/server\";\nimport { validateRecordOrThrow } from \"@/server/utils/validate-record-or-throw\";\nimport type { SupportedPDSDomain } from \"@/index\";\n\nexport const getHypercertClaimPure = async <T extends SupportedPDSDomain>(\n  did: string,\n  rkey: string,\n  pdsDomain: T\n) => {\n  const agent = getReadAgent(pdsDomain);\n  const getRecordPromise = agent.com.atproto.repo.getRecord({\n    collection: \"org.hypercerts.claim.claim\",\n    repo: did,\n    rkey: rkey,\n  });\n  const [response, error] = await tryCatch(getRecordPromise);\n\n  if (error) {\n    if (error instanceof XRPCError) {\n      const trpcError = xrpcErrorToTRPCError(error);\n      throw trpcError;\n    } else {\n      throw new TRPCError({\n        code: \"INTERNAL_SERVER_ERROR\",\n        message: \"An unknown error occurred.\",\n      });\n    }\n  }\n\n  if (response.success !== true) {\n    throw new TRPCError({\n      code: \"INTERNAL_SERVER_ERROR\",\n      message: \"Failed to get organization info.\",\n    });\n  }\n\n  validateRecordOrThrow(response.data.value, OrgHypercertsClaimClaim);\n\n  return response.data as GetRecordResponse<OrgHypercertsClaimClaim.Record>;\n};\n\nexport const getHypercertClaimFactory = <T extends SupportedPDSDomain>(\n  allowedPDSDomainSchema: z.ZodEnum<Record<T, T>>\n) => {\n  return publicProcedure\n    .input(\n      z.object({\n        did: z.string(),\n        rkey: z.string(),\n        pdsDomain: allowedPDSDomainSchema,\n      })\n    )\n    .query(async ({ input }) => {\n      return await getHypercertClaimPure(\n        input.did,\n        input.rkey,\n        input.pdsDomain\n      );\n    });\n};\n","import { publicProcedure } from \"@/server/trpc\";\nimport { z } from \"zod\";\nimport { tryCatch } from \"@/lib/tryCatch\";\nimport { XRPCError } from \"@atproto/xrpc\";\nimport { type GetRecordResponse } from \"@/server/utils/response-types\";\nimport { AppCertifiedLocation } from \"@/../lex-api\";\nimport { getReadAgent } from \"@/server/utils/agent\";\nimport { xrpcErrorToTRPCError } from \"@/server/utils/classify-xrpc-error\";\nimport { TRPCError } from \"@trpc/server\";\nimport { validateRecordOrThrow } from \"@/server/utils/validate-record-or-throw\";\nimport type { SupportedPDSDomain } from \"@/index\";\n\nexport const getCertifiedLocationPure = async <T extends SupportedPDSDomain>(\n  did: string,\n  rkey: string,\n  pdsDomain: T\n) => {\n  const agent = getReadAgent(pdsDomain);\n  const getRecordPromise = agent.com.atproto.repo.getRecord({\n    collection: \"app.certified.location\",\n    repo: did,\n    rkey: rkey,\n  });\n  const [response, error] = await tryCatch(getRecordPromise);\n\n  if (error) {\n    if (error instanceof XRPCError) {\n      const trpcError = xrpcErrorToTRPCError(error);\n      throw trpcError;\n    } else {\n      throw new TRPCError({\n        code: \"INTERNAL_SERVER_ERROR\",\n        message: \"An unknown error occurred.\",\n      });\n    }\n  }\n\n  if (response.success !== true) {\n    throw new TRPCError({\n      code: \"INTERNAL_SERVER_ERROR\",\n      message: \"Failed to get organization info.\",\n    });\n  }\n\n  validateRecordOrThrow(response.data.value, AppCertifiedLocation);\n\n  return response.data as GetRecordResponse<AppCertifiedLocation.Record>;\n};\n\nexport const getCertifiedLocationFactory = <T extends SupportedPDSDomain>(\n  allowedPDSDomainSchema: z.ZodEnum<Record<T, T>>\n) => {\n  return publicProcedure\n    .input(\n      z.object({\n        did: z.string(),\n        rkey: z.string(),\n        pdsDomain: allowedPDSDomainSchema,\n      })\n    )\n    .query(async ({ input }) => {\n      return await getCertifiedLocationPure(\n        input.did,\n        input.rkey,\n        input.pdsDomain\n      );\n    });\n};\n","import { createContext, createTRPCRouter, publicProcedure } from \"../trpc\";\nimport { uploadFileAsBlobFactory } from \"./atproto/common/uploadFileAsBlob\";\nimport { loginFactory } from \"./atproto/auth/login\";\nimport { resumeFactory } from \"./atproto/auth/resume\";\nimport { logoutFactory } from \"./atproto/auth/logout\";\nimport { getOrganizationInfoFactory } from \"./atproto/gainforest/organizationInfo/get\";\nimport { getSiteFactory } from \"./atproto/gainforest/site/get\";\nimport { getDefaultProjectSiteFactory } from \"./atproto/gainforest/site/getDefault\";\nimport { getMeasuredTreesFactory } from \"./atproto/gainforest/measuredTrees/get\";\nimport { createHypercertClaimFactory } from \"./atproto/hypercerts/claim/create\";\nimport { createOrUpdateOrganizationInfoFactory } from \"./atproto/gainforest/organizationInfo/createOrUpdate\";\nimport { getAllSitesFactory } from \"./atproto/gainforest/site/getAll\";\nimport { createSiteFactory } from \"./atproto/gainforest/site/create\";\nimport { updateSiteFactory } from \"./atproto/gainforest/site/update\";\nimport { setDefaultSiteFactory } from \"./atproto/gainforest/site/setDefault\";\nimport { deleteSiteFactory } from \"./atproto/gainforest/site/delete\";\nimport { getAllClaimsAcrossOrganizationsFactory } from \"./atproto/hypercerts/claim/getAllAcrossOrgs\";\nimport { getHypercertClaimFactory } from \"./atproto/hypercerts/claim/get\";\nimport { getCertifiedLocationFactory } from \"./atproto/hypercerts/location/get\";\nimport type { SupportedPDSDomain } from \"@/index\";\nimport z from \"zod\";\n\nexport class AppRouterFactory<T extends SupportedPDSDomain> {\n  public allowedPDSDomains;\n  public allowedPDSDomainSchema;\n  public appRouter;\n\n  constructor(_allowedPDSDomains: T[]) {\n    this.allowedPDSDomains = _allowedPDSDomains;\n    this.allowedPDSDomainSchema = z.enum(this.allowedPDSDomains);\n\n    this.appRouter = createTRPCRouter({\n      health: publicProcedure.query(() => ({ status: \"ok\" })),\n      common: {\n        uploadFileAsBlob: uploadFileAsBlobFactory(this.allowedPDSDomainSchema),\n      },\n      auth: {\n        login: loginFactory(this.allowedPDSDomainSchema),\n        resume: resumeFactory(this.allowedPDSDomainSchema),\n        logout: logoutFactory(this.allowedPDSDomainSchema),\n      },\n      gainforest: {\n        organization: {\n          info: {\n            get: getOrganizationInfoFactory(this.allowedPDSDomainSchema),\n            createOrUpdate: createOrUpdateOrganizationInfoFactory(\n              this.allowedPDSDomainSchema\n            ),\n          },\n          site: {\n            get: getSiteFactory(this.allowedPDSDomainSchema),\n            getAll: getAllSitesFactory(this.allowedPDSDomainSchema),\n            create: createSiteFactory(this.allowedPDSDomainSchema),\n            update: updateSiteFactory(this.allowedPDSDomainSchema),\n            delete: deleteSiteFactory(this.allowedPDSDomainSchema),\n            getDefault: getDefaultProjectSiteFactory(\n              this.allowedPDSDomainSchema\n            ),\n            setDefault: setDefaultSiteFactory(this.allowedPDSDomainSchema),\n          },\n          measuredTrees: {\n            get: getMeasuredTreesFactory(this.allowedPDSDomainSchema),\n          },\n        },\n      },\n      hypercerts: {\n        claim: {\n          create: createHypercertClaimFactory(this.allowedPDSDomainSchema),\n          getAllAcrossOrgs: getAllClaimsAcrossOrganizationsFactory(\n            this.allowedPDSDomainSchema\n          ),\n          get: getHypercertClaimFactory(this.allowedPDSDomainSchema),\n        },\n        location: {\n          get: getCertifiedLocationFactory(this.allowedPDSDomainSchema),\n        },\n      },\n    });\n  }\n\n  getServerCaller = () => {\n    return this.appRouter.createCaller(\n      async () =>\n        await createContext({ allowedPDSDomains: this.allowedPDSDomains })\n    );\n  };\n}\n\nexport type AppRouter<T extends SupportedPDSDomain> =\n  AppRouterFactory<T>[\"appRouter\"];\n"],"mappings":"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","names":["ResponseType","XRPCError","fetch","XrpcClient","import_zod","z","superjson","import_zod","import_api","import_server","import_zod","z","file","import_server","file","z","import_api","import_server","import_zod","z","import_server","import_zod","z","import_zod","z","import_zod","import_xrpc","import_lexicon","isObject","id","id","is$typed","validate","isMain","validateMain","is$typed","validate","id","hashMain","isMain","validateMain","isMain","validateMain","is$typed","validate","id","hashMain","isMain","validateMain","isMain","validateMain","is$typed","validate","id","hashMain","isMain","validateMain","isMain","validateMain","is$typed","validate","id","hashMain","isMain","validateMain","isMain","validateMain","is$typed","validate","id","hashMain","isMain","validateMain","isMain","validateMain","is$typed","validate","id","hashMain","isMain","validateMain","import_server","import_server","import_server","import_zod","import_zod","z","import_zod","z","import_zod","import_server","file","z","import_zod","import_server","z","input","import_zod","import_server","import_xrpc","import_zod","import_server","import_server","geometry","turfCentroid","turfArea","turfBbox","file","file","import_zod","import_server","file","import_zod","import_server","z","import_server","import_zod","z","import_zod","import_server","import_zod","import_server","import_xrpc","claimsFetchError","import_zod","import_xrpc","import_server","import_zod","import_xrpc","import_server","import_zod","z"]}